const Salaryslab = require("../../model/modules/setup/SalarySlabModel")
const RevenueAmount = require("../../model/modules/production/RevenueAmountModel");
const { format } = require('date-fns');
const ClientUserid = require("../../model/modules/production/ClientUserIDModel")
const User = require("../../model/login/auth");
const ErrorHandler = require("../../utils/errorhandler");
const catchAsyncErrors = require("../../middleware/catchAsyncError");
const bcrypt = require("bcryptjs");
const { decryptPassword } = require("./decryptPassword");
const sendToken = require("../../utils/jwttokentocookie");
const checksendToken = require("../../utils/checkjson");
const sendEmail = require("../../utils/pwdresetmail");
const ProcessTeam = require("../../model/modules/production/ProcessTeamModel");
const Targetpoints = require("../../model/modules/production/targetpoints");
const Noticeperiod = require("../../model/modules/recruitment/noticeperiodapply");
const AssignBranch = require("../../model/modules/assignbranch");
const AutoLogout = require("../../model/modules/settings/autologout");
const { ObjectId } = require("mongodb");
const crypto = require("crypto");
const qrcode = require("qrcode");
const moment = require("moment");
const { authenticator } = require("otplib");
const Token = require("../../model/login/token");
const sendVerificationEmail = require("./sendEmail");
const AdminOverAllSettings = require("../../model/modules/settings/AdminOverAllSettingsModel");
const IndividualSettings = require("../../model/modules/settings/IndividualSettingsModel");
const ClockinIP = require("../../model/modules/settings/clockinipModel");
const ControlCriteria = require("../../model/modules/settings/Attendancecontrolcriteria");
const Shift = require('../../model/modules/shift');
const Attendance = require("../../model/modules/attendance/attendance");
const DepartmentMonth = require("../../model/modules/departmentmonthset");
const ApplyLeave = require('../../model/modules/leave/applyleave');
const Holiday = require('../../model/modules/setup/holidayModel');
const Hirerarchi = require('../../model/modules/setup/hierarchy');
const Designation = require("../../model/modules/designation");
const Leavetype = require('../../model/modules/leave/leavetype');
const Permission = require('../../model/modules/permission/permission');
const EmployeeDocuments = require('../../model/login/employeedocuments');
const MyCheckList = require("../../model/modules/interview/Myinterviewchecklist");
const Company = require("../../model/modules/setup/company");
const workStation = require("../../model/modules/workstationmodel");
const Branch = require("../../model/modules/branch");
const Unit = require("../../model/modules/unit");
const currentDateAttStatus = new Date();
const faceapi = require("face-api.js");
const ShiftGrouping = require('../../model/modules/shiftgrouping');
const Leavecriteria = require("../../model/modules/leave/leavecriteria");


const formatDateRemove = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('-');

    return `${day}/${month}/${year}`;
};

// Compare manual date with with formattedDate
const formatDate = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');

    // Use padStart to add leading zeros
    const formattedDay = String(day)?.padStart(2, '0');
    const formattedMonth = String(month)?.padStart(2, '0');

    return `${formattedDay}/${formattedMonth}/${year}`;
};

// Att Month Status
const formatDateLeaveDate = (inputDate) => {
    if (!inputDate) {
        return '';
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [year, month, day] = inputDate?.split('-');
    return `${day}-${month}-${year}`;
};

// Compare manual date with with formattedDate
const formatDateForShiftDate = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');
    // Use padStart to add leading zeros
    const formattedDay = String(day)?.padStart(2, '0');
    const formattedMonth = String(month)?.padStart(2, '0');
    return `${formattedDay}-${formattedMonth}-${year}`;
};

// Compare approved adjdate with formattedDate
const formatAdjDate = (inputDate) => {
    if (!inputDate) {
        return "";
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');
    return `${day}-${month}-${year}`;
};

//const parseTime = (timeString) => {
// if (!timeString) {
//    return '';
//}

// // Check if the timeString contains a space
// const hasSpace = timeString?.includes(' ');

//  // Split based on whether there's a space or not
//  const [time, period] = hasSpace ? timeString?.split(' ') : [timeString?.slice(0, -2), timeString?.slice(-2)];

// const [hours, minutes, seconds] = time?.split(':');

//  let parsedHours = parseInt(hours, 10);

//  //if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
//  //  parsedHours += 12;
// // } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
//   //  parsedHours = 0;
// // }

//if ((period === 'PM' && parsedHours !== 12) || (period === 'pm' && parsedHours !== 12)) {
//  parsedHours += 12;
// }
//else if ((period === 'AM' && parsedHours === 12) || (period === 'am' && parsedHours === 12)) {
//parsedHours = 0;
//  }
// // if ((period === 'PM' || period === 'pm') && parsedHours !== 12) {
//  //  parsedHours += 12;
// // }
//  //else if ((period === 'AM' || period === 'am') && parsedHours === 12) {
// //  parsedHours = 0;
// //}


//  return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
//};

// const parseTime = (timeString) => {
//     if (!timeString) {
//         return '';
//     }

//     // Check if the timeString contains a space
//     const hasSpace = timeString?.includes(' ');

//     // Split based on whether there's a space or not
//     const [time, period] = hasSpace ? timeString?.split(' ') : [timeString.slice(0, -2), timeString.slice(-2)];

//     const [hours, minutes, seconds] = time?.split(':');

//     let parsedHours = parseInt(hours, 10);
//     if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
//         parsedHours += 12;
//     } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
//         parsedHours = 0;
//     }

//     return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
// };

const parseTime = (timeString) => {
    if (!timeString) {
        return '';
    }

    // Check if the timeString contains a space
    const hasSpace = timeString?.includes(' ');

    // Split based on whether there's a space or not
    const [time, period] = hasSpace ? timeString?.split(' ') : [timeString?.slice(0, -2), timeString?.slice(-2)];

    const [hours, minutes, seconds] = time?.split(':');

    let parsedHours = parseInt(hours, 10);

    if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
        parsedHours += 12;
    } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
        parsedHours = 0;
    }

    // if ((period === 'PM' && parsedHours !== 12) || (period === 'pm' && parsedHours !== 12)) {
    //     parsedHours += 12;
    // }
    // else if ((period === 'AM' && parsedHours === 12) || (period === 'am' && parsedHours === 12)) {
    //     parsedHours = 0;
    // }

    if ((period === 'PM' || period === 'pm') && parsedHours !== 12) {
        parsedHours += 12;
    }
    else if ((period === 'AM' || period === 'am') && parsedHours === 12) {
        parsedHours = 0;
    }

    return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
};


exports.getAllSalaryRevenueByCode = catchAsyncErrors(async (req, res, next) => {
    let salSlabs, revenueAmount;

    try {
        salSlabs = await Salaryslab.find({ salarycode: req.body.code }, { company: 1, branch: 1, salarycode: 1 });
        revenueAmount = await RevenueAmount.find({ processcode: req.body.code }, { company: 1, branch: 1, processcode: 1 });
        return res.status(200).json({ salSlabs, revenueAmount });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

});



exports.getAllUserProduction = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {

                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {

                resonablestatus: 1,


                company: 1,
                empcode: 1,
                companyname: 1,
                addremoteworkmode: 1,
                team: 1,
                username: 1,

                unit: 1,
                branch: 1,

                team: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ usersstatus });
});




exports.getAllEnquieryUsers = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: "Enquiry Purpose",
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

// get All user => /api/users
exports.getAllUsers = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                wfhstatus: 1,
                wfhcount: 1,
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                departmentlog: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                departmentlog: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllUserAaccessibleBranch = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { assignbranch } = req.body;

    // Create a query array for company and branch
    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: { $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"] }
    };

    try {
        users = await User.find(
            query,
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.userscheckBranch = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {},

            {
                empcode: 1,
                branch: 1,

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

// get All user => /api/allusers

exports.getAllTheUsers = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                workmode: {
                    $ne: "Internship",
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                status: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                addremoteworkmode: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                doj: 1,
                dot: 1,
                role: 1,
                assignExpLog: 1,
                resonablestatus: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,

                fathername: 1,
                mothername: 1,
                contactfamily: 1,
                contactno: 1,
                prefix: 1,
                assignExpMode: 1,
                assignExpvalue: 1,
                processtype: 1,
                processduration: 1,
                date: 1,
                time: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                dom: 1,

                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankdetails: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                shifttype: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                remoteworkmodestatus: 1,
                addremoteworkmode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});

exports.getAllTheLogUsers = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                workmode: {
                    $ne: "Internship",
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1, team: 1, company: 1, shift: 1, doj: 1, department: 1,
                designationlog: 1, departmentlog: 1,
                processlog: 1, boardingLog: 1,
                attendancemode: 1, designation: 1, floor: 1,
                reportingto: 1, shifttiming: 1, shiftgrouping: 1, shifttype: 1,
                weekoff: 1,
                area: 1,
                shiftallot: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});


// get All user => /api/allinterns
exports.getAllIntern = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                workmode: {
                    $in: "Internship",
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});

// get All user => /api/allinterns
exports.getAllDactiveIntern = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                workmode: {
                    $in: "Internship",
                },
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                originalpassword: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                firstname: 1,
                lastname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcity: 1,
                pstate: 1,
                pcountry: 1,
                dob: 1,
                contactpersonal: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});

const getShiftForDateAttMonthStatus = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment) => {

    if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
        return 'Pending...'
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {

        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // else if (boardingLog?.length > 0) {
    //     if (!recentShiftTimingDate) {
    //         return ""
    //     }
    //     // const [year, month, day] = recentShiftTimingDate?.split('-');
    //     // // Map through each column and compare dates
    //     // const shifts = tempResultDates?.map((currentColumn) => {
    //     //     const [day1, month1, year1] = currentColumn.formattedDate?.split('-');
    //     //     if (year >= year1 && month >= month1 && day >= day1) {
    //     //         return isWeekOffWithAdjustment ? actualShiftTiming : (!isWeekOff ? actualShiftTiming : "Week Off");
    //     //     }
    //     //     else {
    //     //         return isWeekOffWithAdjustment ? recentShiftTiming : (!isWeekOff ? recentShiftTiming : "Week Off");
    //     //     }
    //     // });
    //     const shifts = tempResultDates?.map((currentColumn) => {
    //         if (!recentShiftTimingDate) {
    //             return ""
    //         }
    //         const [columnDay, columnMonth, columnYear] = currentColumn.formattedDate?.split('/');
    //         const columnFormattedDate = new Date(`${columnMonth}/${columnDay}/${columnYear}`) + 1;
    //         const [shiftYear, shiftMonth, shiftDay] = recentShiftTimingDate?.split('-');
    //         const shiftFormattedDate = new Date(`${shiftMonth}/${shiftDay}/${shiftYear}`) + 1;

    //         if (shiftFormattedDate >= columnFormattedDate) {
    //             return isWeekOffWithAdjustment ? actualShiftTiming : (!isWeekOff ? actualShiftTiming : "Week Off");
    //         } else {
    //             return isWeekOffWithAdjustment ? recentShiftTiming : (!isWeekOff ? recentShiftTiming : "Week Off");
    //         }
    //     });

    //     // Return the shift value for the current column
    //     return shifts[dayCount - 1];

    // }
    // else if (boardingLog?.length > 0) {
    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate <= finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // }
    else if (boardingLog.length > 0) {

        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName);

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated            
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }
                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }
};

const getWeekOffDay = (column, boardingLog, department, overAllDepartment) => {
    if (boardingLog.length > 0) {

        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated            
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }
                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }
}

// get total days of current month
const getTotalMonthDays = (rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];
    const totalDaysInMonth = new Date(isyear, ismonth, 0).getDate();
    // const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);
    if (depdays) {
        return depdays.totaldays;
    }
    return totalDaysInMonth;
};

// get total week off count
const getTotalWeekOff = (rowempcode, usershift) => {
    let totalWeekOffDaysCount = 0;
    const totalWeekOffDays = usershift && usershift?.filter((d) => d.empCode === rowempcode && d.shiftlabel === "Week Off");
    if (totalWeekOffDays) {
        totalWeekOffDays.forEach((wkoff) => {
            totalWeekOffDaysCount++;
        });
    }
    return totalWeekOffDaysCount;
};

// get total holidays count based on the matched branch
const getTotalHolidays = (rowcompany, rowbranch, rowunit, rowteam, rowcompanyname, tempResultDates, holidays) => {
    let totalHolidayCount = 0;
    const totalHoliDays = holidays?.filter((d) =>
        d.company?.includes(rowcompany) &&
        d.applicablefor?.includes(rowbranch) &&
        d.unit?.includes(rowunit) &&
        d.team?.includes(rowteam) &&
        d.employee?.includes(rowcompanyname)
    );
    if (totalHoliDays) {
        tempResultDates && tempResultDates?.forEach((date) => {
            totalHoliDays.forEach((holi) => {
                if (formatDateLeaveDate(holi.date) === date.formattedDate) {
                    totalHolidayCount += Number(holi.noofdays);
                }
            });
        });
    }
    return totalHolidayCount;
};


//payrun master
exports.getAllUserAttMonthCountFilterPayRunMaster = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let finaluserattmonth = [];
    const { ismonth, isyear, } = req.body;

    try {
        const [users, depMonthSet, shift, holidays] = await Promise.all([
            User.find(
                {

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        const userIds = users.map(user => user._id);
        const [allLeaveStatus, allAttandanceList] = await Promise.all([
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Attendance.find({ userid: { $in: userIds } })
        ])
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluserattmonth = users?.map((item, index) => {
            let tempResultDates = [];

            item.shiftallot && item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            // Define an array to store the resulting dates
            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department && Number(d.year) === isyear && Number(d.month) === ismonth);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const dayshift = tempResultDates?.map((column, index) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode === item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && formatAdjDate(item.adjdate) === column.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDateForShiftDate(item.date) === column.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(column.dayName);
                const isWeekOff = getWeekOffDay(column, filterBoardingLog, item?._doc?.departmentlog, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                return {
                    userid: item?._doc?._id.toString(),
                    date: column?.formattedDate,
                    empCode: item?._doc?.empcode,
                    shiftlabel: getShiftForDateAttMonthStatus(column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual,
                        filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry.department, depMonthSet),
                }
            })

            const userData = {
                // _id: item?._doc?._id.toString(),
                // userid: item?._doc?._id.toString(),
                company: item?._doc?.company,
                branch: item?._doc?.branch,
                unit: item?._doc?.unit,
                team: item?._doc?.team,
                // doj: item?._doc?.doj,
                department: relevantDepLogEntry && relevantDepLogEntry.department,
                username: item?._doc?.companyname,
                empcode: item?._doc?.empcode,

                totalnumberofdays: getTotalMonthDays(item?._doc?.department, depMonthSet, ismonth, isyear),
                // empshiftdays: getTotalMonthDaysForEmp(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalcounttillcurrendate: getTotalMonthsCurrentDateCount(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                totalshift: getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList),
                clsl: getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus),
                weekoff: getTotalWeekOff(item?._doc?.empcode, dayshift),
                holiday: getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays),
                totalabsentleave: getTotalAbsentLeave(item?._doc?._id.toString(), item?._doc?.empcode, dayshift, getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays), allLeaveStatus, allAttandanceList, ismonth, isyear),
                totalpaiddays: getTotalPaidDays(getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList), getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalWeekOff(item?._doc?.empcode, dayshift), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays))
            }
            return userData;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!finaluserattmonth) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluserattmonth });
});

exports.getAllUsersPayrunexceldata = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {

                department: 1,

                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,

                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,

                experience: 1,
                doj: 1,
                dot: 1,
                // role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                process: 1,
                // weekoff: 1,
                area: 1,
                shiftallot: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                currmonthattlog: 1,
                currmonthavglog: 1,
                assignpfesilog: 1

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});

exports.deleteUserLogObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { ids, logname } = req.body;
        // Construct a filter to find the document with the specified ipconfig._id
        const updateOperations = {
            updateOne: {
                filter: {
                    [`${logname}._id`]: ids, // Assuming ids contains the ids you want to delete
                },
                update: {
                    $pull: {
                        [`${logname}`]: { _id: { $in: ids } } // Assuming ids contains the ids you want to delete
                    },
                },
            },
        };
        const { filter, update } = updateOperations.updateOne;
        const user = await User.findOne(filter);
        if (user) {
            await User.updateOne(filter, update);
        }
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
        return next(new ErrorHandler('Error updating stock!', 500));
    }
});

//payrun final salary
exports.getAllusersLimitedFinalsalary = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                designation: 1,
            }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});
exports.getAllUsersPayrunexceldataFinal = catchAsyncErrors(async (req, res, next) => {
    let users, filteredUsers, depMonthSet;
    try {
        const { branch, unit, team, department, month, year } = req.body

        const filter = {};
        if (branch && branch.length > 0) {
            filter.branch = { $in: branch };
        }
        if (unit && unit.length > 0) {
            filter.unit = { $in: unit };
        }
        if (team && team.length > 0) {
            filter.team = { $in: team };
        }
        if (req.body.employees && req.body.employees.length > 0) {
            filter.companyname = { $in: req.body.employees };
        }

        filter.enquirystatus = { $nin: ["Enquiry Purpose"], }

        filter.resonablestatus = {
            $nin: ["Releave Employee", "Absconded", "Hold", "Terminate"],
        },

            depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });

        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];


        filteredUsers = await User.find(filter, {
            department: 1,
            departmentlog: 1,
            processlog: 1,
            boardingLog: 1, attendancemode: 1,
            designationlog: 1,
            company: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            unit: 1,
            branch: 1,
            designation: 1,
            shift: 1,
            experience: 1,
            doj: 1,
            bankname: 1,
            bankdetails: 1,
            bankbranchname: 1,
            accountholdername: 1,
            accountnumber: 1,
            ifsccode: 1,
            shifttiming: 1,
            shiftgrouping: 1,
            legalname: 1,
            process: 1,
            pfesifromdate: 1,
            isenddate: 1,
            pfdeduction: 1,
            esideduction: 1,
            pfesienddate: 1,
            area: 1,
            shiftallot: 1,
            assignExpLog: 1,
            ipname: 1,
            pfmembername: 1,
            uan: 1,
            insurancenumber: 1,
            shiftallowancelog: 1,
            targetpointlog: 1,
            acheivedpointlog: 1,
            penaltylog: 1,
            totalabsentlog: 1,
            totalpaiddayslog: 1,
            currmonthattlog: 1,
            currmonthavglog: 1,
            assignpfesilog: 1,
            noshiftlog: 1,
            shiftallowtargetlog: 1,
            nightshiftallowlog: 1,
        });

        users = filteredUsers.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            if (department.includes(findUserDeprtment)) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    return res.status(200).json({ users });
});
exports.getAllUsersPayrunexceldata = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {

                department: 1,

                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,

                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,

                experience: 1,
                doj: 1,
                dot: 1,
                // role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                process: 1,
                // weekoff: 1,
                area: 1,
                shiftallot: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                currmonthattlog: 1,
                currmonthavglog: 1,
                assignpfesilog: 1

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});
exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterFinalSalary = catchAsyncErrors(async (req, res, next) => {
    let attendance;
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let permission;
    let weekOffDates = [];
    let finaluser = [];
    let result = [];
    // let getattendancestatus = [];
    const { ismonth, isyear } = req.body;

    try {
        const filter = {};

        if (req.body.company.length > 0) {
            filter.company = { $in: req.body.company };
        }

        if (req.body.branch && req.body.branch.length > 0) {
            filter.branch = { $in: req.body.branch };
        }

        if (req.body.unit && req.body.unit.length > 0) {
            filter.unit = { $in: req.body.unit };
        }

        if (req.body.department && req.body.department.length > 0) {
            filter.department = { $in: req.body.department };
        }

        if (req.body.team && req.body.team.length > 0) {
            filter.team = { $in: req.body.team };
        }

        if (req.body.designation && req.body.designation.length > 0) {
            filter.designation = { $in: req.body.designation };
        }

        if (req.body.employees && req.body.employees.length > 0) {
            filter.companyname = { $in: req.body.employees };
        }
        filter.enquirystatus = {
            $nin: ["Enquiry Purpose"],
        },
            filter.resonablestatus = {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            },

            // Use the 'filter' object in your MongoDB query


            let[users, depMonthSet, controlcriteria, shift, holidays, leavetype] = await Promise.all([
                User.find(
                    filter,
                    {
                        company: 1,
                        branch: 1,
                        unit: 1,
                        team: 1,
                        department: 1,
                        designation: 1,
                        doj: 1,
                        empcode: 1,
                        companyname: 1,
                        team: 1,
                        floor: 1,
                        username: 1,

                        weekoff: 1,
                        shiftallot: 1,
                        shifttiming: 1,
                        boardingLog: 1, attendancemode: 1,
                        department: 1,
                        processlog: 1,
                        designationlog: 1,
                        // shift: 1,

                        experience: 1,
                    }
                ),
                DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
                ControlCriteria.find(),
                Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
                Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
                Leavetype.find({}, { leavetype: 1, code: 1 })
            ])


        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 25);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 5);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);


        const originalDateObjecttodate = new Date(todate);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;

        attendance = await Attendance.find(
            {
                $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
            },
            { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1, attendancestatus: 1, attendancemanual: 1, autoclockout: 1 }
        );
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        // const monthNames = ["January", "February", "March", "April", "May", "June",
        //     "July", "August", "September", "October", "November", "December"
        // ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department));

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            } else {
                const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const findShiftTiming = (shiftName) => {
                const foundShift = shift?.find((d) => d.name === shiftName);
                return foundShift ? `${foundShift.fromhour}:${foundShift.frommin}${foundShift.fromtime}to${foundShift.tohour}:${foundShift.tomin}${foundShift.totime} ` : "";
            };

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const actualShiftTiming = findShiftTiming(item?._doc?.shifttiming);

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;
        });


    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterPayRunMasterFetch = catchAsyncErrors(async (req, res, next) => {
    let users;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let weekOffDates = [];
    let finaluser = [];
    let result = [];
    // let getattendancestatus = [];
    const { ismonth, isyear } = req.body;

    try {
        const filter = {};

        if (req.body.company.length > 0) {
            filter.company = { $in: req.body.company };
        }

        if (req.body.branch && req.body.branch.length > 0) {
            filter.branch = { $in: req.body.branch };
        }

        if (req.body.unit && req.body.unit.length > 0) {
            filter.unit = { $in: req.body.unit };
        }

        if (req.body.department && req.body.department.length > 0) {
            filter.department = { $in: req.body.department };
        }

        if (req.body.team && req.body.team.length > 0) {
            filter.team = { $in: req.body.team };
        }

        if (req.body.designation && req.body.designation.length > 0) {
            filter.designation = { $in: req.body.designation };
        }

        if (req.body.companyname && req.body.company.length > 0) {
            filter.employees = { $in: req.body.companyname };
        }
        (filter.enquirystatus = {
            $nin: ["Enquiry Purpose"],
        }),
            (filter.resonablestatus = {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            }),
            // Use the 'filter' object in your MongoDB query

            (users = await User.find(filter, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                designation: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,

                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
                department: 1,
                processlog: 1,
                designationlog: 1,
                // shift: 1,

                experience: 1,
                departmentlog: 1,
            }));

        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 20);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 10);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);

        const originalDateObjecttodate = new Date(todate);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;
        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);

        const [attendance, depMonthSet, controlcriteria, shift, allLeaveStatus, holidays, leavetype, permission, attModearr, attStatus] = await Promise.all([
            Attendance.find(
                {
                    $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
                },
                { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1 }
            ),
            DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 }),
            AttendanceModeStatus.find(),
            AttendanceStatusMaster.find()

        ])

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        // const monthNames = ["January", "February", "March", "April", "May", "June",
        //     "July", "August", "September", "October", "November", "December"
        // ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department));

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            } else {
                const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            // Map each user date to a row
            const userRows = userDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find((item) => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find((item) => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });


                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;

                if (isWeekOff) {
                    weekOffDates.push(date.formattedDate);
                }
                const updatedDatesBeforeWeekOffDates = [];
                const updatedDatesAfterWeekOffDates = [];

                weekOffDates.forEach((date) => {
                    const [day, month, year] = date?.split("/");
                    const currentDate = new Date(`${year}-${month}-${day}`);

                    // Get the day before
                    const dayBefore = new Date(currentDate);
                    dayBefore.setDate(currentDate.getDate() - 1);
                    const formattedDayBefore = `${dayBefore.getDate()}`.padStart(2, "0");
                    const formattedMonthBefore = `${dayBefore.getMonth() + 1}`.padStart(2, "0");
                    updatedDatesBeforeWeekOffDates.push(`${formattedDayBefore}/${formattedMonthBefore}/${dayBefore.getFullYear()}`);
                });

                weekOffDates.forEach((date) => {
                    const [day, month, year] = date?.split("/");
                    const currentDate = new Date(`${year}-${month}-${day}`);

                    // Get the day after
                    const dayAfter = new Date(currentDate);
                    dayAfter.setDate(currentDate.getDate() + 1);
                    const formattedDayAfter = `${dayAfter.getDate()}`.padStart(2, "0");
                    const formattedMonthAfter = `${dayAfter.getMonth() + 1}`.padStart(2, "0");
                    updatedDatesAfterWeekOffDates.push(`${formattedDayAfter}/${formattedMonthAfter}/${dayAfter.getFullYear()}`);
                });

                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate} `,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,

                    // updatedDatesBeforeWeekOffDates: updatedDatesBeforeWeekOffDates,
                    // updatedDatesAfterWeekOffDates: updatedDatesAfterWeekOffDates,
                    // weekOffDates: weekOffDates,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet)),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet)),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet)),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet)),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate),
                        allLeaveStatus,
                        holidays,
                        item?._doc.branch,
                        item?._doc?.empcode,
                        item?._doc.company,
                        date.formattedDate,
                        item?._doc.unit,
                        item?._doc.team,
                        item?._doc.companyname,
                        onclockout,
                        earlyclockout,
                        beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), userDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
// update intern status by id => /api/updateinternstatus/:id
exports.updateIntern = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;
    let uuser = await User.findByIdAndUpdate(id, req.body);

    if (!uuser) {
        return next(new ErrorHandler("Data not found!", 404));
    }
    return res.status(200).json({ message: "Updated successfully" });
});
// get All user => /api/users
exports.getAllUsersLogin = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                // resonablestatus: {
                //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                // },
            },
            {
                empcode: 1,
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});
exports.usersLimitedEmpcode = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                ...(req.body.id ? { _id: { $ne: req.body.id } } : {}),
            },
            {
                empcode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.usersLimitedEmpcodeCreate = catchAsyncErrors(async (req, res, next) => {
    let userscreate;

    try {
        userscreate = await User.find({ branch: req.body.branch }, { empcode: 1 }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!userscreate) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: userscreate.length, userscreate });
});
exports.usersLimitedEmpcodeNonmanual = catchAsyncErrors(
    async (req, res, next) => {
        let users;

        try {
            users = await User.find(
                {
                    wordcheck: false,
                },
                {
                    empcode: 1,
                }
            );
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }

        if (!users) {
            return next(new ErrorHandler("Users not found", 400));
        }

        return res.status(200).json({ count: users.length, users });
    }
);
exports.getAllUserstatus = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {},
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                addremoteworkmode: 1,

                unit: 1,
                branch: 1,
                department: 1,
                username: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                firstname: 1,
                lastname: 1,
                gender: 1,
                prefix: 1,

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: usersstatus.length, usersstatus });
});

exports.getAllUsersexceldata = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1, workstationshortname: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1, usernamepc: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                pfesistatus: 1,
                status: 1,
                resonablestatus: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1, workstation: 1, workstationshortname: 1, workstationinput: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ count: users.length, users });
});
// view password => api/verification/viewpassword
exports.viewpassword = catchAsyncErrors(async (req, res, next) => {
    const { id, otp } = req.body;


    // Finding if user exists in database
    const user = await User.findById(id);
    if (!user) {
        return next(new ErrorHandler(" Username Not Found", 401));
    }

    const overallsettings = await AdminOverAllSettings.find();
    let individualsettings = await IndividualSettings.find();
    let individualtwofaswitch = individualsettings?.find((item) =>
        item.companyname.includes(user?.companyname)
    );
    let adminTwofaswitch, loginswitch;
    if (overallsettings.length === 0) {
        adminTwofaswitch = true;
        loginswitch = true;
    } else {
        adminTwofaswitch =
            overallsettings[overallsettings.length - 1].overalltwofaswitch;
        loginswitch =
            overallsettings[overallsettings.length - 1].loginrestrictionswitch;
    }

    let check = individualtwofaswitch
        ? individualtwofaswitch?.twofaswitch
        : adminTwofaswitch;

    // && !user.role.includes("Manager")

    let foundData = user?.loginUserStatus?.find((data) => data?.status === "Active")

    if (foundData?.twofaenabled && check) {
        if (!otp) {
            return res.status(201).json({
                otpneeded: true,
            });
        }
        const verified = authenticator.check(otp, foundData?.twofasecret);

        if (!verified) {
            return next(new ErrorHandler("Invalid Otp", 401));
        }
        return res.status(200).json({
            success: true,
        });
    } else {
        return res.status(200).json({
            success: true,
        });
    }
});




// // get total holidays count based on the matched branch
const getTotalHolidaysMinFilter = (rowbranch, tempResultDates, holidays, empname, company, unit, team) => {
    let totalHolidayCount = 0;

    const totalHoliDays = holidays?.filter((d) =>
        d.applicablefor?.includes(rowbranch) && d.employee?.includes(empname)
        && d.company?.includes(company) && d.unit?.includes(unit) && d.team?.includes(team)
    );
    if (totalHoliDays) {
        tempResultDates && tempResultDates?.forEach((date) => {
            totalHoliDays.forEach((holi) => {
                if (formatDateLeaveDate(holi.date) === date.formattedDate) {
                    totalHolidayCount += Number(holi.noofdays);
                }
            });
        });
    }

    return totalHolidayCount;
};
// Add Shift Adjustment Details in user's shiftallot array after adjustment
exports.updateUsersShiftAllotObjects = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { shiftallotsarray } = req.body;

            // Construct an array of update operations for each item in changecheckedlabel
            const updateOperations = shiftallotsarray.map((changedShifts) => ({
                updateOne: {
                    filter: {
                        "shiftallot._id": changedShifts._id,
                    },
                    update: {
                        $set: {
                            "shiftallot.$.adjfirstshiftmode": changedShifts.adjfirstshiftmode,
                            "shiftallot.$.adjfirstshifttime": changedShifts.adjfirstshifttime,
                            "shiftallot.$.adjustmenttype": changedShifts.adjustmenttype,
                            "shiftallot.$.adjchangeshift": changedShifts.adjchangeshift,
                            "shiftallot.$.adjchangeshiftime": changedShifts.adjchangeshiftime,
                            "shiftallot.$.adjchangereason": changedShifts.adjchangereason,
                            "shiftallot.$.adjdate": changedShifts.adjdate,
                            "shiftallot.$.adjtypeshift": changedShifts.adjtypeshift,
                            "shiftallot.$.adjtypeshifttime": changedShifts.adjtypeshifttime,
                            "shiftallot.$.adjtypereason": changedShifts.adjtypereason,
                            "shiftallot.$.adjapplydate": changedShifts.adjapplydate,
                            "shiftallot.$.adjapplytime": changedShifts.adjapplytime,
                            "shiftallot.$.adjstatus": changedShifts.adjstatus,
                            "shiftallot.$.adjustmentstatus": changedShifts.adjustmentstatus,
                        },
                    },
                },
            }));

            // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
            for (const operation of updateOperations) {
                const { filter, update } = operation.updateOne;

                const shiftallot = await User.findOne(filter);

                if (shiftallot) {
                    const product = shiftallot.shiftallot.id(filter["shiftallot._id"]);
                    await User.updateOne(filter, update);
                }
            }

            return res
                .status(200)
                .json({ message: "User Shift updated successfully" });
        } catch (err) {
            return next(new ErrorHandler("Error updating shift!", 500));
        }
    }
);

// Adjust status update "Not Approved" -> "Approved" or "Reject"
exports.updateUsersShiftAllotObjectsStatus = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { shiftallotsarray } = req.body;
            // console.log(shiftallotsarray, "shiftallotsarray")
            // Construct an array of update operations for each item in changecheckedlabel
            const updateOperations = shiftallotsarray.map((changedShifts) => ({
                updateOne: {
                    filter: {
                        "shiftallot._id": changedShifts._id,
                    },
                    update: {
                        $set: {
                            "shiftallot.$.adjstatus": changedShifts.adjstatus,
                        },
                    },
                },
            }));

            // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
            for (const operation of updateOperations) {
                const { filter, update } = operation.updateOne;

                const shiftallot = await User.findOne(filter);

                if (shiftallot) {
                    const product = shiftallot.shiftallot.id(filter["shiftallot._id"]);
                    await User.updateOne(filter, update);
                }
            }

            return res
                .status(200)
                .json({ message: "User Shift Updated Successfully" });
        } catch (err) {
            return next(new ErrorHandler("Error updating shift!", 500));
        }
    }
);

//hrmanagers
exports.getHrManager = catchAsyncErrors(async (req, res, next) => {
    try {
        let query = {
            role: { $in: ["HiringManager", "HR"] },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            },
        };
        const hrmanagers = await User.find(query);
        if (!hrmanagers || hrmanagers.length === 0) {
            return next(new ErrorHandler("Hiring Managers not found", 404));
        }
        const hrman = hrmanagers.filter((d) => {
            return d.username;
        });
        return res.status(200).json({ hrman });
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});
// auth controller
// get Signle user => /api/auth/:id

exports.getSingleUserSignleRole = catchAsyncErrors(async (req, res, next) => {
    const suser = await User.findById(req.params.id, {
        role: 1,
        empcode: 1,
        companyname: 1,
        addedby: 1,
        updatedby: 1,
    });
    if (!suser) {
        return next(new ErrorHandler("User not found", 404));
    }
    return res.status(200).json({
        success: true,
        suser,
    });
});

// get All user => /api/users
exports.getAllUserscompanyname = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            { empcode: 1, username: 1, companyname: 1 }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAttenddancefilter = catchAsyncErrors(async (req, res, next) => {
    let attandance;
    let attandancefilter;
    let allUsers;
    try {
        allUsers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                username: 1,
                _id: 1,
                empcode: 1,
                profileimage: 1,
                companyname: 1,
                branch: 1,
                company: 1,
                unit: 1,
                team: 1,
                department: 1,
                resonablestatus: 1,
            }
        );

        let query = {};
        Object.keys(req.body).forEach((key) => {
            if (key !== "headers" && req.body[key].length > 0) {
                query[key] = req.body[key];
            }
        });

        // Filter the allUsers array based on the conditions provided in the query object
        attandance = allUsers.filter((item) => {
            return Object.keys(query).every((key) => {
                return query[key].includes(item[key]);
            });
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!attandance) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res
        .status(200)
        .json({ count: attandance.length, attandancefilter: attandance });
});

exports.getAllUserAttMonthCountFilterLimited = catchAsyncErrors(async (req, res, next) => {

    let allAttandanceList;
    let allLeaveStatus;
    let resultshiftallot = [];
    let finaluserattmonth = [];
    const { ismonth, isyear, } = req.body;

    try {
        const [users, depMonthSet, shift, holidays] = await Promise.all([
            User.find(
                {

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
        ])
        const userCds = users.map(user => user.companyname);
        const userIds = users.map(user => user._id);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        allAttandanceList = await Attendance.find({ userid: { $in: userIds } });
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluserattmonth = users?.map((item, index) => {
            let tempResultDates = [];

            item.shiftallot && item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            // Define an array to store the resulting dates
            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department && Number(d.year) === isyear && Number(d.month) === ismonth);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //     // If matched, push the range from 'fromdate' to 'todate'
                        //     const startDate = new Date(firstDate);
                        //     // Loop through the dates in the range
                        //     while (startDate <= currentDateAttStatus) {
                        //         tempResultDates.push({
                        //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                        //             dayName: format(startDate, 'EEEE'),
                        //             dayCount: startDate.getDate(),
                        //         });
                        //         startDate.setDate(startDate.getDate() + 1);
                        //     }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(firstDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //     // If matched, push the range from 'fromdate' to 'todate'
                        //     const startDate = new Date(joiningDate);
                        //     // Loop through the dates in the range
                        //     while (startDate <= currentDateAttStatus) {
                        //         tempResultDates.push({
                        //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                        //             dayName: format(startDate, 'EEEE'),
                        //             dayCount: startDate.getDate(),
                        //         });
                        //         startDate.setDate(startDate.getDate() + 1);
                        //     }
                        // }
                        // else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    }
                    // }
                });
            }
            else {
                const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //     let currentDate1 = new Date(startDate);

                    //     while (currentDate1 <= endDate) {
                    //         tempResultDates.push({
                    //             formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                    //             dayName: format(currentDate1, 'EEEE'),
                    //             dayCount: currentDate1.getDate(),
                    //         });
                    //         currentDate1.setDate(currentDate1.getDate() + 1);
                    //     }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        tempResultDates.push({
                            formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                            dayName: format(currentDate1, 'EEEE'),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                    // }
                } else {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //     // If matched, push the range from 'fromdate' to 'todate'
                    //     const startDate = new Date(joiningDate);
                    //     // Loop through the dates in the range
                    //     while (startDate <= currentDateAttStatus) {
                    //         tempResultDates.push({
                    //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                    //             dayName: format(startDate, 'EEEE'),
                    //             dayCount: startDate.getDate(),
                    //         });
                    //         startDate.setDate(startDate.getDate() + 1);
                    //     }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        tempResultDates.push({
                            formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                            dayName: format(currentDate1, 'EEEE'),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                }
                // }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const dayshift = tempResultDates?.map((column, index) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode === item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && formatAdjDate(item.adjdate) === column.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDateForShiftDate(item.date) === column.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(column.dayName);
                const isWeekOff = getWeekOffDay(column, filterBoardingLog, item?._doc?.departmentlog, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                return {
                    userid: item?._doc?._id.toString(),
                    date: column?.formattedDate,
                    empCode: item?._doc?.empcode,
                    shiftlabel: getShiftForDateAttMonthStatus(column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual,
                        filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry.department, depMonthSet),
                }
            })

            const userData = {
                // _id: item?._doc?._id.toString(),
                // userid: item?._doc?._id.toString(),
                company: item?._doc?.company,
                branch: item?._doc?.branch,
                unit: item?._doc?.unit,
                team: item?._doc?.team,
                doj: item?._doc?.doj,
                department: relevantDepLogEntry && relevantDepLogEntry.department,
                username: item?._doc?.companyname,
                empcode: item?._doc?.empcode,
                // weekoff: item?._doc?.weekoff,
                // boardingLog: item?._doc?.boardingLog,
                // shiftallot: item?._doc?.shiftallot,
                totalnumberofdays: getTotalMonthDays(item?._doc?.department, depMonthSet, ismonth, isyear),
                // empshiftdays: getTotalMonthDaysForEmp(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalcounttillcurrendate: getTotalMonthsCurrentDateCount(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalshift: getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList),
                // clsl: getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus),
                weekoff: getTotalWeekOff(item?._doc?.empcode, dayshift),
                holiday: getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays),
                // totalabsentleave: getTotalAbsentLeave(item?._doc?._id.toString(), item?._doc?.empcode, dayshift, getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays), allLeaveStatus, allAttandanceList, ismonth, isyear),
                // totalpaiddays: getTotalPaidDays(getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList), getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalWeekOff(item?._doc?.empcode, dayshift), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays))
            }
            return userData;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluserattmonth) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluserattmonth });
});


// get All user => /api/users  assingedby profile pic
exports.getAllUserstaskProfile = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.findById(req.body.userprofile);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});

exports.getAllUserslimit = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                department: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                doj: 1,
                dot: 1,
                floor: 1, area: 1, workstation: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllAddEmployeeLimit = catchAsyncErrors(async (req, res, next) => {
    const { page = 1, limit = 1, sizename, sort, search } = req.query;

    const filters = {
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    };
    if (sizename) {
        filters.sizename = sizename;
    }

    const query = User.find(filters);

    if (search) {
        query.where({ name: { $regex: search, $options: "i" } });
    }

    if (sort) {
        const [field, order] = sort?.split(":");
        query.sort({ [field]: order === "desc" ? -1 : 1 });
    }
    try {
        const items = await query.skip((page - 1) * limit).limit(+limit);
        const totalCount = await User.countDocuments(filters);

        if (!items) {
            return next(new ErrorHandler("Data not found!", 404));
        }

        return res.status(200).json({
            items,
            totalPages: Math.ceil(totalCount / limit),
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

// / register auser => api/auth/new
exports.regAuth = catchAsyncErrors(async (req, res, next) => {
    const {
        prefix,
        firstname,
        lastname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        username,
        usernameautogenerate,
        workmode,
        password,
        autogeneratepassword,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        addremoteworkmode,
        companyemail,
        resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        referencetodo,
        contactno,
        details,
        companyname,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        unit,
        samesprmnt,
        addedby,
        updatedby,
        floor,
        company,
        experience,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        empcode,
        remark,
        dom,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        addAddQuaTodo,
        workhistTodo,
        //draft,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        assignExpLog,
        departmentlog,
        designationlog,
        boardingLog,
        processlog,
        salarycode,
        salarysetup,
        basic,
        hra,
        conveyance,
        medicalallowance,
        productionallowance,
        otherallowance,
        productionallowancetwo,
        ctc, mode, rejoin,
        shifttype,
        reasonablestatusremarks,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode,
    } = req.body;
    if (!username || !password) {
        return next(new ErrorHandler("Please fill all fields", 400));
    }
    // encrypt password before saving
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    const user = await User.create({
        prefix,
        username,
        usernameautogenerate,
        workmode,
        lastname,
        email,
        employeecount,
        systemmode,
        companyemail,
        addremoteworkmode,
        resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        firstname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        dom,
        //draft,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail, resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        rejoin,
        reasonablestatusremarks,
        dot,
        referencetodo,
        contactno,
        details,
        companyname,
        addremoteworkmode,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        unit,
        floor,
        samesprmnt,
        experience,
        addedby,
        updatedby,
        department,
        team,
        //draft,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        company,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        password: hashPassword,
        autogeneratepassword,
        assignExpLog,
        departmentlog,
        designationlog,
        boardingLog,
        processlog,
        employeecount,
        salarycode,
        salarysetup,
        basic,
        hra,
        conveyance,
        medicalallowance,
        productionallowance,
        otherallowance,
        productionallowancetwo,
        ctc, mode, assignExpMode,
        assignExpvalue,
        assignExpDate,
        shifttype,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode,
    });

    const token = await new Token({
        userId: user._id,
        token: crypto.randomBytes(32).toString("hex"),
    }).save();

    const url = `http://anubhuthi.org/${user._id}/verify/${token.token}`;
    await sendVerificationEmail(user.email, "Verify Email", url);

    return res.status(201).json({
        success: true,
        user,
    });
});



// Login user => api/users
exports.loginAuth = catchAsyncErrors(async (req, res, next) => {
    const { username, password, otp, publicIP } = req.body;
    const resonablestatusarray = [
        "Absconded",
        "Hold",
        "Terminate",
        "Releave Employee",
        "Not Joined",
        "Postponed",
        "Rejected",
        "Closed",
    ];
    // Check if email & password entered by user
    if (!username || !password) {
        return next(new ErrorHandler("Please enter username and password", 400));
    }

    // Finding if user exists in database
    const user = await User.findOne({ username }).select("+password");
    if (!user) {
        return next(new ErrorHandler("Invalid Username or Password", 401));
    }

    // If checks password is correct or not
    const isPwdMatched = await bcrypt.compare(password, user.password);

    if (!isPwdMatched) {
        return next(new ErrorHandler("Invalid Password", 401));
    }
    if (resonablestatusarray.includes(user?.resonablestatus)) {
        return next(new ErrorHandler("Login Restricted", 401));
    }

    // if(!user.emailverification && !user.role.includes("Manager")){
    //   let token = await Token.findOne({userId:user._id});
    //   if(!token){
    //     token = await new Token({
    //       userId: user._id,
    //       token:crypto.randomBytes(32).toString("hex")
    //     }).save();

    //     const url = `http://anubhuthi.org/${user._id}/verify/${token.token}`;
    //     await sendVerificationEmail(user.email,"Verify Email",url)
    //   }
    //   return next(new ErrorHandler('An email has been sent to your account for verification. Please verify your email.', 400));
    // }

    const overallsettings = await AdminOverAllSettings.find();
    const clockinip = await ClockinIP.find({ branch: user?.branch });
    let individualsettings = await IndividualSettings.find();
    let individualtwofaswitch = individualsettings?.find((item) =>
        item.companyname.includes(user?.companyname)
    );
    let adminTwofaswitch, loginswitch;
    if (overallsettings.length === 0) {
        adminTwofaswitch = true;
        loginswitch = true;
    } else {
        adminTwofaswitch =
            overallsettings[overallsettings.length - 1].overalltwofaswitch;
        loginswitch =
            overallsettings[overallsettings.length - 1].loginrestrictionswitch;
    }

    let check = individualtwofaswitch
        ? individualtwofaswitch?.twofaswitch
        : adminTwofaswitch;
    let checkLogin = individualtwofaswitch
        ? individualtwofaswitch?.loginipswitch
        : loginswitch;
    var logincheck;
    if (clockinip?.length === 0) {
        logincheck = "NOTSHOW";
    } else {
        logincheck = "SHOW";
    }
    const isIpInData = clockinip?.some((entry) =>
        entry.ipaddress.includes(publicIP)
    );
    if (
        checkLogin &&
        !user.role.includes("Manager") &&
        logincheck === "SHOW" &&
        !isIpInData
    ) {
        //return next(new ErrorHandler("Login Restricted", 401));
    }

    if (!user.twofaenabled && check && !user.role.includes("Manager")) {
        const secret = authenticator.generateSecret();
        const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
        const image = await qrcode.toDataURL(uri);
        user["twofatempsecret"] = secret;
        const result = await user.save();
        return res.status(201).json({
            generateqr: true,
            image,
            result,
        });
    } else if (user.twofaenabled && check && !user.role.includes("Manager")) {
        if (!otp) {
            return res.status(201).json({
                otpneeded: true,
            });
        }
        const verified = authenticator.check(otp, user.twofasecret);

        if (!verified) {
            return next(new ErrorHandler("Invalid Otp", 401));
        }
        sendToken(user, 200, res);
    } else {
        sendToken(user, 200, res);
    }
});

const WorkStationShortNameGeneration = async () => {
    try {
        let res_employee = await workStation.find().lean();
        let res_company = await Company.find().lean();
        let res_branch = await Branch.find().lean();
        let res_unit = await Unit.find().lean();
        const result = res_employee?.flatMap((item) => {
            return item.combinstation.flatMap((combinstationItem) => {
                return combinstationItem.subTodos.length > 0
                    ? combinstationItem.subTodos.map((subTodo) => {
                        return {
                            company: item.company, branch: item.branch, unit: item.unit, floor: item.floor, id: item._id,
                            cabinname: subTodo.subcabinname
                        }
                    })
                    : [{
                        company: item.company, branch: item.branch, unit: item.unit, floor: item.floor, id: item._id,
                        cabinname: combinstationItem.cabinname
                    }
                    ];
            });
        });
        const rescompanydata = result.map((data, index) => {
            let updatedData = data;
            res_company?.map((item, i) => {
                if (data.company === item.name) {
                    updatedData = { ...data, companycode: item.code };
                }
            });

            return updatedData;
        });

        const resBranchdata = rescompanydata.map((data, index) => {
            let updatedData = data;
            res_branch?.map((item, i) => {
                if (data.branch === item.name) {
                    updatedData = { ...data, branchcode: item.code };
                }
            });

            return updatedData;
        });

        const resUnitdata = resBranchdata.map((data, index) => {
            let updatedData = data;
            res_unit?.map((item, i) => {
                if (data.unit === item.name) {
                    updatedData = { ...data, unitcode: item.code };
                }
            });

            return updatedData;
        });
        // Calculate counts dynamically
        const counts = {};

        const updatedData = resUnitdata.map(obj => {

            const key = `${obj.company}-${obj.branch}-${obj.unit}-${obj.floor}`;
            obj.count = (counts[key] || 0) + 1;
            counts[key] = obj.count;

            obj.systemname = `${obj?.companycode}_${obj?.branchcode}#${obj.count}#${obj?.unitcode}_${obj.cabinname}`;

            obj.systemshortname = `${obj?.branchcode}_${obj.count}_${obj?.unitcode}_${obj.cabinname}`;

            return obj;
        });



        return updatedData
    }
    catch (err) {

    }


}

// exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {
//     let resversion = false;
//     try {
//         const {
//             username,
//             password,
//             otp,
//             publicIP,
//             macAddress,
//             systemname,
//             currenturl,
//             localIp,
//             hostname,
//             version,
//             applogin,
//         } = req.body;
//         let MatchedNotMatched;
//         let controlcriteria;
//         resversion = version === "1.8.0" ? true : false
//         // let hostname = "TT_1_U4_G-HRA";
//         const resonablestatusarray = [
//             "Absconded",
//             "Hold",
//             "Terminate",
//             "Releave Employee",
//             "Not Joined",
//             "Postponed",
//             "Rejected",
//             "Closed",
//         ];
//         //version mismatch
//         if (!username || !password) {
//             return next(new ErrorHandler("Please enter username and password", 400));
//         }
//         // Check if email & password entered by user
//         if (applogin === true && version !== "1.4.0" && version !== "1.5.0" && version !== "1.6.0" && version !== "1.7.0" && version !== "1.8.0") {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }

//         if (applogin === undefined || version === undefined) {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }
//         // Finding if user exists in database
//         const user = await User.findOne({
//             resonablestatus: {
//                 $nin: [
//                     "Not Joined",
//                     "Postponed",
//                     "Rejected",
//                     "Closed",
//                     "Releave Employee",
//                     "Absconded",
//                     "Hold",
//                     "Terminate",
//                 ],
//             },
//             username,
//         }).select("+password");
//         if (!user) {
//             return next(
//                 new ErrorHandler(
//                     "Login Restricted! Please Enter Valid Username&Password",
//                     401
//                 )
//             );
//         }
//         // If checks password is correct or not
//         const isPwdMatched = await bcrypt.compare(password, user.password);

//         if (!isPwdMatched) {
//             return next(new ErrorHandler("Invalid Password", 401));
//         }
//         if (resonablestatusarray.includes(user?.resonablestatus)) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }

//         const overallsettings = await AdminOverAllSettings.find();
//         const clockinip = await ClockinIP.find({ branch: user?.branch });
//         let individualsettings = await IndividualSettings.find({
//             company: user?.company,
//             branch: user?.branch,
//             unit: user?.unit,
//             team: user?.team,
//             companyname: { $in: user?.companyname },
//         });
//         let individualtwofaswitch = individualsettings?.find((item) =>
//             item.companyname.includes(user?.companyname)
//         );


//         let autoLogoutTime = await AutoLogout.aggregate([
//             {
//                 $facet: {
//                     matchedData: [
//                         {
//                             $unwind: "$todos"
//                         },
//                         {
//                             $match: {
//                                 "todos.employeename":
//                                     user.companyname
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins:
//                                     "$todos.autologoutmins"
//                             }
//                         }
//                     ],
//                     notMatched: [
//                         {
//                             $match: {
//                                 autologoutswitch: true
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins: "$autologoutmins"
//                             }
//                         }
//                     ]
//                 }
//             },
//             {
//                 $project: {
//                     result: {
//                         $cond: {
//                             if: {
//                                 $gt: [{ $size: "$matchedData" }, 0]
//                             },
//                             then: "$matchedData",
//                             else: "$notMatched"
//                         }
//                     }
//                 }
//             }
//         ])


//         let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

//         const dateCheck = new Date();
//         dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
//         let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"
//         let externalurl =
//             overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];
//         let internalurl =
//             overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];

//         let finalLoginMode = individualtwofaswitch
//             ? individualtwofaswitch?.loginmode
//             : overallsettings[overallsettings.length - 1]?.loginmode;

//         if (
//             currenturl !== undefined &&
//             finalLoginMode === "Internal Login" &&
//             !internalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login, Contact Administrator`, 401)
//             );
//         } else if (
//             currenturl !== undefined &&
//             finalLoginMode === "External Login" &&
//             !externalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login ,Contact Administrator`, 401)
//             );
//         }

//         //   if (!user.role.includes("Manager")) {
//         const today = moment();
//         const pastThreeAttendaysDays = [
//             today.clone().format("DD-MM-YYYY"),
//             today.clone().subtract(1, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(2, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(3, "days").format("DD-MM-YYYY"),
//         ];
//         const pastThreeLeaveDays = [
//             today.clone().format("DD/MM/YYYY"),

//             today.clone().subtract(1, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(2, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(3, "days").format("DD/MM/YYYY"),
//         ];
//         const pastThreeDaysISO = [
//             today.clone().format("YYYY-MM-DD"),
//             today.clone().subtract(1, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(2, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(3, "days").format("YYYY-MM-DD"),
//         ];

//         // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
//         const [attendance, allLeaveStatus, holidays] = await Promise.all([
//             // Fetch relevant attendance records for the past 3 days for the specific user
//             Attendance.find(
//                 {
//                     date: {
//                         $in: pastThreeAttendaysDays,
//                     },
//                     userid: user._id,
//                 },
//                 { date: 1, userid: 1 }
//             ).lean(),

//             // Fetch relevant leave records for the specific user
//             ApplyLeave.find(
//                 {
//                     date: { $in: pastThreeLeaveDays },
//                     employeeid: user.empcode,
//                     employeename: user.companyname,
//                 },
//                 { employeename: 1, employeeid: 1, date: 1 }
//             ).lean(),

//             // Fetch relevant holidays for the specific user
//             Holiday.find(
//                 {
//                     date: { $in: pastThreeDaysISO },
//                     company: { $in: [user.company] }, // Checks if user's company is in the company array
//                     applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
//                     unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
//                     team: { $in: [user.team] }, // Checks if user's team is in the team array
//                     employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
//                 },
//                 { date: 1, employee: 1 }
//             ).lean(),
//         ]);

//         // Continue with your logic

//         // Create maps for attendance, leave, and holidays for quick lookup

//         const attendanceMap = attendance.reduce((acc, item) => {
//             const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});
//         const leaveMap = allLeaveStatus.reduce((acc, item) => {
//             item.date.forEach((date) => {
//                 acc[date] = true;
//             });
//             return acc;
//         }, {});

//         const holidayMap = holidays.reduce((acc, item) => {
//             const date = moment(item.date).format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});

//         // Function to check the status for the past 3 days
//         const checkStatusForPast3Days = (weekOffDays) => {
//             let absentDays = 0;
//             let leaveDays = 0;
//             let holidayDays = 0;

//             for (let date of pastThreeLeaveDays) {
//                 // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

//                 // if (weekOffDays.includes(dayOfWeek)) {
//                 //   continue; // Skip week off days
//                 // }
//                 if (attendanceMap[date]) {
//                     // User was present on this date
//                     continue;
//                 } else if (leaveMap[date]) {
//                     // User was on leave on this date
//                     leaveDays++;
//                 } else if (holidayMap[date]) {
//                     // User had a holiday on this date

//                     holidayDays++;
//                 } else {
//                     // User was absent on this date
//                     absentDays++;
//                 }
//             }

//             if (absentDays >= 4) {
//                 return "Long Absent";
//             } else if (leaveDays >= 4) {
//                 return "Long Leave";
//             } else if (holidayDays >= 4) {
//                 return null;
//             } else {
//                 return null;
//             }
//         };

//         // Function to determine the final status
//         const determineStatus = (attendanceStatus, livestatus) => {
//             if (attendanceStatus) {
//                 return attendanceStatus;
//             } else if (livestatus) {
//                 return livestatus;
//             } else {
//                 return "No Status";
//             }
//         };
//         let weekOffDays = [];
//         if (user.boardingLog && user.boardingLog.length > 0) {
//             const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
//             weekOffDays = lastBoardingLog.weekoff || [];
//         }
//         // Determine the user's status
//         const attendanceStatus = checkStatusForPast3Days(weekOffDays);
//         const livestatus = !attendanceStatus ? "Live" : null;

//         const userStatus = determineStatus(attendanceStatus, livestatus);

//         const todaydate = moment().format("DD-MM-YYYY");
//         const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
//         const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
//         const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

//         let checkArray = user?.longleaveabsentaprooveddate?.every(
//             (date) => !dateArray.includes(date)
//         );
//         if (
//             !pastThreeDaysISO?.includes(user?.doj) &&
//             userStatus === "Long Absent" &&
//             Array.isArray(user?.longleaveabsentaprooveddate) &&
//             checkArray &&
//             !user.role.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(
//                     `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
//                     401
//                 )
//             );
//         }

//         controlcriteria = await ControlCriteria.find();

//         let adminTwofaswitch, loginswitch;
//         if (overallsettings.length === 0) {
//             adminTwofaswitch = true;
//             loginswitch = true;
//         } else {
//             adminTwofaswitch =
//                 overallsettings[overallsettings.length - 1].overalltwofaswitch;
//             loginswitch =
//                 overallsettings[overallsettings.length - 1].loginrestrictionswitch;
//         }

//         let loginapprestriction = user?.extramode
//             ? user?.extramode
//             : individualtwofaswitch
//                 ? individualtwofaswitch?.loginapprestriction
//                 : overallsettings[overallsettings.length - 1]?.loginapprestriction;

//         let check = individualtwofaswitch
//             ? individualtwofaswitch?.twofaswitch
//             : adminTwofaswitch;
//         let checkLogin = individualtwofaswitch
//             ? individualtwofaswitch?.loginipswitch
//             : loginswitch;

//         const WorkStationShortName = await WorkStationShortNameGeneration();
//         const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
//         const workstationNames = user?.workstation;

//         let matchedWorkStation = "";
//         let matchedUserWorkStation = "";

//         if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Primary WorkStation";

//         } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Secondary WorkStation";

//         } else if (user?.workstationinput?.slice(0, 15) === hostname) {
//             matchedUserWorkStation = user?.workstationinput
//             matchedWorkStation = "Work From Home";
//         }

//         MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
//         const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
//         const countWorStation = matchedWorkStation === "Primary WorkStation" ?
//             1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

//         user["sigindate"] = moment().format("DD-MM-YYYY");
//         const result = await user.save();

//         var logincheck;
//         if (clockinip?.length === 0) {
//             logincheck = "NOTSHOW";
//         } else {
//             logincheck = "SHOW";
//         }
//         const isIpInData = clockinip?.some((entry) =>
//             entry.ipaddress.includes(publicIP)
//         );
//         if (
//             checkLogin &&
//             !user.role.includes("Manager") &&
//             logincheck === "SHOW" &&
//             !isIpInData
//         ) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }
//         const userMacTwoFatrue = user?.loginUserStatus?.some(
//             (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//         );

//         if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {
//             const secret = authenticator.generateSecret();
//             const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
//             const image = await qrcode.toDataURL(uri);

//             if (
//                 user?.loginUserStatus?.length == 0 ||
//                 user?.loginUserStatus === undefined
//             ) {
//                 user["loginUserStatus"] = {
//                     macaddress: macAddress,
//                     username: systemname,
//                     localip: localIp,
//                     status: "Active",
//                     twofatempsecret: secret,
//                     hostname: hostname,
//                     twofaenabled: false,
//                     version: version,
//                     workstation: matchedUserWorkStation,
//                     matchedstatus: MatchedNotMatched,
//                     matched: matchedWorkStation,
//                     count: countWorStation

//                 };
//                 const result = await user.save();
//                 return res.status(201).json({
//                     generateqr: true,
//                     image,
//                     result,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation
//                 });
//             } else if (user?.loginUserStatus?.length > 0) {
//                 const gesyscont = user?.loginUserStatus.filter((data) => {
//                     return data.macaddress != "none";
//                 });

//                 if (macAddress != "none") {
//                     if (
//                         ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                         !user?.loginUserStatus?.some(
//                             (data) => (data.macaddress === macAddress || data.hostname === hostname)
//                         )
//                     ) {
//                         return next(
//                             new ErrorHandler(
//                                 "Reached Your System Count.Please Contact Administrator",
//                                 401
//                             )
//                         );
//                     } else {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,

//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation
//                             },
//                         ];
//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation
//                         });
//                     }
//                 } else {
//                     if (macAddress != "none") {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,
//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation
//                             },
//                         ];

//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation
//                         });
//                     } else {
//                         const result = user;
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,

//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation
//                         });
//                     }
//                 }
//             }
//         } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
//             if (!otp) {
//                 const remaining = user?.loginUserStatus
//                     ?.filter((data) => data.macaddress !== macAddress)
//                     ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                 return res.status(201).json({
//                     otpneeded: true,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation
//                 });
//             }

//             const userMacTwoFaSecret = user?.loginUserStatus?.find(
//                 (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//             );

//             const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

//             if (!verified) {
//                 return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
//             }
//             checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                 checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                 matchedWorkStation);
//         } else {
//             const gesyscont = user?.loginUserStatus.filter((data) => {
//                 return data.macaddress != "none";
//             });
//             if (
//                 user?.loginUserStatus?.find((data) =>
//                     (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 const result = await user.save();
//                 checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                     checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                     matchedWorkStation);
//             } else if (

//                 ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                 macAddress !== "none" && hostname !== "none" &&
//                 !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 return next(
//                     new ErrorHandler(
//                         "Reached Your System Count.Please Contact Administrator",
//                         401
//                     )
//                 );
//             } else {
//                 if (macAddress !== "none") {
//                     const remaining = user?.loginUserStatus?.map((dar) => ({
//                         ...dar,
//                         status: "Inactive",
//                     }));

//                     user["loginUserStatus"] = [
//                         ...remaining,
//                         {
//                             macaddress: macAddress,
//                             username: systemname,
//                             hostname: hostname,
//                             localip: localIp,
//                             status: "Active",
//                             version: version,
//                             workstation: matchedUserWorkStation,
//                             matchedstatus: MatchedNotMatched,
//                             matched: matchedWorkStation,
//                             count: countWorStation
//                         },
//                     ];
//                     // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
//                     // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

//                     const result = await user.save();
//                     checksendToken(
//                         result,
//                         200,
//                         res,
//                         loginapprestriction,
//                         checkAutoLogoutTime,
//                         checkAutoLogoutDate,
//                         controlcriteria,
//                         MatchedNotMatched, resversion,
//                         matchedWorkStation
//                     );
//                 } else {
//                     checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
//                         checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                         matchedWorkStation);
//                 }
//             }
//         }
//     } catch (err) {
//         return next(new ErrorHandler("User not found", 404));
//     }
// });


exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {
    let resversion = false;
    let appUpdateCalculation = 7
    try {
        const {
            username,
            password,
            otp,
            publicIP,
            macAddress,
            systemname,
            currenturl,
            localIp,
            hostname,
            version,
            applogin,
        } = req.body;
        let MatchedNotMatched;
        let controlcriteria;
        resversion = version === "1.9.0" ? true : false



        // let hostname = "TT_1_U4_G-HRA";
        const resonablestatusarray = [
            "Absconded",
            "Hold",
            "Terminate",
            "Releave Employee",
            "Not Joined",
            "Postponed",
            "Rejected",
            "Closed",
        ];
        //version mismatch
        if (!username || !password) {
            return next(new ErrorHandler("Please enter username and password", 400));
        }
        // Check if email & password entered by user
        if (applogin === true && version !== "1.4.0" && version !== "1.5.0" && version !== "1.6.0" && version !== "1.7.0" && version !== "1.8.0" && version !== "1.9.0") {
            return next(new ErrorHandler("Please Update current version!..", 400));
        }

        if (applogin === undefined || version === undefined) {
            return next(new ErrorHandler("Please Update current version!..", 400));
        }
        // Finding if user exists in database
        const user = await User.findOne({
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            username,
        }).select("+password");
        if (!user) {
            return next(
                new ErrorHandler(
                    "Login Restricted! Please Enter Valid Username&Password",
                    401
                )
            );
        }


        const userUniqueAddresss = user?.loginUserStatus?.find(data => data?.username === systemname && macAddress === data?.macaddress)
        appUpdateCalculation = userUniqueAddresss ? 7 - (Math.floor((new Date().getTime() - new Date(userUniqueAddresss?.createdAt).getTime()) / (1000 * 60 * 60 * 24))) : 7;


        // If checks password is correct or not
        const isPwdMatched = await bcrypt.compare(password, user.password);

        if (!isPwdMatched) {
            return next(new ErrorHandler("Invalid Password", 401));
        }
        if (resonablestatusarray.includes(user?.resonablestatus)) {
            return next(new ErrorHandler("Login Restricted", 401));
        }

        const overallsettings = await AdminOverAllSettings.find();
        const clockinip = await ClockinIP.find({ branch: user?.branch });
        let individualsettings = await IndividualSettings.find({
            company: user?.company,
            branch: user?.branch,
            unit: user?.unit,
            team: user?.team,
            companyname: { $in: user?.companyname },
        });
        let individualtwofaswitch = individualsettings?.find((item) =>
            item.companyname.includes(user?.companyname)
        );


        let autoLogoutTime = await AutoLogout.aggregate([
            {
                $facet: {
                    matchedData: [
                        {
                            $unwind: "$todos"
                        },
                        {
                            $match: {
                                "todos.employeename":
                                    user.companyname
                            }
                        },
                        {
                            $project: {
                                autologoutmins:
                                    "$todos.autologoutmins"
                            }
                        }
                    ],
                    notMatched: [
                        {
                            $match: {
                                autologoutswitch: true
                            }
                        },
                        {
                            $project: {
                                autologoutmins: "$autologoutmins"
                            }
                        }
                    ]
                }
            },
            {
                $project: {
                    result: {
                        $cond: {
                            if: {
                                $gt: [{ $size: "$matchedData" }, 0]
                            },
                            then: "$matchedData",
                            else: "$notMatched"
                        }
                    }
                }
            }
        ])


        let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

        const dateCheck = new Date();
        dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
        let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"
        let externalurl =
            overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
                    (item) => new URL(item).hostname
                )
                : [];
        let internalurl =
            overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
                    (item) => new URL(item).hostname
                )
                : [];

        let finalLoginMode = individualtwofaswitch
            ? individualtwofaswitch?.loginmode
            : overallsettings[overallsettings.length - 1]?.loginmode;

        if (
            currenturl !== undefined &&
            finalLoginMode === "Internal Login" &&
            !internalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {

            return next(
                new ErrorHandler(`UnAuthorized Login, Contact Administrator`, 401)
            );
        } else if (
            currenturl !== undefined &&
            finalLoginMode === "External Login" &&
            !externalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {
            return next(
                new ErrorHandler(`UnAuthorized Login ,Contact Administrator`, 401)
            );
        }

        //   if (!user.role.includes("Manager")) {
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),

            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];

        // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
        const [attendance, allLeaveStatus, holidays] = await Promise.all([
            // Fetch relevant attendance records for the past 3 days for the specific user
            Attendance.find(
                {
                    date: {
                        $in: pastThreeAttendaysDays,
                    },
                    userid: user._id,
                },
                { date: 1, userid: 1 }
            ).lean(),

            // Fetch relevant leave records for the specific user
            ApplyLeave.find(
                {
                    date: { $in: pastThreeLeaveDays },
                    employeeid: user.empcode,
                    employeename: user.companyname,
                },
                { employeename: 1, employeeid: 1, date: 1 }
            ).lean(),

            // Fetch relevant holidays for the specific user
            Holiday.find(
                {
                    date: { $in: pastThreeDaysISO },
                    company: { $in: [user.company] }, // Checks if user's company is in the company array
                    applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
                    unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
                    team: { $in: [user.team] }, // Checks if user's team is in the team array
                    employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
                },
                { date: 1, employee: 1 }
            ).lean(),
        ]);

        // Continue with your logic

        // Create maps for attendance, leave, and holidays for quick lookup

        const attendanceMap = attendance.reduce((acc, item) => {
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});
        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            item.date.forEach((date) => {
                acc[date] = true;
            });
            return acc;
        }, {});

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (weekOffDays) => {
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[date]) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[date]) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[date]) {
                    // User had a holiday on this date

                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            if (absentDays >= 4) {
                return "Long Absent";
            } else if (leaveDays >= 4) {
                return "Long Leave";
            } else if (holidayDays >= 4) {
                return null;
            } else {
                return null;
            }
        };

        // Function to determine the final status
        const determineStatus = (attendanceStatus, livestatus) => {
            if (attendanceStatus) {
                return attendanceStatus;
            } else if (livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };
        let weekOffDays = [];
        if (user.boardingLog && user.boardingLog.length > 0) {
            const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
            weekOffDays = lastBoardingLog.weekoff || [];
        }
        // Determine the user's status
        const attendanceStatus = checkStatusForPast3Days(weekOffDays);
        const livestatus = !attendanceStatus ? "Live" : null;

        const userStatus = determineStatus(attendanceStatus, livestatus);

        const todaydate = moment().format("DD-MM-YYYY");
        const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
        const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
        const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

        let checkArray = user?.longleaveabsentaprooveddate?.every(
            (date) => !dateArray.includes(date)
        );
        if (
            !pastThreeDaysISO?.includes(user?.doj) &&
            userStatus === "Long Absent" &&
            Array.isArray(user?.longleaveabsentaprooveddate) &&
            checkArray &&
            !user.role.includes("Manager")
        ) {
            return next(
                new ErrorHandler(
                    `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
                    401
                )
            );
        }

        controlcriteria = await ControlCriteria.find();

        let adminTwofaswitch, loginswitch;
        if (overallsettings.length === 0) {
            adminTwofaswitch = true;
            loginswitch = true;
        } else {
            adminTwofaswitch =
                overallsettings[overallsettings.length - 1].overalltwofaswitch;
            loginswitch =
                overallsettings[overallsettings.length - 1].loginrestrictionswitch;
        }

        let loginapprestriction = user?.extramode
            ? user?.extramode
            : individualtwofaswitch
                ? individualtwofaswitch?.loginapprestriction
                : overallsettings[overallsettings.length - 1]?.loginapprestriction;

        let check = individualtwofaswitch
            ? individualtwofaswitch?.twofaswitch
            : adminTwofaswitch;
        let checkLogin = individualtwofaswitch
            ? individualtwofaswitch?.loginipswitch
            : loginswitch;

        const WorkStationShortName = await WorkStationShortNameGeneration();

        const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
        const workstationNames = user?.workstation;
        let matchedWorkStation = "";
        let matchedUserWorkStation = "";

        if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

            matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
            matchedWorkStation = "Primary WorkStation";

        } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

            matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
            matchedWorkStation = "Secondary WorkStation";

        } else if (user?.workstationinput?.slice(0, 15) === hostname) {

            matchedUserWorkStation = user?.workstationinput
            matchedWorkStation = "Work From Home";
        }

        MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
        const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
        const countWorStation = matchedWorkStation === "Primary WorkStation" ?
            1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

        user["sigindate"] = moment().format("DD-MM-YYYY");
        const result = await user.save();

        var logincheck;
        if (clockinip?.length === 0) {
            logincheck = "NOTSHOW";
        } else {
            logincheck = "SHOW";
        }
        const isIpInData = clockinip?.some((entry) =>
            entry.ipaddress.includes(publicIP)
        );
        if (
            checkLogin &&
            !user.role.includes("Manager") &&
            logincheck === "SHOW" &&
            !isIpInData
        ) {
            return next(new ErrorHandler("Login Restricted", 401));
        }
        const userMacTwoFatrue = user?.loginUserStatus?.some(
            (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
        );

        if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {
            const secret = authenticator.generateSecret();
            const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
            const image = await qrcode.toDataURL(uri);

            if (
                user?.loginUserStatus?.length == 0 ||
                user?.loginUserStatus === undefined
            ) {
                user["loginUserStatus"] = {
                    macaddress: macAddress,
                    username: systemname,
                    localip: localIp,
                    status: "Active",
                    twofatempsecret: secret,
                    hostname: hostname,
                    twofaenabled: false,
                    version: version,
                    workstation: matchedUserWorkStation,
                    matchedstatus: MatchedNotMatched,
                    matched: matchedWorkStation,
                    count: countWorStation

                };
                const result = await user.save();
                return res.status(201).json({
                    generateqr: true,
                    image,
                    result,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation
                });
            } else if (user?.loginUserStatus?.length > 0) {
                const gesyscont = user?.loginUserStatus.filter((data) => {
                    return data.macaddress != "none";
                });

                if (macAddress != "none") {
                    if (
                        ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
                        !user?.loginUserStatus?.some(
                            (data) => (data.macaddress === macAddress || data.hostname === hostname)
                        )
                    ) {
                        return next(
                            new ErrorHandler(
                                "Reached Your System Count.Please Contact Administrator",
                                401
                            )
                        );
                    } else {
                        const remaining = user?.loginUserStatus
                            ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
                            ?.map((dar) => ({ ...dar, status: "Inactive" }));

                        user["loginUserStatus"] = [
                            ...remaining,
                            {
                                macaddress: macAddress,

                                username: systemname,
                                localip: localIp,
                                status: "Active",
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation
                            },
                        ];
                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation
                        });
                    }
                } else {
                    if (macAddress != "none") {
                        const remaining = user?.loginUserStatus
                            ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
                            ?.map((dar) => ({ ...dar, status: "Inactive" }));

                        user["loginUserStatus"] = [
                            ...remaining,
                            {
                                macaddress: macAddress,
                                username: systemname,
                                localip: localIp,
                                status: "Active",
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation
                            },
                        ];

                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation
                        });
                    } else {
                        const result = user;
                        return res.status(201).json({
                            generateqr: true,
                            image,

                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation
                        });
                    }
                }
            }
        } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
            if (!otp) {
                const remaining = user?.loginUserStatus
                    ?.filter((data) => data.macaddress !== macAddress)
                    ?.map((dar) => ({ ...dar, status: "Inactive" }));

                return res.status(201).json({
                    otpneeded: true,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation
                });
            }

            const userMacTwoFaSecret = user?.loginUserStatus?.find(
                (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
            );

            const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

            if (!verified) {
                return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
            }
            checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
                checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                matchedWorkStation, appUpdateCalculation);
        } else {
            const gesyscont = user?.loginUserStatus.filter((data) => {
                return data.macaddress != "none";
            });
            if (
                user?.loginUserStatus?.find((data) =>
                    (data.macaddress === macAddress || data.hostname === hostname))
            ) {
                const result = await user.save();
                checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
                    checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                    matchedWorkStation, appUpdateCalculation);
            } else if (

                ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
                macAddress !== "none" && hostname !== "none" &&
                !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
            ) {
                return next(
                    new ErrorHandler(
                        "Reached Your System Count.Please Contact Administrator",
                        401
                    )
                );
            } else {
                if (macAddress !== "none") {
                    const remaining = user?.loginUserStatus?.map((dar) => ({
                        ...dar,
                        status: "Inactive",
                    }));

                    user["loginUserStatus"] = [
                        ...remaining,
                        {
                            macaddress: macAddress,
                            username: systemname,
                            hostname: hostname,
                            localip: localIp,
                            status: "Active",
                            version: version,
                            workstation: matchedUserWorkStation,
                            matchedstatus: MatchedNotMatched,
                            matched: matchedWorkStation,
                            count: countWorStation
                        },
                    ];
                    // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
                    // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

                    const result = await user.save();
                    checksendToken(
                        result,
                        200,
                        res,
                        loginapprestriction,
                        checkAutoLogoutTime,
                        checkAutoLogoutDate,
                        controlcriteria,
                        MatchedNotMatched, resversion,
                        matchedWorkStation,
                        appUpdateCalculation
                    );
                } else {
                    checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
                        checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                        matchedWorkStation, appUpdateCalculation);
                }
            }
        }
    } catch (err) {
        return next(new ErrorHandler("User not found", 404));
    }
});

exports.authenticateUser = catchAsyncErrors(async (req, res, next) => {
    try {
        const { currenturl, faceDescriptor } = req.body;
        let controlcriteria, user;
        const resonablestatusarray = [
            "Absconded",
            "Hold",
            "Terminate",
            "Releave Employee",
            "Not Joined",
            "Postponed",
            "Rejected",
            "Closed",
        ];

        // Ensure faceDescriptor is an array of numbers
        if (
            !Array.isArray(faceDescriptor) ||
            !faceDescriptor.every((num) => typeof num === "number")
        ) {
            throw new Error("Invalid face descriptor format.");
        }

        // Fetch all user face descriptors from MongoDB
        const allUsers = await User.find(
            {
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            { faceDescriptor: 1 }
        ).lean();

        let authenticated = false;

        // Compare face descriptors
        for (const suser of allUsers) {
            const storedDescriptor = suser?.faceDescriptor;


            if (
                Array.isArray(storedDescriptor) &&
                storedDescriptor.length === faceDescriptor.length
            ) {
                const distance = faceapi.euclideanDistance(
                    faceDescriptor,
                    storedDescriptor
                );

                if (distance < 0.4) {
                    authenticated = true;
                    user = await User.findOne({ _id: suser._id });
                    break; // Exit loop once authenticated
                }
            }
        }

        if (!user && !authenticated) {
            return next(new ErrorHandler("Face Not Detected", 401));
        }

        if (resonablestatusarray.includes(user?.resonablestatus)) {
            return next(new ErrorHandler("Login Restricted", 401));
        }

        const overallsettings = await AdminOverAllSettings.find();
        let individualsettings = await IndividualSettings.find({
            company: user?.company,
            branch: user?.branch,
            unit: user?.unit,
            team: user?.team,
            companyname: { $in: user?.companyname },
        });
        let individualtwofaswitch = individualsettings?.find((item) =>
            item.companyname.includes(user?.companyname)
        );

        let externalurl =
            overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
                    (item) => new URL(item).hostname
                )
                : [];
        let internalurl =
            overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
                    (item) => new URL(item).hostname
                )
                : [];

        let finalLoginMode = individualtwofaswitch
            ? individualtwofaswitch?.loginmode
            : overallsettings[overallsettings.length - 1]?.loginmode;

        if (
            currenturl !== undefined &&
            finalLoginMode === "Internal Login" &&
            !internalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {
            return next(
                new ErrorHandler(`UnAuthorized Login, Contact Administrator`, 401)
            );
        } else if (
            currenturl !== undefined &&
            finalLoginMode === "External Login" &&
            !externalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {
            return next(
                new ErrorHandler(`UnAuthorized Login ,Contact Administrator`, 401)
            );
        }

        //   if (!user.role.includes("Manager")) {
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),

            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];

        // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
        const [attendance, allLeaveStatus, holidays] = await Promise.all([
            // Fetch relevant attendance records for the past 3 days for the specific user
            Attendance.find(
                {
                    date: {
                        $in: pastThreeAttendaysDays,
                    },
                    userid: user._id,
                },
                { date: 1, userid: 1 }
            ).lean(),

            // Fetch relevant leave records for the specific user
            ApplyLeave.find(
                {
                    date: { $in: pastThreeLeaveDays },
                    employeeid: user.empcode,
                    employeename: user.companyname,
                },
                { employeename: 1, employeeid: 1, date: 1 }
            ).lean(),

            // Fetch relevant holidays for the specific user
            Holiday.find(
                {
                    date: { $in: pastThreeDaysISO },
                    company: { $in: [user.company] }, // Checks if user's company is in the company array
                    applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
                    unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
                    team: { $in: [user.team] }, // Checks if user's team is in the team array
                    employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
                },
                { date: 1, employee: 1 }
            ).lean(),
        ]);

        // Continue with your logic

        // Create maps for attendance, leave, and holidays for quick lookup

        const attendanceMap = attendance.reduce((acc, item) => {
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});
        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            item.date.forEach((date) => {
                acc[date] = true;
            });
            return acc;
        }, {});

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (weekOffDays) => {
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[date]) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[date]) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[date]) {
                    // User had a holiday on this date

                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            if (absentDays >= 4) {
                return "Long Absent";
            } else if (leaveDays >= 4) {
                return "Long Leave";
            } else if (holidayDays >= 4) {
                return null;
            } else {
                return null;
            }
        };

        // Function to determine the final status
        const determineStatus = (attendanceStatus, livestatus) => {
            if (attendanceStatus) {
                return attendanceStatus;
            } else if (livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };
        let weekOffDays = [];
        if (user.boardingLog && user.boardingLog.length > 0) {
            const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
            weekOffDays = lastBoardingLog.weekoff || [];
        }
        // Determine the user's status
        const attendanceStatus = checkStatusForPast3Days(weekOffDays);
        const livestatus = !attendanceStatus ? "Live" : null;

        const userStatus = determineStatus(attendanceStatus, livestatus);

        const todaydate = moment().format("DD-MM-YYYY");
        const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
        const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
        const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

        let checkArray = user.longleaveabsentaprooveddate.every(
            (date) => !dateArray.includes(date)
        );
        if (
            !pastThreeDaysISO?.includes(user?.doj) &&
            userStatus === "Long Absent" &&
            Array.isArray(user?.longleaveabsentaprooveddate) &&
            checkArray &&
            !user.role.includes("Manager")
        ) {
            return next(
                new ErrorHandler(
                    `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
                    401
                )
            );
        }

        controlcriteria = await ControlCriteria.find();

        let loginapprestriction = user?.extramode
            ? user?.extramode
            : individualtwofaswitch
                ? individualtwofaswitch?.loginapprestriction
                : overallsettings[overallsettings.length - 1]?.loginapprestriction;

        checksendToken(user, 200, res, loginapprestriction, controlcriteria);
    } catch (err) {
        return next(new ErrorHandler("User not found", 404));
    }
});



// "/:id/verify/:token"
exports.verifyUserEmail = catchAsyncErrors(async (req, res, next) => {
    try {
        const user = await User.findOne({ _id: req.params.id });
        if (!user) {
            return next(new ErrorHandler("Invalid Link", 400));
        }

        const token = await Token.findOne({
            userId: user._id,
            token: req.params.token,
        });
        if (!token) {
            return next(new ErrorHandler("Invalid Link", 400));
        }
        const users = await User.findById({ _id: user._id });
        if (!users) {
            return next(new ErrorHandler("User not found!", 404));
        }
        users["emailverification"] = true;
        const result = await users.save();
        await Token.findByIdAndRemove({ _id: token._id });
        return res.status(200).json({
            success: true,
            message: "Email Verified Successfully",
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

// exports.verifytwofa = catchAsyncErrors(async (req, res, next) => {
//     try {
//         const { id, otp } = req.body;
//         const user = await User.findById(id);
//         if (!user) {
//             return next(new ErrorHandler("User not found!", 404));
//         }
//         const verified = authenticator.check(otp, user.twofatempsecret);
//         if (!verified) {
//             return next(new ErrorHandler("Invalid Otp!", 404));
//         }
//         user["twofaenabled"] = true;
//         user["twofasecret"] = user.twofatempsecret;
//         const result = await user.save();

//         sendToken(result, 200, res);
//     } catch (err) {
//         return next(new ErrorHandler("Records not found!", 404));
//     }
// });

exports.verifytwofa = catchAsyncErrors(async (req, res, next) => {
    try {
        const { id, otp, macAddress } = req.body;
        const user = await User.findById(id);


        let userMacTwoFaSecret = user?.loginUserStatus?.find(data => data?.macaddress === macAddress && data?.twofaenabled === false)


        if (!user) {
            return next(new ErrorHandler("User not found!", 404));
        }
        const verified = authenticator.check(otp, userMacTwoFaSecret.twofatempsecret);
        if (!verified) {
            return next(new ErrorHandler("Invalid Otp!", 404));
        }

        const loginUsernon = user?.loginUserStatus?.filter(data => data?.macaddress !== userMacTwoFaSecret?.macaddress)
        if (userMacTwoFaSecret) {
            userMacTwoFaSecret.twofasecret = userMacTwoFaSecret.twofatempsecret;
            userMacTwoFaSecret.twofaenabled = true;
        }

        // function updateOtp(user, newOtp) {
        //     return {
        //         ...user,
        //         twofasecret: newOtp,
        //         twofaenabled: true
        //     };
        // }
        // const updatedLogin = updateOtp(userMacTwoFaSecret , userMacTwoFaSecret.twofatempsecret);
        const loginUserUpdated = [...loginUsernon, userMacTwoFaSecret]
        user["loginUserStatus"] = loginUserUpdated;



        // user["twofaenabled"] = true;
        // user["twofasecret"] = user.twofatempsecret;
        const result = await user.save();

        checksendToken(result, 200, res);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});
exports.verifychecktwofa = catchAsyncErrors(async (req, res, next) => {
    try {
        const { id, otp, macAddress } = req.body;
        const user = await User.findById(id);


        let userMacTwoFaSecret = user?.loginUserStatus?.find(data => data?.macaddress === macAddress && data?.twofaenabled === false)


        if (!user) {
            return next(new ErrorHandler("User not found!", 404));
        }
        const verified = authenticator.check(otp, userMacTwoFaSecret.twofatempsecret);
        if (!verified) {
            return next(new ErrorHandler("Invalid Otp!", 404));
        }

        const loginUsernon = user?.loginUserStatus?.filter(data => data?.macaddress !== userMacTwoFaSecret?.macaddress)
        if (userMacTwoFaSecret) {
            userMacTwoFaSecret.twofasecret = userMacTwoFaSecret.twofatempsecret;
            userMacTwoFaSecret.twofaenabled = true;
        }

        // function updateOtp(user, newOtp) {
        //     return {
        //         ...user,
        //         twofasecret: newOtp,
        //         twofaenabled: true
        //     };
        // }
        // const updatedLogin = updateOtp(userMacTwoFaSecret , userMacTwoFaSecret.twofatempsecret);
        const loginUserUpdated = [...loginUsernon, userMacTwoFaSecret]
        user["loginUserStatus"] = loginUserUpdated;



        // user["twofaenabled"] = true;
        // user["twofasecret"] = user.twofatempsecret;
        const result = await user.save();

        checksendToken(result, 200, res);
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
});


// Logout user => api/authout
exports.loginOut = catchAsyncErrors(async (req, res, next) => {
    res.cookie("token", null, {
        expires: new Date(Date.now()),
        httpOnly: true,
    });

    res.status(200).json({
        success: true,
        message: "Logged out!",
    });
});

//  get overall delete functionality
exports.getAllUserCheck = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            company: req.body.checkuser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllUserBranch = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            branch: req.body.checkbranch,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllUnitToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            unit: req.body.checkunittouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllFloorToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            floor: req.body.checkfloortouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllDepartmentToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            department: req.body.checkdepartmenttouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllTeamToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            team: req.body.checkteamtouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllDesigToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            designation: req.body.checkdesigtouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllQualToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        const query = {
            eduTodo: {
                $elemMatch: {
                    qualification: req.body.checkqualtouser,
                },
            },
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllSkillToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        const query = {
            addAddQuaTodo: {
                $elemMatch: {
                    addQual: req.body.checkskilltouser,
                },
            },
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllShiftToUser = catchAsyncErrors(async (req, res, next) => {

    let users;
    try {
        const query = {
            $or: [
                { 'boardingLog.shifttiming': req.body.checkshifttouser },
                { 'boardingLog': { $elemMatch: { 'todo.shifttiming': req.body.checkshifttouser } } }
            ]
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllShiftToUserBulkDelete = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.aggregate([
            {
                $match: {
                    $or: [
                        { "boardingLog.shifttiming": { $in: req.body.checkshifttouser } },
                        { "boardingLog.todo.shifttiming": { $in: req.body.checkshifttouser } }
                    ]
                }
            },
            {
                $lookup: {
                    from: 'shifts',
                    localField: 'boardingLog.shifttiming',
                    foreignField: 'name',
                    as: 'matchedShifts'
                }
            },
            {
                $lookup: {
                    from: 'shifts',
                    localField: 'boardingLog.todo.shifttiming',
                    foreignField: 'name',
                    as: 'matchedTodoShifts'
                }
            },

            {
                "$project": {
                    "username": 1,
                    "_id": 1,
                    "combinedMatchedShifts": {
                        "$setUnion": [
                            {
                                "$map": {
                                    "input": "$matchedShifts",
                                    "as": "shift",
                                    "in": { "$toString": "$$shift._id" }
                                }
                            },
                            {
                                "$map": {
                                    "input": "$matchedTodoShifts",
                                    "as": "todoShift",
                                    "in": { "$toString": "$$todoShift._id" }
                                }
                            },

                        ]
                    }
                }
            }
        ])
    } catch (err) {
        return next({});
    }

    if (!users) {
        return next({});
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllRoleToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            role: req.body.checkroletouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

// get Signle user => /api/auth/:id
exports.getSingleUser = catchAsyncErrors(async (req, res, next) => {
    const suser = await User.findById(req.params.id);

    if (!suser) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({
        success: true,
        suser,
    });
});

// update user by id => /api/user/:id
exports.updateUserPwd = catchAsyncErrors(async (req, res, next) => {
    try {
        const id = req.params.id;
        const upuserone = await User.findByIdAndUpdate(id, req.body);

        if (!upuserone) {
            return next(new ErrorHandler("User not found", 404));
        }

        return res.status(200).json({ message: "Updated successfully!" });
    } catch (err) {
    }
});

// update user by id => /api/auth/:id
exports.updateUser = catchAsyncErrors(async (req, res, next) => {
    const {
        prefix,
        firstname,
        lastname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        username,
        usernameautogenerate,
        workmode,
        password,
        autogeneratepassword,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail, resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        dom,
        referencetodo,
        contactno,
        details,
        companyname,
        addremoteworkmode,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        unit,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        samesprmnt,
        floor,
        company,
        experience,
        addedby,
        updatedby,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        //draft,
        reportingto,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        assignExpLog,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        shifttype,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode,
    } = req.body;
    // encrypt password before saving
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);

    const id = req.params.id;

    const upuser = await User.findByIdAndUpdate(id, {
        prefix,
        username,
        usernameautogenerate,
        workmode,
        lastname,
        email,
        employeecount,
        systemmode,
        addremoteworkmode,
        companyemail, resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        firstname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        dom,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail, resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        referencetodo,
        status,
        percentage,
        contactno,
        details,
        companyname,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        floor,
        experience,
        samesprmnt,
        unit,
        addedby,
        updatedby,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        //draft,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        company,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        password: hashPassword,
        autogeneratepassword,
        assignExpLog,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        shifttype,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode,
    });

    if (!upuser) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({ message: "Updated successfully!", upuser });
});

// delete user by id => /api/auth/:id
exports.deleteUser = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;

    const duser = await User.findByIdAndRemove(id);

    if (!duser) {
        return next(new ErrorHandler("User not found", 404));
    }

    res.status(200).json({ message: "Deleted successfully" });
});

// Shift Roaster functions
// Get Clock in time for the user
const checkGetClockInTime = (attendance, rowuserid, rowdate, rowshift, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {

        return attendanceRecord.clockintime !== "" ? rowshift === 'Week Off' ? "00:00:00" : attendanceRecord.clockintime : "00:00:00";
    }
    // Return a default value if clockin time is not available
    return "00:00:00";

};

// Get Clock out time for the user
const checkGetClockOutTime = (attendance, rowuserid, rowdate, rowshift, rowshiftmode) => {

    const attendanceRecord = attendance.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.clockouttime !== "" ? rowshift === 'Week Off' ? "00:00:00" : attendanceRecord.clockouttime : "00:00:00";
    }
    // Return a default value if clockin time is not available
    return "00:00:00";

};
// Get Clock in date for the user
const checkGetClockInDate = (attendance, rowuserid, rowdate, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.date;
    }
    // Return a default value if clockin date is not available
    return "";

};

const checkGetClockInAutoStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.autoclockout;
    }
    // Return a default value if clockin date is not available
    return "";

};

const getUserIp = (attendance, rowuserid, rowdate, rowshiftmode) => {
    // Find the attendance record for the given user id and date
    const attendanceRecord = attendance.find(
        (record) => record.userid === rowuserid && formatDateRemove(record.date) === rowdate && record.shiftmode === rowshiftmode
    );

    if (attendanceRecord) {
        return attendanceRecord.clockinipaddress;
    }

    // Return an empty string if no attendance record is found
    return "";
};

const checkClockInStatus = (clockintime, rowshift, graceTime, allLeaveStatus, holidays, clockindate, rowbranch, rowempcode, rowcompany, rowformattedDate, rowunit, rowteam, rowcompanyname,
    earlyClockInTime, lateClockInTime, afterLateClockInTime, leavetype, permission, clockouttime, rowshiftmode, weekoffpresentstatus) => {

    const totalFinalLeaveDaysApproved = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Approved");
    const totalFinalLeaveDaysApplied = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Applied");
    const totalFinalLeaveDaysRejected = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Rejected");

    const permissionApprovedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === '');
    const permissionAppliedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === '');
    const permissionRejectedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Rejected" && d.compensationstatus === '');

    // const totalPermissionApprovedStart = permission.find((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    // const totalPermissionAppliedStart = permission.find((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const totalPermissionApprovedStart = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    const totalPermissionAppliedStart = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const holidayResults = holidays.filter((item) => moment(item.date, "YYYY-MM-DD").format("DD/MM/YYYY") === rowformattedDate)
    const isHoliday = holidayResults?.some(holiday =>
        holiday.company?.includes(rowcompany) &&
            holiday.applicablefor?.includes(rowbranch) &&
            holiday.unit?.includes(rowunit) &&
            holiday.team?.includes(rowteam) &&
            holiday.employee.includes('ALL') ? rowcompanyname : holiday.employee?.includes(rowcompanyname)
    );

    let leavestatusApproved = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApproved.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusApplied = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApplied.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusRejected = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusRejected.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    const leaveOnDateApprovedSingleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedSingleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedSingleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateApprovedDoubleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedDoubleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedDoubleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedSingleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedSingleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedSingleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedDoubleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedDoubleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedDoubleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedSingleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedSingleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedSingleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedDoubleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedDoubleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedDoubleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    if (permissionApprovedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERAPPR";
    }
    if (permissionAppliedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERAPPL";
    }
    if (permissionRejectedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERREJ";
    }
    if (totalPermissionApprovedStart.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "COMP - PERAPPR";
    }
    if (totalPermissionAppliedStart.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "COMP - PERAPPR";
    }

    // let clockInTime = parseTime(clockintime, rowformattedDate);
    // let startTime = parseTime(rowshift?.split('to')[0], rowformattedDate);
    // let startTimeWithPM = rowshift?.split('to')[0];
    // let endTime = parseTime(rowshift?.split('to')[1], rowformattedDate);

    // Get current date and time
    var now = new Date();
    var dd = String(now.getDate()).padStart(2, "0");
    var mm = String(now.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = now.getFullYear();
    var today = dd + "/" + mm + "/" + yyyy;

    // Extract hours and minutes
    var hours = now.getHours();
    var minutes = now.getMinutes();

    // Format hours and minutes to always have two digits
    var formattedHours = String(hours).padStart(2, '0');
    var formattedMinutes = String(minutes).padStart(2, '0');

    // Combine hours and minutes into the desired format
    var currentTime = formattedHours + ":" + formattedMinutes;

    let clockInTime = parseTime(clockintime);
    let startTime = parseTime(rowshift?.split('to')[0]);
    let startTimeWithPM = rowshift?.split('to')[0];

    if (!startTime) {
        return (rowshift === 'Week Off' && clockintime === "00:00:00") ? 'Week Off' : 'Invalid start time';
    }

    if (startTimeWithPM.includes('PM')) {
        // early clockintime
        const earlyTimeInMilliseconds = earlyClockInTime * 60000;
        const startTimeWithEarly = new Date(startTime?.getTime() - earlyTimeInMilliseconds);

        // Add graceTime to the startTime
        const graceTimeInMilliseconds = graceTime * 60000; // Convert graceTime to milliseconds
        const startTimeWithGrace = new Date(startTime?.getTime() + graceTimeInMilliseconds);

        // late clockin 
        const lateTimeInMilliseconds = lateClockInTime * 60000;
        const startTimeWithLate = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds);

        // after late lop
        const halfLopTimeInMilliseconds = afterLateClockInTime * 60000;
        const startTimeWithHalfLop = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds + halfLopTimeInMilliseconds);

        // Adjust endTime if it's a night shift
        if (startTimeWithPM.includes('PM') && clockintime.includes('AM')) {
            clockInTime.setDate(clockInTime.getDate() + 1); // Move endTime to the next day
        }

        // Night Shift
        // Check if clockInTime is within the grace period
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (leaveOnDateApprovedSingleFL) {
            return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
        }
        else if (leaveOnDateApprovedSingleHB) {
            return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
        }
        else if (leaveOnDateApprovedSingleHA) {
            return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
        }
        else if (leaveOnDateApprovedDoubleFL) {
            return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
        }
        else if (leaveOnDateApprovedDoubleHB) {
            return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
        }
        else if (leaveOnDateApprovedDoubleHA) {
            return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
        }
        else if (leaveOnDateAppliedSingleFL) {
            return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
        }
        else if (leaveOnDateAppliedSingleHB) {
            return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
        }
        else if (leaveOnDateAppliedSingleHA) {
            return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
        }
        else if (leaveOnDateAppliedDoubleFL) {
            return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
        }
        else if (leaveOnDateAppliedDoubleHB) {
            return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
        }
        else if (leaveOnDateAppliedDoubleHA) {
            return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
        }
        else if (leaveOnDateRejectedSingleFL) {
            return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
        }
        else if (leaveOnDateRejectedSingleHB) {
            return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
        }
        else if (leaveOnDateRejectedSingleHA) {
            return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
        }
        else if (leaveOnDateRejectedDoubleFL) {
            return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
        }
        else if (leaveOnDateRejectedDoubleHB) {
            return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
        }
        else if (leaveOnDateRejectedDoubleHA) {
            return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
        }
        else if (rowshift === "Pending..." && clockintime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockintime === "00:00:00") {
            return `Week Off`;
        }
        else if (weekoffpresentstatus === true) {
            return 'Week Off Present';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (clockInTime >= startTimeWithEarly && clockInTime <= startTime) {
            return `On - Present`;
        }
        else if (clockInTime >= startTimeWithGrace && clockInTime <= startTimeWithLate) {
            return `Late - ClockIn`;
        }
        else if (clockInTime >= startTimeWithLate && clockInTime <= startTimeWithHalfLop) {
            return `HBLOP`;
        }
        else if (clockInTime >= startTimeWithHalfLop) {
            return `FLOP`;
        }
        else if (clockInTime >= startTime && clockInTime <= startTimeWithGrace) {
            return `Grace - ClockIn`;
        }
        else if (clockInTime < startTimeWithEarly) {
            return `Early - ClockIn`;
        }
        else {
            return `Present`;
        }
    }
    else {
        // early clockintime
        const earlyTimeInMilliseconds = earlyClockInTime * 60000;
        const startTimeWithEarly = new Date(startTime?.getTime() - earlyTimeInMilliseconds);

        // Add graceTime to the startTime
        const graceTimeInMilliseconds = graceTime * 60000; // Convert graceTime to milliseconds
        const startTimeWithGrace = new Date(startTime?.getTime() + graceTimeInMilliseconds);

        // late clockin 
        const lateTimeInMilliseconds = lateClockInTime * 60000;
        const startTimeWithLate = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds);

        // after late lop
        const halfLopTimeInMilliseconds = afterLateClockInTime * 60000;
        const startTimeWithHalfLop = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds + halfLopTimeInMilliseconds);

        // Day Shift
        // Check if clockInTime is within the grace period
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        // else if (leaveOnDateCasualApproved.length > 0 && rowshift !== "Week Off") {
        //     return 'Leave ';
        // }
        else if (leaveOnDateApprovedSingleFL) {
            return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
        }
        else if (leaveOnDateApprovedSingleHB) {
            return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
        }
        else if (leaveOnDateApprovedSingleHA) {
            return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
        }
        else if (leaveOnDateApprovedDoubleFL) {
            return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
        }
        else if (leaveOnDateApprovedDoubleHB) {
            return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
        }
        else if (leaveOnDateApprovedDoubleHA) {
            return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
        }
        else if (leaveOnDateAppliedSingleFL) {
            return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
        }
        else if (leaveOnDateAppliedSingleHB) {
            return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
        }
        else if (leaveOnDateAppliedSingleHA) {
            return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
        }
        else if (leaveOnDateAppliedDoubleFL) {
            return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
        }
        else if (leaveOnDateAppliedDoubleHB) {
            return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
        }
        else if (leaveOnDateAppliedDoubleHA) {
            return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
        }
        else if (leaveOnDateRejectedSingleFL) {
            return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
        }
        else if (leaveOnDateRejectedSingleHB) {
            return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
        }
        else if (leaveOnDateRejectedSingleHA) {
            return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
        }
        else if (leaveOnDateRejectedDoubleFL) {
            return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
        }
        else if (leaveOnDateRejectedDoubleHB) {
            return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
        }
        else if (leaveOnDateRejectedDoubleHA) {
            return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
        }
        else if (rowshift === "Pending..." && clockintime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockintime === "00:00:00") {
            return `Week Off`;
        }
        else if (weekoffpresentstatus === true) {
            return 'Week Off Present';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (clockInTime >= startTimeWithEarly && clockInTime <= startTime) {
            return `On - Present`;
        }
        else if (clockInTime >= startTimeWithGrace && clockInTime <= startTimeWithLate) {
            return `Late - ClockIn`;
        }
        else if (clockInTime >= startTimeWithLate && clockInTime <= startTimeWithHalfLop) {
            return `HBLOP`;
        }
        else if (clockInTime >= startTimeWithHalfLop) {
            return `FLOP`;
        }
        else if (clockInTime >= startTime && clockInTime <= startTimeWithGrace) {
            return `Grace - ClockIn`;
        }
        else if (clockInTime < startTimeWithEarly) {
            return `Early - ClockIn`;
        }
        else {
            return `Present`;
        }
    }

};

const checkClockOutStatus = (clockouttime, clockintime, rowshift, clockOutHours, clockindate, allLeaveStatus, holidays, rowbranch, rowempcode, rowcompany, rowformattedDate, rowunit, rowteam, rowcompanyname, onClockOutTime,
    earlyClockOutTime, beforeEarlyClockOutTime, autoClockOutStatus, leavetype, permission, rowshiftmode, weekoffpresentstatus) => {

    const totalFinalLeaveDaysApproved = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Approved");
    const totalFinalLeaveDaysApplied = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Applied");
    const totalFinalLeaveDaysRejected = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Rejected");

    const permissionApprovedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === '');
    const permissionAppliedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === '');
    const permissionRejectedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Rejected" && d.compensationstatus === '');

    const totalPermissionApprovedEnd = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    const totalPermissionAppliedEnd = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const holidayResults = holidays.filter((item) => moment(item.date, "YYYY-MM-DD").format("DD/MM/YYYY") === rowformattedDate)

    const isHoliday = holidayResults.some(holiday =>
        holiday.company?.includes(rowcompany) &&
            holiday.applicablefor?.includes(rowbranch) &&
            holiday.unit?.includes(rowunit) &&
            holiday.team?.includes(rowteam) &&
            holiday.employee.includes('ALL') ? rowcompanyname : holiday.employee?.includes(rowcompanyname)
    );

    let leavestatusApproved = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApproved.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusApplied = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApplied.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusRejected = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusRejected.push({
                        date: shift.formattedDate,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    const leaveOnDateApprovedSingleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedSingleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedSingleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateApprovedDoubleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedDoubleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedDoubleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedSingleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedSingleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedSingleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedDoubleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedDoubleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedDoubleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedSingleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedSingleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedSingleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedDoubleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedDoubleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedDoubleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    if (leaveOnDateApprovedSingleFL) {
        return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
    }
    else if (leaveOnDateApprovedSingleHB) {
        return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
    }
    else if (leaveOnDateApprovedSingleHA) {
        return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
    }
    else if (leaveOnDateApprovedDoubleFL) {
        return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
    }
    else if (leaveOnDateApprovedDoubleHB) {
        return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
    }
    else if (leaveOnDateApprovedDoubleHA) {
        return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
    }
    else if (leaveOnDateAppliedSingleFL) {
        return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
    }
    else if (leaveOnDateAppliedSingleHB) {
        return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
    }
    else if (leaveOnDateAppliedSingleHA) {
        return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
    }
    else if (leaveOnDateAppliedDoubleFL) {
        return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
    }
    else if (leaveOnDateAppliedDoubleHB) {
        return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
    }
    else if (leaveOnDateAppliedDoubleHA) {
        return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
    }
    else if (leaveOnDateRejectedSingleFL) {
        return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
    }
    else if (leaveOnDateRejectedSingleHB) {
        return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
    }
    else if (leaveOnDateRejectedSingleHA) {
        return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
    }
    else if (leaveOnDateRejectedDoubleFL) {
        return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
    }
    else if (leaveOnDateRejectedDoubleHB) {
        return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
    }
    else if (leaveOnDateRejectedDoubleHA) {
        return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
    }

    if (permissionApprovedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERAPPR";
    }
    if (permissionAppliedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERAPPL";
    }
    if (permissionRejectedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "PERREJ";
    }
    if (totalPermissionApprovedEnd.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "COMP - PERAPPR";
    }
    if (totalPermissionAppliedEnd.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate))) {
        return "COMP - PERAPPR";
    }
    if (weekoffpresentstatus === true) {
        return 'Week Off Present';
    }

    // Get current date and time
    var now = new Date();
    var dd = String(now.getDate()).padStart(2, "0");
    var mm = String(now.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = now.getFullYear();
    var today = dd + "/" + mm + "/" + yyyy;

    // Extract hours and minutes
    var hours = now.getHours();
    var minutes = now.getMinutes();

    // Format hours and minutes to always have two digits
    var formattedHours = String(hours).padStart(2, '0');
    var formattedMinutes = String(minutes).padStart(2, '0');

    // Combine hours and minutes into the desired format
    var currentTime = formattedHours + ":" + formattedMinutes;

    let clockOutTime = parseTime(clockouttime);
    let startTime = parseTime(rowshift?.split('to')[0]);
    let startTimeWithPM = rowshift?.split('to')[0];

    let endTime = parseTime(rowshift?.split('to')[1]);

    if (!startTime) {
        return (rowshift === 'Week Off' && clockintime === "00:00:00") ? 'Week Off' : 'Invalid start time';
    }

    if (!endTime) {
        return (rowshift === 'Week Off' && clockouttime === "00:00:00") ? 'Week Off' : (rowshift === 'Pending...' && clockouttime !== "00:00:00") ? 'Pending...' : 'Invalid end time';
    }

    // Determine if it's a night shift
    const isNightShift = startTime.getHours() >= 12;

    // Compare clockouttime based on shift type
    if (startTimeWithPM.includes('PM')) {

        // Adjust endTime if it's a night shift
        if (startTimeWithPM.includes('PM') && clockouttime.includes('AM')) {
            // Check if endTime is before startTime (indicating the shift crosses midnight)        
            if (endTime < startTime) {
                endTime.setDate(endTime.getDate() + 1); // Move endTime to the next day
                clockOutTime.setDate(clockOutTime.getDate() + 1);
            }
        }
        else if (startTimeWithPM.includes('PM') && clockouttime.includes('PM')) {
            if (endTime < startTime) {
                endTime.setDate(endTime.getDate() + 1);
                clockOutTime.setDate(clockOutTime.getDate() - 1);
            }
        }

        // Add onClockOutTime to the endTime
        const onClockOutMilliseconds = onClockOutTime * 60000; // Convert onClockOutTime to milliseconds
        const endTimeWithGrace = new Date(endTime?.getTime() + onClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const earlyClockOutMilliseconds = earlyClockOutTime * 60000;
        const endTimeWithEarly = new Date(endTime?.getTime() - earlyClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const beforeEarlyClockOutMilliseconds = beforeEarlyClockOutTime * 60000;
        const endTimeWithBeforeEarly = new Date(endTime?.getTime() - earlyClockOutMilliseconds - beforeEarlyClockOutMilliseconds);

        const [rowday, rowmonth, rowyear] = rowformattedDate.split('/');
        const addrowday = Number(rowday) + 1;
        const endRowDayAdd = String(addrowday).padStart(2, '0');

        const currentDate = new Date();
        const curyear = currentDate.getFullYear();
        const curmonth = String(currentDate.getMonth() + 1).padStart(2, '0'); // Add 1 to month as it's zero-based
        const curday = String(currentDate.getDate()).padStart(2, '0');
        const hours = String(currentDate.getHours()).padStart(2, '0');
        const minutes = String(currentDate.getMinutes()).padStart(2, '0');
        const seconds = String(currentDate.getSeconds()).padStart(2, '0');

        const endHoursN8 = String(endTime?.getHours()).padStart(2, '0');
        const endMinutesN8 = String(endTime?.getMinutes()).padStart(2, '0');
        const endSecondsN8 = String(endTime?.getSeconds()).padStart(2, '0');

        const currentDateTimeString = `${curyear}-${curmonth}-${curday} ${hours}:${minutes}:${seconds}`;
        const getEndTimeForNight = `${rowyear}-${rowmonth}-${endRowDayAdd} ${endHoursN8}:${endMinutesN8}:${endSecondsN8}`;




        // Night shift
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && clockouttime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (rowshift === "Pending..." && clockouttime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockouttime === "00:00:00") {
            return `Week Off`;
        }
        else if (autoClockOutStatus === true && clockouttime !== "00:00:00") {
            return `Auto Mis - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithEarly && clockOutTime < endTime) {
            return `Early - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithBeforeEarly && clockOutTime < endTimeWithEarly) {
            return `HALOP`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime < endTimeWithBeforeEarly) {
            return `FLOP`;
        }
        else if (clockOutTime >= endTime && clockOutTime <= endTimeWithGrace) {
            return `On - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime > endTimeWithGrace) {
            return `Over - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockouttime === "00:00:00" && currentDateTimeString <= getEndTimeForNight) {
            return `Pending`;
        }
        else if (clockouttime === "00:00:00") {
            return `Mis - ClockOut`;
        }
    } else {

        // Parse the clock in date
        const [day, month, year] = clockindate.split('-');
        const shiftStartDate = new Date(Number(year), Number(month) - 1, Number(day));
        const shiftEndDate = new Date(Number(year), Number(month) - 1, Number(day));

        // If endTime is before startTime, it indicates the shift crosses midnight
        // Adjust endTime accordingly
        if (endTime < startTime) {
            shiftEndDate.setDate(shiftEndDate.getDate() + 1); // Adjust shiftEndDate to the next day
        }

        const [rowday, rowmonth, rowyear] = rowformattedDate.split('/');
        const addrowday = Number(rowday) + 1;
        const endRowDayAdd = String(addrowday).padStart(2, '0');

        const currentDate = new Date();
        const curyear = currentDate.getFullYear();
        const curmonth = String(currentDate.getMonth() + 1).padStart(2, '0'); // Add 1 to month as it's zero-based
        const curday = String(currentDate.getDate()).padStart(2, '0');
        const hours = String(currentDate.getHours()).padStart(2, '0');
        const minutes = String(currentDate.getMinutes()).padStart(2, '0');
        const seconds = String(currentDate.getSeconds()).padStart(2, '0');

        const endHoursN8 = String(endTime?.getHours()).padStart(2, '0');
        const endMinutesN8 = String(endTime?.getMinutes()).padStart(2, '0');
        const endSecondsN8 = String(endTime?.getSeconds()).padStart(2, '0');


        const currentDateTimeString = `${curyear}-${curmonth}-${curday} ${hours}:${minutes}:${seconds}`;
        const getEndTimeForNight = `${rowyear}-${rowmonth}-${endRowDayAdd} ${endHoursN8}:${endMinutesN8}:${endSecondsN8}`;


        // Add onClockOutTime to the endTime
        const onClockOutMilliseconds = onClockOutTime * 60000; // Convert onClockOutTime to milliseconds
        const endTimeWithGrace = new Date(endTime.getTime() + onClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const earlyClockOutMilliseconds = earlyClockOutTime * 60000;
        const endTimeWithEarly = new Date(endTime.getTime() - earlyClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const beforeEarlyClockOutMilliseconds = beforeEarlyClockOutTime * 60000;
        const endTimeWithBeforeEarly = new Date(endTime.getTime() - earlyClockOutMilliseconds - beforeEarlyClockOutMilliseconds);




        // Day shift
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && clockouttime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (rowshift === "Pending..." && clockouttime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockouttime === "00:00:00") {
            return `Week Off`;
        }
        else if (autoClockOutStatus === true && clockouttime !== "00:00:00") {
            return `Auto Mis - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithEarly && clockOutTime < endTime) {
            return `Early - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithBeforeEarly && clockOutTime < endTimeWithEarly) {
            return `HALOP`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime < endTimeWithBeforeEarly) {
            return `FLOP`;
        }
        else if (clockOutTime >= endTime && clockOutTime <= endTimeWithGrace) {
            return `On - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockOutTime > endTimeWithGrace) {
            return `Over - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockouttime === "00:00:00" && currentDateTimeString <= getEndTimeForNight) {
            return `Pending`;
        }
        else if (clockouttime === "00:00:00") {
            return `Mis - ClockOut`;
        }
    }
};


function getWeekNumberInMonth(date) {
    const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
    const dayOfWeek = firstDayOfMonth.getDay(); // 0 (Sunday) to 6 (Saturday)

    // If the first day of the month is not Monday (1), calculate the adjustment
    const adjustment = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

    // Calculate the day of the month adjusted for the starting day of the week
    const dayOfMonthAdjusted = date.getDate() + adjustment;

    // Calculate the week number based on the adjusted day of the month
    const weekNumber = Math.ceil(dayOfMonthAdjusted / 7);

    return weekNumber;
}

const getShiftForDate = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment) => {

    // const selectedDateIndex = createdUserDates.findIndex(dateObj => dateObj.formattedDate === column.formattedDate);

    // if (selectedDateIndex === -1) {
    //     return !isWeekOff ? actualShiftTiming : "Week Off";
    // }

    if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
        return 'Pending...'
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {

        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // before add shifttype condition working code
    // else if (boardingLog?.length > 0) {

    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate < finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // } 
    else if (boardingLog.length > 0) {
        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated          
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }

                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }

};

const getTotalMonthDaysUser = (rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    const totalDaysInMonth = new Date(isyear, ismonth, 0).getDate();

    // const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays) {
        return depdays.totaldays;
    }

    return totalDaysInMonth;
};

// get total working days from dep month set
const getTotalMonthDaysForEmpUser = (rowdoj, rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    if (!rowdoj) {
        return "";
    }

    const [year, month, day] = rowdoj.split('-').map(Number);
    const joiningDate = new Date(year, month - 1, day);

    let totalDays = 0;

    // const depdays = depMonthSet && depMonthSet?.filter((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.filter((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays && depdays.length > 0) {
        depdays.forEach((dep) => {
            const fromDate = new Date(dep.fromdate);
            const toDate = new Date(dep.todate);
            if (joiningDate < fromDate) {
                // If the joining date is before the department's fromdate
                // const daysToFromdate = Math.ceil((fromDate - joiningDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the starting day
                // const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
                // totalDays += Math.min(daysToFromdate, daysInDepartment);
                const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment + (dep.todate === rowdoj ? 0 : 1);

            } else {
                // If the joining date is after the department's fromdate
                // totalDays += Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                const daysInDepartment = Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment + (dep.todate === rowdoj ? 0 : 0);
            }
        });
    } else {
        // Logic to handle when no department data is found for the current month
        // Calculate total days based on the current month's start and end dates
        const startDateOfMonth = new Date(isyear, ismonth - 1, 1);
        const endDateOfMonth = new Date(isyear, ismonth, 0);
        if (joiningDate < startDateOfMonth) {
            // If the joining date is before the department's fromdate
            // const daysToFromdate = Math.ceil((startDateOfMonth - joiningDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the starting day
            // const daysInDepartment = Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
            // totalDays += Math.min(daysToFromdate, daysInDepartment);
            const daysInDepartment = Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
            totalDays += daysInDepartment + (endDateOfMonth === joiningDate ? 0 : 1);
        }
        else {
            // totalDays += Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
            const daysInDepartment = Math.ceil((endDateOfMonth - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
            totalDays += daysInDepartment + (endDateOfMonth === joiningDate ? 0 : 1);
        }
    }

    return Math.max(0, totalDays); // Ensure totalDays is not negative
};

// get till date count based on the dep month and joining date till current date of enddate
const getTotalMonthsCurrentDateCountUser = (rowdoj, rowdepartment, depMonthSet, ismonth, isyear) => {
    if (!rowdoj) {
        return "";
    }

    const [year, month, day] = rowdoj?.split('-').map(Number);
    const joiningDate = new Date(year, month - 1, day);
    const currentDate = new Date(isyear, ismonth - 1);

    let totalDays = 0;
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    // const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);

    const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays && depdays.length > 0) {
        depdays.forEach((dep) => {

            const fromDate = new Date(dep.fromdate);
            const toDate = new Date(dep.todate);

            // Adjust the time to midnight for joiningDate and toDate
            joiningDate.setHours(0, 0, 0, 0);
            toDate.setHours(0, 0, 0, 0);
            fromDate.setHours(0, 0, 0, 0);

            if (joiningDate < fromDate) {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;

                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + 1;
                }
            }
            else {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;
                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                    const daysInDepartment = Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + (toDate === joiningDate ? 0 : 1);
                }
            }
        });
    } else {
        // Calculate the start date of the month based on the selected month
        const monthfromDate = new Date(isyear, ismonth - 1, 1);
        const monthEndDate = new Date(monthfromDate);
        monthEndDate.setMonth(monthEndDate.getMonth() + 1);
        monthEndDate.setDate(monthEndDate.getDate() - 1);

        if (joiningDate < monthfromDate) {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((currentDateAttStatus - monthfromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((monthEndDate - monthfromDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        } else {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                const daysInDepartment = Math.ceil((monthEndDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        }
    }

    // Check if totalDays is negative and return 0 in that case
    return totalDays < 0 ? 0 : totalDays;
};

const getTotalShiftHoursUser = (rowuserid, userDates, attendance) => {
    let totalShiftCount = 0;

    const totalShiftDays = attendance?.filter((d) => d.userid === rowuserid && d.status === true);
    if (totalShiftDays) {
        // Maintain a set to keep track of unique dates
        const countedDates = new Set();

        userDates && userDates?.forEach((date) => {
            totalShiftDays.find((att) => {
                if (att.date === moment(date.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY") && !countedDates.has(att.date)) {
                    // If the date matches and it's not already counted, increment totalShiftCount
                    totalShiftCount++;
                    countedDates.add(att.date); // Add the date to the set to mark it as counted
                }
            });
        });
    }

    return totalShiftCount;
};

//attendance checklist
const checkAttendanceStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {
    const attendanceRecord = attendance?.find(
        (d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode
    );

    // Check if attendanceRecord exists and its attendancestatus is not undefined
    if (attendanceRecord && attendanceRecord.attendancestatus !== undefined) {
        return attendanceRecord.attendancestatus;
    }
    // Return a default value if attendanceRecord or attendancestatus is not available
    return "";
};

//attendance weekoff present
const checkWeekOffPresentStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {
    const attendanceRecord = attendance?.find(
        (d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode && d.weekoffpresentstatus === true
    );

    // Check if attendanceRecord exists and its attendancestatus is not undefined
    if (attendanceRecord && attendanceRecord.weekoffpresentstatus !== undefined) {
        return attendanceRecord.weekoffpresentstatus;
    }
    // Return a default value if attendanceRecord or attendancestatus is not available
    return "";
};

exports.getAllUserClockinAndClockoutStatus = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates, } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        $or: [
            { reasondate: { $exists: false } },
            { reasondate: "" },
            { reasondate: { $gte: req.body.fromdate } }
        ]
    };

    try {
        const [users, depMonthSet, controlcriteria, shift, attendance, holidays, leavetype] = await Promise.all([
            User.find(query
                , {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    // shift: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;

                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusFilter = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        // company: { $in: company },
        // branch: { $in: branch },
        // unit: { $in: unit },
        // $or: [
        //     {
        //         departmentlog: {
        //             $elemMatch: {
        //                 department: { $in: department }
        //             }
        //         }
        //     },
        //     { companyname: { $in: employee } },
        // ],
        companyname: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        // $or: [
        //     {
        //         $and: [
        //             { reasondate: { $exists: true } },
        //             {
        //                 $or: [
        //                     { reasondate: "" },
        //                     { reasondate: { $gte: req.body.fromdate } }
        //                 ]
        //             }
        //         ]
        //     },
        //     { reasondate: { $exists: false } }
        // ]
    }

    try {
        const [users, controlcriteria, depMonthSets, shift, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    // shift: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const findShiftTiming = (shiftName) => {
                const foundShift = shift?.find((d) => d.name === shiftName);
                return foundShift
                    ? `${foundShift.fromhour}:${foundShift.frommin}${foundShift.fromtime}to${foundShift.tohour}:${foundShift.tomin}${foundShift.totime} `
                    : '';
            };

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusForMontLopCalFilter = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluserbefore = [];
    let finaluser = [];
    //const { ismonth, isyear, company, branch, unit, department, employee } = req.body;
    const { ismonth, isyear, employee } = req.body;

    try {
        const [users, depMonthSets, controlcriteria, shift, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    //company: { $in: company },
                    //branch: { $in: branch },
                    //unit: { $in: unit },
                    //$or: [
                    //    {
                    //        departmentlog: {
                    //            $elemMatch: {
                    //                department: { $in: department }
                    //            }
                    //        }
                    //    },
                    //    { companyname: { $in: employee } },
                    //],
                    companyname: { $in: employee },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                // shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);

        const [attendances, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 })

        ])
        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSets?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSets?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            //item.shiftallot?.map(allot => {
            //    resultshiftallot.push({ ...allot })
            //})

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    // return item.logcreation === "user" || item.logcreation === "shift";
                    return item;
                });

                const depMonthSet = depMonthSets?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
                const attendance = attendances.filter(d => {
                    const [userday, usermonth, useryear] = date.formattedDate?.split('/');
                    const [attday, attmonth, attyear] = d.date?.split('-');
                    const userDate = `${useryear}-${usermonth}-${userday}`;
                    const datevalue = `${attyear}-${attmonth}-${attday}`;
                    return (
                        d.username === item.username && new Date(datevalue) >= new Date(userDate) && new Date(datevalue) <= new Date(userDate)
                    )
                }
                )

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

/// get usershift clockin and clockout status individual
exports.getAllUserClockinAndClockoutStatusIndividual = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSet, shift, attendance, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    // company: req.body.company,
                    // branch: req.body.branch,
                    // unit: req.body.unit,
                    // department: req.body.department,
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    $or: [
                        { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                        { reasondate: "" },
                        { reasondate: { $gte: req.body.fromdate } }
                    ]
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                // shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

/// get usershift clockin and clockout status individual
exports.getAllUserClockinAndClockoutStatusIndividual = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSet, shift, attendance, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    // company: req.body.company,
                    // branch: req.body.branch,
                    // unit: req.body.unit,
                    // department: req.body.department,
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    $or: [
                        { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                        { reasondate: "" },
                        { reasondate: { $gte: req.body.fromdate } }
                    ]
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                // shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusIndividualFilter = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSets, shift, attendances, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    //company: { $in: company },
                    //branch: { $in: branch },
                    //unit: { $in: unit },
                    //$or: [
                    //    {
                    //        departmentlog: {
                    //            $elemMatch: {
                    //                department: { $in: department }
                    //            }
                    //        }
                    //    },
                    //    { companyname: { $in: employee } },
                    //],
                    companyname: { $in: employee },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    //  $or: [
                    //     { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                    //    { reasondate: "" },
                    //    { reasondate: { $gte: req.body.fromdate } } 
                    //  ]
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
                attendancemode: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));
            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    attendancemode: item?._doc?.attendancemode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusFilterDateWise = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let leavetype;
    let permission;
    let finaluser = [];
    //const { userDates, company, branch, unit, team, department, employee } = req.body;
    const { userDates, employee } = req.body;
    const formattedUserDates = userDates.map((data) =>
        moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY")
    );

    try {

        let query = {
            //company: { $in: company },
            //branch: { $in: branch },
            //unit: { $in: unit },
            companyname: { $in: employee },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        //// If team is provided, include the team in the condition
        //if (team && team.length > 0) {
        //    query.$and = [
        //        { team: { $in: team } },
        //        {
        //            $or: [
        //                {
        //                    departmentlog: {
        //                        $elemMatch: {
        //                            department: { $in: department }
        //                        }
        //                    }
        //                },
        //                { companyname: { $in: employee } }
        //            ]
        //        }
        //    ];
        //} else {
        //    // If team is not provided, just use department or employee condition
        //    query.$or = [
        //        {
        //            departmentlog: {
        //                $elemMatch: {
        //                    department: { $in: department }
        //                }
        //            }
        //        },
        //        { companyname: { $in: employee } }
        //    ];
        //}

        const [users, controlcriteria, depMonthSets, shift, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    dot: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    // shift: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item?._doc?.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    attendancestatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
}
);


exports.getAllUserClockinAndClockoutStatusLeave = catchAsyncErrors(async (req, res, next) => {

    let finaluser = [];

    const { userDates } = req.body;

    try {
        const [users, depMonthSet, shift] = await Promise.all([
            User.find(
                {
                    $or: [
                        { empcode: req.body.empcode },
                        { companyname: req.body.companyname }
                    ],

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 })
        ])

        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet),
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusLogin = catchAsyncErrors(async (req, res, next) => {

    let finaluser = [];

    const { userDates } = req.body;

    try {
        const [users, depMonthSet, shift] = await Promise.all([
            User.find(
                {
                    companyname: req.body.companyname,
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 })
        ])
        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusMyIndividual = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let permission;
    let finaluser = [];
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSet, shift, attendance, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    companyname: req.body.username,
                    empcode: req.body.empcode,
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusIndividualHierarchyFilter =
    catchAsyncErrors(async (req, res, next) => {
        let result,
            hierarchy,
            resultAccessFilter,
            secondaryhierarchyfinal,
            tertiaryhierarchyfinal,
            primaryhierarchyfinal,
            hierarchyfilter,
            filteredoverall,
            reportingtobaseduser,
            primaryhierarchy,
            hierarchyfilter1,
            secondaryhierarchy,
            hierarchyfilter2,
            tertiaryhierarchy,
            primaryhierarchyall,
            secondaryhierarchyall,
            tertiaryhierarchyall,
            userbranch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames,
            hierarchyFinal,
            hierarchyDefault;
        let allLeaveStatus;
        let resultshiftallot = [];
        let graceTime;
        let clockOutHours;
        let lateclockincount;
        let earlyclockoutcount;
        let onclockout;
        let earlyclockin;
        let earlyclockout;
        let lateclockin;
        let afterlateclockin;
        let beforeearlyclockout;
        let leavetype;
        let permission;
        let finaluser = [];
        const { userDates, company, branch, listpageaccessmode } = req.body;

        const formattedUserDates = userDates.map((data) =>
            moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY")
        );




        try {
            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)






            const [
                users,
                controlcriteria,
                depMonthSet,
                shift,
                attendance,
                holidays,
                leavetype,
            ] = await Promise.all([
                User.find(
                    {
                        enquirystatus: {
                            $nin: ["Enquiry Purpose"],
                        },
                        resonablestatus: {
                            $nin: [
                                "Not Joined",
                                "Postponed",
                                "Rejected",
                                "Closed",
                                "Releave Employee",
                                "Absconded",
                                "Hold",
                                "Terminate",
                            ],
                        },
                        ...(listpageaccessmode === "Reporting to Based"
                            ? { reportingto: req.body.username }
                            : {}),
                    },
                    {
                        company: 1,
                        branch: 1,
                        unit: 1,
                        team: 1,
                        department: 1,
                        doj: 1,
                        dot: 1,
                        empcode: 1,
                        companyname: 1,
                        team: 1,
                        floor: 1,
                        username: 1,
                        designation: 1,
                        weekoff: 1,
                        shiftallot: 1,
                        shifttiming: 1,
                        boardingLog: 1,
                        attendancemode: 1,
                        role: 1,
                        _id: 1,
                        reasondate: 1,
                        departmentlog: 1,
                        attendancemode: 1,
                    }
                ),

                ControlCriteria.find(),
                DepartmentMonth.find(
                    {},
                    {
                        department: 1,
                        year: 1,
                        month: 1,
                        monthname: 1,
                        fromdate: 1,
                        todate: 1,
                        totaldays: 1,
                    }
                ),
                Shift.find(
                    {},
                    {
                        name: 1,
                        fromhour: 1,
                        tohour: 1,
                        frommin: 1,
                        tomin: 1,
                        fromtime: 1,
                        totime: 1,
                    }
                ),
                Attendance.find({
                    date: { $in: formattedUserDates },
                }),
                Holiday.find(
                    {},
                    {
                        date: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                        employee: 1,
                        noofdays: 1,
                    }
                ),
                Leavetype.find({}, { leavetype: 1, code: 1 }),
            ]);
            const userCds = users.map((user) => user.companyname);
            allLeaveStatus = await ApplyLeave.find({
                employeename: { $in: userCds },
            });
            permission = await Permission.find(
                { employeename: { $in: userCds } },
                {
                    employeeid: 1,
                    date: 1,
                    status: 1,
                    applytype: 1,
                    compensationstatus: 1,
                    compensationapplytype: 1,
                    requesthours: 1,
                }
            );

            //myhierarchy dropdown
            if (
                (req.body.hierachy === "My Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchy = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: req.body.sector,
                });
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDef.length > 0
                            ? [].concat(...answerDef)
                            : []
                        : hierarchy.length > 0
                            ? [].concat(...hierarchy.map((item) => item.employeename))
                            : [];
                hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

                hierarchyfilter = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Primary",
                });
                primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0])
                    ? hierarchyfilter.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter1 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Secondary",
                });
                secondaryhierarchy = hierarchyfilter1.map(
                    (item) => item.employeename[0]
                )
                    ? hierarchyfilter1.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter2 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Tertiary",
                });
                tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0])
                    ? hierarchyfilter2.map((item) => item.employeename[0])
                    : [];

                resulted = users
                    .map((userObj) => {
                        const matchingHierarchy = hierarchyDefault.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            control: matchingHierarchy ? matchingHierarchy.control : "",
                        };
                    })
                    .filter((data) => hierarchyMap.includes(data.companyname));
            }

            if (
                (req.body.hierachy === "All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault
                    .map((data) => data.employeename)
                    .flat();

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    answerDef,
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                resultedTeam = users
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            //my + all hierarchy list dropdown

            if (
                (req.body.hierachy === "My + All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                filteredoverall = users
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            if (listpageaccessmode === "Reporting to Based") {
                reportingtobaseduser = users.map((userObj) => {
                    return {
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: "",
                        control: "",
                    };
                });
            }

            let resultAccessFiltered =
                req.body.hierachy === "My Hierarchy List" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resulted
                    : req.body.hierachy === "All Hierarchy List" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? resultedTeam
                        : req.body.hierachy === "My + All Hierarchy List" &&
                            (listpageaccessmode === "Hierarchy Based" ||
                                listpageaccessmode === "Overall")
                            ? filteredoverall
                            : reportingtobaseduser;


            resultAccessFilter = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];


            // graceTime = controlcriteria[0].gracetime;
            clockOutHours = controlcriteria[0].clockout;
            lateclockincount = controlcriteria[0].lateclockincount;
            earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
            onclockout = controlcriteria[0].onclockout;
            earlyclockin = controlcriteria[0].earlyclockin;
            lateclockin = controlcriteria[0].lateclockin;
            earlyclockout = controlcriteria[0].earlyclockout;
            afterlateclockin = controlcriteria[0].afterlateclockin;
            beforeearlyclockout = controlcriteria[0].afterlateclockin;

            finaluser = users?.flatMap((item, index) => {
                let isEmployeeGrace =
                    controlcriteria[0].todos &&
                    controlcriteria[0].todos.find(
                        (d) =>
                            d.company === item.company &&
                            d.branch === item.branch &&
                            d.unit === item.unit &&
                            d.team === item.team &&
                            d.employeename === item.companyname
                    );

                if (isEmployeeGrace) {
                    graceTime = isEmployeeGrace.employeegracetime;
                } else {
                    graceTime = controlcriteria[0].gracetime;
                }

                item.shiftallot?.map((allot) => {
                    resultshiftallot.push({ ...allot });
                });

                const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(
                    (val) =>
                        val &&
                        val?._doc?.empcode === item?._doc?.empcode &&
                        val?._doc?.adjstatus === "Approved"
                );

                // Filter out the dates that have matching 'Shift Adjustment' todates
                let removedUserDates = userDates?.filter((date) => {
                    // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                    const matchingShiftAdjustmentToDate =
                        filteredMatchingDoubleShiftItem.find(
                            (item) =>
                                item &&
                                item?._doc?.todate === date.formattedDate &&
                                item?._doc?.adjustmenttype === "Shift Adjustment"
                        );

                    // If there is no matching 'Shift Adjustment', keep the date
                    return !matchingShiftAdjustmentToDate;
                });

                // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
                let uniqueEntries = new Set();

                // Iterate over removedUserDates and add unique entries to the Set
                removedUserDates?.forEach((date) => {
                    uniqueEntries.add(
                        JSON.stringify({
                            formattedDate: date.formattedDate,
                            dayName: date.dayName,
                            dayCount: date.dayCount,
                            shiftMode: "Main Shift",
                            weekNumberInMonth: date.weekNumberInMonth,
                        })
                    );
                });

                // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
                filteredMatchingDoubleShiftItem.forEach((item) => {
                    const [day, month, year] = item._doc.adjdate?.split("/");
                    let newFormattedDate = new Date(`${year}-${month}-${day}`);

                    if (
                        item._doc.adjustmenttype === "Shift Adjustment" ||
                        item._doc.adjustmenttype === "Add On Shift" ||
                        item._doc.adjustmenttype === "Shift Weekoff Swap"
                    ) {
                        uniqueEntries.add(
                            JSON.stringify({
                                formattedDate: item._doc.adjdate,
                                dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                                dayCount: parseInt(
                                    moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")
                                ),
                                shiftMode: "Second Shift",
                                weekNumberInMonth:
                                    getWeekNumberInMonth(newFormattedDate) === 1
                                        ? `${getWeekNumberInMonth(newFormattedDate)}st Week`
                                        : getWeekNumberInMonth(newFormattedDate) === 2
                                            ? `${getWeekNumberInMonth(newFormattedDate)}nd Week`
                                            : getWeekNumberInMonth(newFormattedDate) === 3
                                                ? `${getWeekNumberInMonth(newFormattedDate)}rd Week`
                                                : getWeekNumberInMonth(newFormattedDate) > 3
                                                    ? `${getWeekNumberInMonth(newFormattedDate)}th Week`
                                                    : "",
                            })
                        );
                    }
                });

                // Convert Set back to an array of objects
                let createdUserDatesUnique = Array.from(uniqueEntries)?.map((entry) =>
                    JSON.parse(entry)
                );

                function sortUserDates(dates) {
                    return dates.sort((a, b) => {
                        if (a.formattedDate === b.formattedDate) {
                            // If dates are the same, sort by shift mode
                            if (a.shiftMode < b.shiftMode) return -1;
                            if (a.shiftMode > b.shiftMode) return 1;
                            return 0;
                        } else {
                            // Otherwise, sort by date
                            const dateA = new Date(
                                a.formattedDate.split("/").reverse().join("/")
                            );
                            const dateB = new Date(
                                b.formattedDate.split("/").reverse().join("/")
                            );
                            return dateA - dateB;
                        }
                    });
                }

                // Sort the array
                const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
                const createdUserDates = sortedCreatedUserDates?.filter((d) => {
                    const filterData = userDates.some(
                        (val) => val.formattedDate === d.formattedDate
                    );
                    if (filterData) {
                        return d;
                    }
                });

                // Map each user date to a row
                const userRows = createdUserDates?.map((date) => {
                    let filteredRowData = resultshiftallot?.filter(
                        (val) => val?._doc?.empcode == item?._doc?.empcode
                    );
                    const matchingItem = filteredRowData?.find(
                        (item) => item && item?._doc?.adjdate == date.formattedDate
                    );
                    const matchingItemAllot = filteredRowData?.find(
                        (item) => item && formatDate(item?._doc?.date) == date.formattedDate
                    );
                    const matchingDoubleShiftItem = filteredRowData.find(
                        (item) => item && item?._doc?.todate === date.formattedDate
                    );
                    const filterBoardingLog =
                        item?._doc?.boardingLog &&
                        item?._doc?.boardingLog?.filter((item) => {
                            return (
                                item.logcreation === "user" || item.logcreation === "shift"
                            );
                            // return item;
                        });

                    // Remove duplicate entries with the most recent entry
                    const uniqueEntriesDep = {};
                    item?._doc?.departmentlog?.forEach((entry) => {
                        const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                        const key = entry.startdate;
                        if (!(key in uniqueEntriesDep)) {
                            uniqueEntriesDep[key] = entry;
                        }
                    });

                    const uniqueDepLog = Object.values(uniqueEntriesDep);
                    const [columnDay, columnMonth, columnYear] =
                        date.formattedDate?.split("/");
                    const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                    // Find the relevant log entry for the given date
                    const relevantDepLogEntry = uniqueDepLog
                        .filter((log) => log.startdate <= finalDate)
                        .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                    // Check if the dayName is Sunday or Monday
                    // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                    const isWeekOff =
                        getWeekOffDay(
                            date,
                            filterBoardingLog,
                            relevantDepLogEntry && relevantDepLogEntry?.department,
                            depMonthSet
                        ) === "Week Off"
                            ? true
                            : false;
                    const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                    const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                    const row = {
                        id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode
                            }`,
                        userid: item?._doc?._id.toString(),
                        company: item?._doc?.company,
                        branch: item?._doc?.branch,
                        unit: item?._doc?.unit,
                        team: item?._doc?.team,
                        department: relevantDepLogEntry && relevantDepLogEntry?.department,
                        username: item?._doc?.companyname,
                        empcode: item?._doc?.empcode,
                        weekoff: item?._doc?.weekoff,
                        boardingLog: item?._doc?.boardingLog,
                        shiftallot: item?._doc?.shiftallot,
                        doj: item?._doc?.doj,
                        shift: getShiftForDate(
                            date,
                            matchingItem,
                            matchingItemAllot,
                            isWeekOffWithAdjustment,
                            isWeekOffWithManual,
                            filterBoardingLog,
                            isWeekOff,
                            matchingDoubleShiftItem,
                            relevantDepLogEntry && relevantDepLogEntry?.department,
                            depMonthSet
                        ),
                        date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                        role: item?._doc?.role,
                        rowformattedDate: date.formattedDate,
                        dayName: date.dayName,
                        shiftMode: date.shiftMode,
                        rowusername: item?._doc?.username,
                        reasondate: item?._doc?.reasondate,
                        attendancemode: item?._doc?.attendancemode,
                        clockin: checkGetClockInTime(
                            attendance,
                            item?._doc?._id.toString(),
                            date.formattedDate,
                            getShiftForDate(
                                date,
                                matchingItem,
                                matchingItemAllot,
                                isWeekOffWithAdjustment,
                                isWeekOffWithManual,
                                filterBoardingLog,
                                isWeekOff,
                                matchingDoubleShiftItem,
                                relevantDepLogEntry && relevantDepLogEntry?.department,
                                depMonthSet
                            ),
                            date.shiftMode
                        ),
                        clockout: checkGetClockOutTime(
                            attendance,
                            item?._doc?._id.toString(),
                            date.formattedDate,
                            getShiftForDate(
                                date,
                                matchingItem,
                                matchingItemAllot,
                                isWeekOffWithAdjustment,
                                isWeekOffWithManual,
                                filterBoardingLog,
                                isWeekOff,
                                matchingDoubleShiftItem,
                                relevantDepLogEntry && relevantDepLogEntry?.department,
                                depMonthSet
                            ),
                            date.shiftMode
                        ),
                        clockinstatus: checkClockInStatus(
                            checkGetClockInTime(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                getShiftForDate(
                                    date,
                                    matchingItem,
                                    matchingItemAllot,
                                    isWeekOffWithAdjustment,
                                    isWeekOffWithManual,
                                    filterBoardingLog,
                                    isWeekOff,
                                    matchingDoubleShiftItem,
                                    relevantDepLogEntry && relevantDepLogEntry?.department,
                                    depMonthSet
                                ),
                                date.shiftMode
                            ),
                            getShiftForDate(
                                date,
                                matchingItem,
                                matchingItemAllot,
                                isWeekOffWithAdjustment,
                                isWeekOffWithManual,
                                filterBoardingLog,
                                isWeekOff,
                                matchingDoubleShiftItem,
                                relevantDepLogEntry && relevantDepLogEntry?.department,
                                depMonthSet
                            ),
                            graceTime,
                            allLeaveStatus,
                            holidays,
                            checkGetClockInDate(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                date.shiftMode
                            ),
                            item?._doc.branch,
                            item?._doc?.empcode,
                            item?._doc.company,
                            date.formattedDate,
                            item?._doc.unit,
                            item?._doc.team,
                            item?._doc.companyname,
                            earlyclockin,
                            lateclockin,
                            afterlateclockin,
                            leavetype,
                            permission,
                            checkGetClockOutTime(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                getShiftForDate(
                                    date,
                                    matchingItem,
                                    matchingItemAllot,
                                    isWeekOffWithAdjustment,
                                    isWeekOffWithManual,
                                    filterBoardingLog,
                                    isWeekOff,
                                    matchingDoubleShiftItem,
                                    relevantDepLogEntry && relevantDepLogEntry.departmentlog,
                                    depMonthSet
                                ),
                                date.shiftMode
                            ),
                            date.shiftMode,
                            checkWeekOffPresentStatus(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                date.shiftMode
                            )
                        ),
                        clockoutstatus: checkClockOutStatus(
                            checkGetClockOutTime(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                getShiftForDate(
                                    date,
                                    matchingItem,
                                    matchingItemAllot,
                                    isWeekOffWithAdjustment,
                                    isWeekOffWithManual,
                                    filterBoardingLog,
                                    isWeekOff,
                                    matchingDoubleShiftItem,
                                    relevantDepLogEntry && relevantDepLogEntry?.department,
                                    depMonthSet
                                ),
                                date.shiftMode
                            ),
                            checkGetClockInTime(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                getShiftForDate(
                                    date,
                                    matchingItem,
                                    matchingItemAllot,
                                    isWeekOffWithAdjustment,
                                    isWeekOffWithManual,
                                    filterBoardingLog,
                                    isWeekOff,
                                    matchingDoubleShiftItem,
                                    relevantDepLogEntry && relevantDepLogEntry?.department,
                                    depMonthSet
                                ),
                                date.shiftMode
                            ),
                            getShiftForDate(
                                date,
                                matchingItem,
                                matchingItemAllot,
                                isWeekOffWithAdjustment,
                                isWeekOffWithManual,
                                filterBoardingLog,
                                isWeekOff,
                                matchingDoubleShiftItem,
                                relevantDepLogEntry && relevantDepLogEntry?.department,
                                depMonthSet
                            ),
                            clockOutHours,
                            checkGetClockInDate(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                date.shiftMode
                            ),
                            allLeaveStatus,
                            holidays,
                            item?._doc.branch,
                            item?._doc?.empcode,
                            item?._doc.company,
                            date.formattedDate,
                            item?._doc.unit,
                            item?._doc.team,
                            item?._doc.companyname,
                            onclockout,
                            earlyclockout,
                            beforeearlyclockout,
                            checkGetClockInAutoStatus(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                date.shiftMode
                            ),
                            leavetype,
                            permission,
                            date.shiftMode,
                            checkWeekOffPresentStatus(
                                attendance,
                                item?._doc?._id.toString(),
                                date.formattedDate,
                                date.shiftMode
                            )
                        ),
                        attendanceautostatus: checkAttendanceStatus(
                            attendance,
                            item?._doc?._id.toString(),
                            date.formattedDate,
                            date.shiftMode
                        ),
                        lateclockincount: lateclockincount,
                        earlyclockoutcount: earlyclockoutcount,
                        ipaddress: getUserIp(
                            attendance,
                            item?._doc?._id.toString(),
                            date.formattedDate,
                            date.shiftMode
                        ),
                        weekoffpresentstatus: checkWeekOffPresentStatus(
                            attendance,
                            item?._doc?._id.toString(),
                            date.formattedDate,
                            date.shiftMode
                        ),
                    };

                    return row;
                });
                return userRows;
            });
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }

        if (!finaluser) {
            return next(new ErrorHandler("Users not found", 400));
        }

        return res.status(200).json({ finaluser, resultAccessFilter });
    });

exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterMinPointsNew = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let shift;
    let attendance;
    let allLeaveStatus;
    let holidays;
    let resultshiftallot = [];
    let depMonthSet;
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let leavetype;
    let permission;
    let weekOffDates = [];
    let finaluser = [];
    const { ismonth, isyear } = req.body;

    try {
        users = await User.find(
            {
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                departmentlog: 1,
            }
        );
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 20);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 10);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);

        const originalDateObjecttodate = new Date(todate);

        // const maxDateDocument = await Attendance.aggregate([
        //   {
        //     $match: {
        //       date: { $exists: true, $ne: "", $regex: /^\d{2}-\d{2}-\d{4}$/ },
        //     },
        //   },
        //   {
        //     $project: {
        //       date: {
        //         $dateFromString: {
        //           dateString: "$date",
        //           format: "%d-%m-%Y",
        //         },
        //       },
        //     },
        //   },
        //   {
        //     $sort: { date: -1 },
        //   },
        //   {
        //     $limit: 1,
        //   },
        // ]);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;

        attendance = await Attendance.find(
            {
                $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
            },
            { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1 }
        );
        depMonthSet = await DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        controlcriteria = await ControlCriteria.find();
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //   // If matched, push the range from 'fromdate' to 'todate'
                        //   const startDate = new Date(firstDate);
                        //   // Loop through the dates in the range
                        //   while (startDate <= currentDateAttStatus) {
                        //     userDates.push({
                        //       formattedDate: format(startDate, "dd/MM/yyyy"),
                        //       dayName: format(startDate, "EEEE"),
                        //       dayCount: startDate.getDate(),
                        //     });
                        //     startDate.setDate(startDate.getDate() + 1);
                        //   }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(firstDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //   // If matched, push the range from 'fromdate' to 'todate'
                        //   const startDate = new Date(joiningDate);
                        //   // Loop through the dates in the range
                        //   while (startDate <= currentDateAttStatus) {
                        //     userDates.push({
                        //       formattedDate: format(startDate, "dd/MM/yyyy"),
                        //       dayName: format(startDate, "EEEE"),
                        //       dayCount: startDate.getDate(),
                        //     });
                        //     startDate.setDate(startDate.getDate() + 1);
                        //   }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    }
                });
            } else {
                const [year2, month2, day2] = item?._doc?.doj?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //   let currentDate1 = new Date(startDate);

                    //   while (currentDate1 <= endDate) {
                    //     userDates.push({
                    //       formattedDate: format(currentDate1, "dd/MM/yyyy"),
                    //       dayName: format(currentDate1, "EEEE"),
                    //       dayCount: currentDate1.getDate(),
                    //     });
                    //     currentDate1.setDate(currentDate1.getDate() + 1);
                    //   }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        userDates.push({
                            formattedDate: format(currentDate1, "dd/MM/yyyy"),
                            dayName: format(currentDate1, "EEEE"),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                    // }
                } else {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //   // If matched, push the range from 'fromdate' to 'todate'
                    //   const startDate = new Date(joiningDate);
                    //   // Loop through the dates in the range
                    //   while (startDate <= currentDateAttStatus) {
                    //     userDates.push({
                    //       formattedDate: format(startDate, "dd/MM/yyyy"),
                    //       dayName: format(startDate, "EEEE"),
                    //       dayCount: startDate.getDate(),
                    //     });
                    //     startDate.setDate(startDate.getDate() + 1);
                    //   }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        userDates.push({
                            formattedDate: format(currentDate1, "dd/MM/yyyy"),
                            dayName: format(currentDate1, "EEEE"),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                }
                // }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    // id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    // userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    // attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    // lateclockincount: lateclockincount,
                    // earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    // empshiftdays: getTotalMonthDaysForEmpUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    // totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    // totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

//remote users
//remote users
exports.getAllRemoteuserFilter = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers;
        const {
            companyname,
            branchname,
            unitname,
            teamname,
            employeename,
            departmentname,
        } = req.body;

        const filter = {
            enquirystatus: { $nin: ["Enquiry Purpose"] },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            ...(companyname && Array.isArray(companyname) && companyname.length > 0
                ? { company: { $in: companyname } }
                : {}),
            ...(branchname && Array.isArray(branchname) && branchname.length > 0
                ? { branch: { $in: branchname } }
                : {}),
            ...(unitname && Array.isArray(unitname) && unitname.length > 0
                ? { unit: { $in: unitname } }
                : {}),
            ...(teamname && Array.isArray(teamname) && teamname.length > 0
                ? { team: { $in: teamname } }
                : {}),
            ...(employeename && Array.isArray(employeename) && employeename.length > 0
                ? { companyname: { $in: employeename } }
                : {}),
            ...(departmentname &&
                Array.isArray(departmentname) &&
                departmentname.length > 0
                ? { department: { $in: departmentname } }
                : {}),
        };

        filteredUsers = await User.find(filter, {
            company: 1,
            workmode: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            workstationofficestatus: 1,
            addremoteworkmode: 1,
            workmode: 1,
            workstationinput: 1,
            username: 1,
        });

        return res.status(200).json({ filterallremoteuser: filteredUsers });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});



exports.updateUsersShiftLogLastObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { boardinglogsarray } = req.body;

        // Construct an array of update operations for each item in changecheckedlabel
        const updateOperations = boardinglogsarray.map((changedShifts) => ({
            updateOne: {
                filter: {
                    "boardingLog._id": changedShifts._id,
                },
                update: {
                    $set: {
                        "boardingLog.$.startdate": changedShifts.startdate,
                    },
                },
            },
        }));

        // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
        for (const operation of updateOperations) {
            const { filter, update } = operation.updateOne;

            const shiftallot = await User.findOne(filter);

            if (shiftallot) {
                const product = shiftallot.shiftallot.id(filter["boardingLog._id"]);
                await User.updateOne(filter, update);
            }
        }

        return res
            .status(200)
            .json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
}
);


//get all users data
exports.getUsersAllData = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"]
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1, branch: 1, unit: 1, team: 1, companyname: 1, empcode: 1, department: 1, designation: 1, _id: 1, resonablestatus: 1, assignExpLog: 1, doj: 1, processlog: 1, floor: 1, area: 1, workstation: 1, workstationinput: 1, username: 1, commonid: 1,

                username: 1, designationlog: 1, process: 1, workmode: 1

                // workstationofficestatus: 1, addremoteworkmode:1,workmode: 1, remoteworkmodestatus: 1, area: 1,employeecount: 1,
                // systemmode: 1, doj: 1,companyname: 1, branch: 1, unit: 1, floor: 1, department: 1, team: 1, designation: 1, 
                // empcode: 1, company: 1, role: 1,resonablestatus: 1, 
                // reasondate: 1, reasonname: 1,lastworkday: 1, empreason: 1, enableworkstation: 1, designationlog: 1, departmentlog: 1, assignExpLog: 1, twofaenabled: 1, 
                // twofatempsecret: 1, twofasecret: 1, process: 1, originalpassword: 1, processlog: 1, processtype: 1, processduration: 1, shifttype: 1,
                // boardingLog: 1, shiftallot: 1, rejoin: 1, reasonablestatusremarks: 1, wordcheck: 1,
                //  remoteworkmodestatus: 1, addremoteworkmode: 1, createdAt: 1
            }

        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ usersstatus });
});

exports.updateUsersShiftLogLastObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { boardinglogsarray } = req.body;

        // Construct an array of update operations for each item in changecheckedlabel
        const updateOperations = boardinglogsarray.map((changedShifts) => ({
            updateOne: {
                filter: {
                    "boardingLog._id": changedShifts._id,
                },
                update: {
                    $set: {
                        "boardingLog.$.startdate": changedShifts.startdate,
                    },
                },
            },
        }));

        // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
        for (const operation of updateOperations) {
            const { filter, update } = operation.updateOne;

            const shiftallot = await User.findOne(filter);

            if (shiftallot) {
                const product = shiftallot.shiftallot.id(filter["boardingLog._id"]);
                await User.updateOne(filter, update);
            }
        }

        return res
            .status(200)
            .json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
}
);


exports.getAllSalaryFixFilter = catchAsyncErrors(async (req, res, next) => {
    let salaryRange, type, process, amountValue, from, to, result, company, branch;
    let matchCriteria = {}
    try {
        salaryRange = req.body.salaryrange;
        type = req.body.type;
        process = req.body.process;
        company = req.body.company;
        branch = req.body.branch;
        amountValue = parseFloat(req.body.amountvalue); // Parsing to float
        from = parseFloat(req.body.fromamount); // Parsing to float
        to = parseFloat(req.body.toamount);


        if (type === "Process Wise") {

            matchCriteria.salarycode = new RegExp("^" + req.body.process)

        } else {

            if (salaryRange === "Less Than") {
                matchCriteria.totalValue = { $lt: parseInt(amountValue) };
            } else if (salaryRange === "Greater Than") {
                matchCriteria.totalValue = { $gt: parseInt(amountValue) };
            }
            else if (salaryRange === "Exact") {
                matchCriteria.totalValue = { $eq: parseInt(amountValue) };
            }

            else if (salaryRange === "Between") {
                matchCriteria.totalValue = { $gte: parseInt(from), $lte: parseInt(to) };
            } // Add more conditions if needed for "Greater than", "Exact", etc.


        }

        matchCriteria.company = company;
        matchCriteria.branch = branch


        result = await Salaryslab.aggregate([
            {
                $addFields: {
                    totalValue: { $sum: ["$basic", "$hra", "$conveyance", "$medicalallowance", "$productionallowance", "$otherallowance"] }
                }
            },
            {
                $match: matchCriteria
            },
            {
                $lookup: {
                    from: "targetpoints",
                    localField: "salarycode",
                    foreignField: "processcode",
                    as: "targetpoints"
                }
            },
            {
                $addFields: {
                    targetPointsValue: { $arrayElemAt: ["$targetpoints.points", 0] }
                }
            },
            {
                $project: {
                    targetPointsValue: 1, // Include other fields you need from the salaryslab collection

                    totalValue: 1,
                    salarycode: 1
                }
            }
        ]);


    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }


    return res.status(200).json({ result });
});



// get All user => /api/users
exports.getAllUsersWithoutStatus = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                unit: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,

                aadhar: 1,
                panno: 1,
                panstatus: 1, panrefno: 1,
                candidateid: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.getAllFilteredUsers = catchAsyncErrors(async (req, res, next) => {
    const {
        companyname,
        branchname,
        unitname,
        teamname,
        employeename,
        departmentname,
    } = req.body;

    const filter = {
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: {
            $nin: [
                "Not Joined",
                "Postponed",
                "Rejected",
                "Closed",
                "Releave Employee",
                "Absconded",
                "Hold",
                "Terminate",
            ],
        },
        ...(companyname && Array.isArray(companyname) && companyname.length > 0
            ? { company: { $in: companyname } }
            : {}),
        ...(branchname && Array.isArray(branchname) && branchname.length > 0
            ? { branch: { $in: branchname } }
            : {}),
        ...(unitname && Array.isArray(unitname) && unitname.length > 0
            ? { unit: { $in: unitname } }
            : {}),
        ...(teamname && Array.isArray(teamname) && teamname.length > 0
            ? { team: { $in: teamname } }
            : {}),
        ...(employeename && Array.isArray(employeename) && employeename.length > 0
            ? { companyname: { $in: employeename } }
            : {}),
        ...(departmentname &&
            Array.isArray(departmentname) &&
            departmentname.length > 0
            ? { department: { $in: departmentname } }
            : {}),
    };


    try {
        const empDocs = await EmployeeDocuments.find(
            {},
            { profileimage: 1, commonid: 1 }
        ).lean();

        const pageSize = 100;
        let page = 0;
        let users;
        let allUsers = [];

        do {
            users = await User.find(filter, {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
            })
                .lean()
                .skip(page * pageSize)
                .limit(pageSize);

            if (!users || users.length === 0) break;

            const mappedUsers = users.map((data) => {
                const foundData = empDocs.find(
                    (item) => item?.commonid?.toString() === data?._id?.toString()
                );
                return {
                    ...data,
                    profileimage: foundData ? foundData.profileimage : "",
                };
            });

            allUsers = [...allUsers, ...mappedUsers];
            page++;
        } while (users.length === pageSize);

        if (allUsers.length === 0) {
            return next(new ErrorHandler("Users not found", 400));
        }

        return res.status(200).json({ count: allUsers.length, users: allUsers });
    } catch (err) {
        return next(
            new ErrorHandler("An error occurred while fetching users", 500)
        );
    }
});

exports.getAllUsersnew = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                company: 1,
                branch: 1, unit: 1, team: 1, empcode: 1, companyname: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllSalaryFixFilterReport = catchAsyncErrors(async (req, res, next) => {
    try {
        const {
            salaryrange,
            type,
            process,
            amountvalue,
            fromamount,
            toamount,
            company,
            branch,
            page,
            team,
            unit,
            pageSize,
            searchTerm
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const fromAmount = parseFloat(fromamount);
        const toAmount = parseFloat(toamount);
        const skip = (page - 1) * pageSize;
        const limit = pageSize;

        // Define the match conditions based on the inputs
        let matchConditions = {
            company: { $in: company },
            branch: { $in: branch },
        };

        let matchConditionsteamunit = {
            team: { $in: team },
            unit: { $in: unit },
        };


        if (type === "Process Wise") {
            matchConditions.processqueue = process;
        }
        let matchConditionsWithSalary = {}
        switch (salaryrange) {
            case "Less Than":
                matchConditionsWithSalary.grosstotal = { $lt: amountValue };
                break;
            case "Greater Than":
                matchConditionsWithSalary.grosstotal = { $gt: amountValue };
                break;
            case "Exact":
                matchConditionsWithSalary.grosstotal = { $eq: amountValue };
                break;
            case "Between":
                matchConditionsWithSalary.grosstotal = { $gte: fromAmount, $lte: toAmount };
                break;
            default: { }
        }
        console.log(matchConditions, page, pageSize, skip, limit, "matchConditions")
        let searchConditions = {}
        if (searchTerm) {
            const searchTermsArray = searchTerm.split(" ");
            const regexTerms = searchTermsArray.map((term) => new RegExp(term, "i"));
            const numericValue = !isNaN(searchTerm) ? Number(searchTerm) : null;
            searchConditions = {
                $and: regexTerms.map((searchRegex) => ({
                    $or: [
                        { grosstotal: numericValue !== null ? numericValue : searchRegex },
                        { salarycode: searchRegex },
                        { targetPointsValue: searchRegex },
                    ],
                })),
            };
            // If the search term is a valid number, add conditions for numeric fields
            // if (numericValue !== null) {
            //     searchConditions.push({
            //         $or: [{ grosstotal: numericValue }],
            //     });
            // }
        }


        console.log(searchConditions, "searchConditions")


        const results = await Salaryslab.aggregate([
            { $match: matchConditions },

            ...(type === "Amount Wise" ? [{ $match: { grosstotal: matchConditionsWithSalary.grosstotal } }] : []),

            {
                $lookup: {
                    from: "targetpoints",
                    let: { company: "$company", branch: "$branch", salarycode: "$salarycode" },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        { $eq: ["$company", "$$company"] },
                                        { $eq: ["$branch", "$$branch"] },
                                        { $eq: ["$processcode", "$$salarycode"] },
                                    ],
                                },
                            },
                        },
                        {
                            $project: {
                                _id: 0,
                                points: 1,
                            },
                        },
                    ],
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: {
                        $ifNull: [{ $arrayElemAt: ["$targetpoints.points", 0] }, 0],
                    },
                },
            },
            // Lookup to fetch matching processteams based on company and branch
            {
                $lookup: {
                    from: "processteams",
                    let: { company: "$company", branch: "$branch", processqueue: "$processqueue" },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        { $eq: ["$company", "$$company"] },
                                        { $eq: ["$branch", "$$branch"] },
                                        { $eq: ["$process", "$$processqueue"] },
                                    ],
                                },
                            },
                        },
                        {
                            $project: {
                                _id: 0, // Exclude _id
                                unit: 1,
                                team: 1,
                            },
                        },
                    ],
                    as: "processteams",
                },
            },

            // Unwind to create multiple rows for each unit and team combination
            { $unwind: "$processteams" },

            // Add unit and team fields from the processteams array
            {
                $addFields: {
                    unit: "$processteams.unit",
                    team: "$processteams.team",
                },
            },

            // Remove the processteams array since we extracted the needed fields
            { $project: { processteams: 0 } },


            { $match: matchConditionsteamunit },
            { $match: searchConditions },


            { $skip: skip },
            { $limit: limit },







            {
                $project: {

                    targetPointsValue: 1,
                    totalValue: "$grosstotal",
                    salarycode: 1,
                    company: 1,
                    branch: 1,
                    unit: 1, // Include unit in output
                    team: 1, // Include team in output
                    processqueue: 1,

                },
            },
        ]);



        // Get the total count without pagination
        const countResult = await Salaryslab.aggregate([
            { $match: matchConditions },

            ...(type === "Amount Wise" ? [{ $match: { grosstotal: matchConditionsWithSalary.grosstotal } }] : []),
            {
                $lookup: {
                    from: "targetpoints",
                    let: { company: "$company", branch: "$branch", salarycode: "$salarycode" },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        { $eq: ["$company", "$$company"] },
                                        { $eq: ["$branch", "$$branch"] },
                                        { $eq: ["$processcode", "$$salarycode"] },
                                    ],
                                },
                            },
                        },
                        {
                            $project: {
                                _id: 0,
                                points: 1,
                            },
                        },
                    ],
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: {
                        $ifNull: [{ $arrayElemAt: ["$targetpoints.points", 0] }, 0],
                    },
                },
            },
            {
                $lookup: {
                    from: "processteams",
                    let: { company: "$company", branch: "$branch", processqueue: "$processqueue" },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        { $eq: ["$company", "$$company"] },
                                        { $eq: ["$branch", "$$branch"] },
                                        { $eq: ["$process", "$$processqueue"] },
                                    ],
                                },
                            },
                        },
                        {
                            $project: {
                                _id: 0,
                                unit: 1,
                                team: 1,
                            },
                        },
                    ],
                    as: "processteams",
                },
            },

            { $unwind: "$processteams" },

            {
                $addFields: {
                    unit: "$processteams.unit",
                    team: "$processteams.team",
                },
            },

            { $match: matchConditionsteamunit },
            { $match: searchConditions },


            { $count: "totalCount" }, // Count total documents
        ]);

        const totalCount = countResult.length > 0 ? countResult[0].totalCount : 0;


        console.log(results.length, totalCount, "ikjkj")

        // Respond with the result
        return res.status(200).json({ results: results, totalCount });
    } catch (err) {
        console.log(err, "error")
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
});


exports.getAllSalaryFixFilterReportold = catchAsyncErrors(async (req, res, next) => {
    try {
        const {
            salaryrange,
            type,
            process,
            amountvalue,
            fromamount,
            toamount,
            company,
            branch,
            batchNumber,
            batchSize,
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const fromAmount = parseFloat(fromamount);
        const toAmount = parseFloat(toamount);
        const skip = (batchNumber - 1) * batchSize;
        const limit = batchSize;

        // Define the match conditions based on the inputs
        let matchConditions = {
            company: { $in: company },
            branch: { $in: branch },
        };

        if (type === "Process Wise") {
            matchConditions.salarycode = new RegExp("^" + process);
        }
        let matchConditionsWithSalary = {}
        switch (salaryrange) {
            case "Less Than":
                matchConditionsWithSalary.grosstotal = { $lt: amountValue };
                break;
            case "Greater Than":
                matchConditionsWithSalary.grosstotal = { $gt: amountValue };
                break;
            case "Exact":
                matchConditionsWithSalary.grosstotal = { $eq: amountValue };
                break;
            case "Between":
                matchConditionsWithSalary.grosstotal = { $gte: fromAmount, $lte: toAmount };
                break;
        }

        // Perform the optimized aggregation query
        const results = await Salaryslab.aggregate([

            { $match: matchConditions },
            ...(type === "Amount Wise" ? [{ $match: { grosstotal: matchConditionsWithSalary.grosstotal } }] : []),

            {
                $lookup: {
                    from: "targetpoints",
                    localField: "salarycode",
                    foreignField: "processcode",
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: { $arrayElemAt: ["$targetpoints.points", 0] },
                },
            },
            {
                $project: {
                    targetPointsValue: 1,
                    totalValue: "$grosstotal",
                    salarycode: 1,
                    company: 1,
                    branch: 1,
                    processqueue: 1,
                },
            },
        ]).exec();

        // Execute the process team query in parallel
        const processTeamData = await ProcessTeam.find(
            {
                company: { $in: company },
                branch: { $in: branch },
                process: { $in: results.map((r) => r.processqueue) },
            },
            { unit: 1, team: 1, company: 1, branch: 1, process: 1 }
        ).lean();

        // Combine the results
        const combinedArray = processTeamData.flatMap((mainItem) =>
            results.map((subItem) => ({
                ...mainItem,
                ...subItem,
                _id: new ObjectId(),
            }))
        );

        // Respond with the result
        return res.status(200).json({ results: combinedArray });
    } catch (err) {
        console.log(err, "err")
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
});

// check duplicate employeename in create
exports.checkduplicateemployeenamecreate = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { firstname, lastname, employeename, dob } = req.body;

            const dobParts = dob.split("-");
            const day = dobParts[2];
            const month = dobParts[1];
            const year = dobParts[0];

            // Generate potential company names
            const potentialCompanyNames = [
                employeename,
                `${employeename}${day}`,
                `${employeename}${day}${month}`,
                `${employeename}${day}${month}${year}`,
            ];

            // Check for duplicates in one go
            let existingUser = await User.findOne(
                {
                    $and: [
                        { firstname: { $regex: new RegExp(firstname, "i") } },
                        { lastname: { $regex: new RegExp(lastname, "i") } },
                        {
                            companyname: {
                                $in: potentialCompanyNames.map((name) => new RegExp(name, "i")),
                            },
                        },
                    ],
                }
                // { firstname: 1, lastname: 1, companyname: 1 }
            );

            let currentCompanyName = employeename;

            if (existingUser) {
                // Try to find the first available name in parallel
                const nameChecks = potentialCompanyNames.map((name) =>
                    User.findOne(
                        {
                            $and: [
                                { firstname: { $regex: new RegExp(firstname, "i") } },
                                { lastname: { $regex: new RegExp(lastname, "i") } },
                                { companyname: { $regex: new RegExp(name, "i") } },
                            ],
                        }
                        // { firstname: 1, lastname: 1, companyname: 1 }
                    )
                );

                const results = await Promise.all(nameChecks);
                for (let i = 0; i < results.length; i++) {
                    if (!results[i]) {
                        currentCompanyName = potentialCompanyNames[i];
                        break;
                    }
                }

                // If still a duplicate, append counter until a unique name is found
                if (results.every((result) => result)) {
                    let counter = 1;
                    while (existingUser) {
                        currentCompanyName = `${employeename}${day}${month}${year}${counter}`;
                        existingUser = await User.findOne(
                            {
                                $and: [
                                    { firstname: { $regex: new RegExp(firstname, "i") } },
                                    { lastname: { $regex: new RegExp(lastname, "i") } },
                                    {
                                        companyname: {
                                            $regex: new RegExp(currentCompanyName, "i"),
                                        },
                                    },
                                ],
                            }
                            // { firstname: 1, lastname: 1, companyname: 1 }
                        );
                        counter++;
                    }
                }

                res.status(200).json({
                    exist: true,
                    uniqueCompanyName: currentCompanyName,
                });
            } else {
                res.status(200).json({
                    exist: false,
                    uniqueCompanyName: employeename,
                });
            }
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }
    }
);


// check duplicate employeename in edit
exports.checkduplicateemployeenameedit = catchAsyncErrors(
    async (req, res, next) => {
        const { firstname, lastname, employeename, id } = req.body;

        const existingUser = await User.findOne({
            $and: [
                { _id: { $ne: id } },
                { firstname: { $regex: new RegExp(firstname, "i") } },
                { lastname: { $regex: new RegExp(lastname, "i") } },
                { companyname: { $regex: new RegExp(employeename, "i") } },
            ],
        });

        if (existingUser) {
            res.status(200).json({ exist: true });
        } else {
            res.status(200).json({ exist: false });
        }
    }
);

exports.updateUserPwdReset = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;

    const { password, originalpassword, resetstatus } = req.body
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    const upuserone = await User.findByIdAndUpdate(id, {
        password: hashPassword,
        originalpassword,
        resetstatus
    });

    if (!upuserone) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({ message: "Updated successfully!" });
});
exports.getAllUserTotalShiftDays = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { ismonth, isyear, pageSize, page,
        // employees
    } = req.body;

    try {
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear
        }
        let [usersAll, depMonthSet, controlcriteria, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // companyname: { $in: employees }

                }, {}
            ).skip((page - 1) * pageSize).limit(pageSize),


            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            // Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const resultDateArray = depMonthSet.reduce((acc, curr) => {
            // Compare and update the earliest fromdate
            if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                acc.fromdate = curr.fromdate;
            }
            // Compare and update the latest todate
            if (new Date(curr.todate) > new Date(acc.todate)) {
                acc.todate = curr.todate;
            }
            return acc;
        }, {
            fromdate: depMonthSet[0].fromdate, // Start with the first fromdate
            todate: depMonthSet[0].todate      // Start with the first todate
        });

        function formatDate(dateString) {
            const [day, month, year] = dateString.split("-");
            return `${year}-${month}-${day}`;
        }

        let attFromDate = (resultDateArray.fromdate)
        let attToDate = (resultDateArray.todate)
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];

        let users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            // if (department.includes(findUserDeprtment)) {
            return {
                ...item._doc, // Use _doc to avoid including Mongoose metadata
                department: findUserDeprtment,
            };

            // }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);
        const [attendance, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, createdAt: { $gte: attFromDate, $lte: attToDate } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 })

        ])

        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;


        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];


            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);


                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find(item => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item.todate === date.formattedDate);
                const filterBoardingLog = item.boardingLog && item.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });
                let attendanceFiltered = attendance.filter(d => d.username === item.username)


                const depMonthSetFiltered = depMonthSet.filter(d => d.department === item.department)
                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: item.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,), item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        clockOutHours, checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
// get All user => /api/allusersemployee
exports.getAllTheUsersEmployee = catchAsyncErrors(async (req, res, next) => {
    let alluseremployee;

    try {
        alluseremployee = await User.find({},
            // {
            //     enquirystatus: {
            //         $nin: ["Enquiry Purpose"],
            //     },
            //     workmode: {
            //         $ne: "Internship",
            //     },
            // resonablestatus: {
            //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            // },
            // },
            {
                status: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                addremoteworkmode: 1,
                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                fathername: 1,
                mothername: 1,
                contactfamily: 1,

                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                doj: 1,
                dot: 1,
                role: 1,
                assignExpLog: 1,
                resonablestatus: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                aadhar: 1,
                panno: 1,

                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankdetails: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                remoteworkmodestatus: 1,
                addremoteworkmode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!alluseremployee) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: alluseremployee.length, alluseremployee });
});

exports.getUserWithStatus = catchAsyncErrors(async (req, res, next) => {
    let finalarray;

    try {
        const {
            pageName,
            company,
            branch,
            unit,
            team,
            department,
            employee,
            profileimage,
        } = req.body;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        // Fetch relevant attendance records for the past 3 days
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },

            // Conditional company filter
            ...(company.length && { company: { $in: company } }),
            // Conditional branch filter
            ...(branch.length && { branch: { $in: branch } }),
            // Conditional unit filter
            ...(unit.length && { unit: { $in: unit } }),
            // Conditional team filter
            ...(team.length && { team: { $in: team } }),
            // Conditional department filter
            ...(department.length && { department: { $in: department } }),
            // Conditional employee filter
            ...(employee.length && { companyname: { $in: employee } }),
        };

        if (pageName === "Employee") {
            filterQuery.workmode = {
                $ne: "Internship",
            };
        } else if (pageName === "Internship") {
            filterQuery.workmode = {
                $eq: "Internship",
            };
        }

        const noticeperiodpipeline = [
            {
                // Sort by empname and then by createdAt in descending order
                $sort: { empname: 1, createdAt: -1 },
            },
            {
                // Group by empname and select the first document per group (most recent)
                $group: {
                    _id: "$empname", // Group by empname
                    mostRecentDocument: { $first: "$$ROOT" }, // Select the most recent document per empname
                },
            },
            {
                // Project the necessary fields from the most recent document
                $replaceRoot: { newRoot: "$mostRecentDocument" },
            },
            {
                $match: {
                    $or: [
                        {
                            exitstatus: true,
                        },
                        // Condition for "Approved" status
                        {
                            approvedStatus: "true",
                            cancelstatus: false,
                        },
                        // Condition for "Applied" status
                        {
                            status: "Applied",
                        },
                    ],
                    // Add the new conditions
                    rejectStatus: { $ne: "true" },
                    cancelstatus: { $ne: true },
                    continuestatus: { $ne: true },
                },
            },
            {
                $project: {
                    empname: 1,
                    empcode: 1,
                    status: 1,
                    rejectStatus: 1,
                    cancelstatus: 1,
                    approvedStatus: 1,
                    continuestatus: 1,
                    recheckStatus: 1,
                    exitstatus: 1,
                    createdAt: 1,
                },
            },
        ];
        // Run all queries in parallel using Promise.all
        const [allusers, attendance, allLeaveStatus, holidays, noticeperiodstatus] =
            await Promise.all([
                User.find(filterQuery, {
                    status: 1,
                    empcode: 1,
                    nexttime: 1,
                    companyname: 1,
                    username: 1,
                    email: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    company: 1,
                    shift: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    workmode: 1,
                    internstatus: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    doj: 1,
                    dot: 1,
                    role: 1,
                    assignExpLog: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    gender: 1,
                    maritalstatus: 1,
                    bloodgroup: 1,
                    location: 1,
                    aadhar: 1,
                    panno: 1,
                    panstatus: 1,
                    panrefno: 1,
                    fathername: 1,
                    mothername: 1,
                    contactfamily: 1,
                    contactno: 1,
                    prefix: 1,
                    assignExpMode: 1,
                    assignExpvalue: 1,
                    processtype: 1,
                    processduration: 1,
                    date: 1,
                    time: 1,
                    grosssalary: 1,
                    timemins: 1,
                    modeexperience: 1,
                    targetexperience: 1,
                    targetpts: 1,
                    dom: 1,
                    contactpersonal: 1,
                    designationlog: 1,
                    processlog: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    username: 1,
                    usernameautogenerate: 1,
                    workmode: 1,
                    email: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    unit: 1,
                    branch: 1,
                    designation: 1,
                    floor: 1,
                    shift: 1,
                    reportingto: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    bankdetails: 1,
                    shifttiming: 1,
                    shiftgrouping: 1,
                    shifttype: 1,
                    legalname: 1,
                    callingname: 1,
                    pdoorno: 1,
                    pstreet: 1,
                    parea: 1,
                    plandmark: 1,
                    ptaluk: 1,
                    ppost: 1,
                    ppincode: 1,
                    pcountry: 1,
                    pstate: 1,
                    pcity: 1,
                    cdoorno: 1,
                    cstreet: 1,
                    carea: 1,
                    role: 1,
                    clandmark: 1,
                    ctaluk: 1,
                    cpost: 1,
                    cpincode: 1,
                    ccountry: 1,
                    cstate: 1,
                    ccity: 1,
                    reasondate: 1,
                    process: 1,
                    workstation: 1,
                    workstationinput: 1,
                    workstationofficestatus: 1,
                    weekoff: 1,
                    originalpassword: 1,
                    enquirystatus: 1,
                    area: 1,
                    enableworkstation: 1,
                    wordcheck: 1,
                    shiftallot: 1,
                    firstname: 1,
                    lastname: 1,
                    employeecount: 1,
                    emergencyno: 1,
                    name: 1,
                    salarysetup: 1,
                    mode: 1,
                    salarycode: 1,
                    basic: 1,
                    hra: 1,
                    conveyance: 1,
                    medicalallowance: 1,
                    productionallowance: 1,
                    otherallowance: 1,
                    productionallowancetwo: 1,
                    pffromdate: 1,
                    pfenddate: 1,
                    esifromdate: 1,
                    esienddate: 1,
                    pfesistatus: 1,
                    remoteworkmodestatus: 1,
                    addremoteworkmode: 1,
                }).lean(),

                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),

                Noticeperiod.aggregate(noticeperiodpipeline).exec(),
            ]);

        let employeeDocumentsMap = {};

        // Fetch profile images only if profileimage is true
        if (profileimage) {
            const employeeDocuments = await EmployeeDocuments.find(
                {
                    commonid: { $in: allusers.map((user) => user._id.toString()) },
                },
                { profileimage: 1, commonid: 1 }
            ).lean();

            // Create a map of employee documents by commonid (user's _id)
            employeeDocumentsMap = employeeDocuments.reduce((acc, doc) => {
                acc[doc.commonid] = doc.profileimage || "";
                return acc;
            }, {});
        }
        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            allusers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        // Create a map for fast lookup
        const noticePeriodMap = noticeperiodstatus.reduce((acc, item) => {
            const key = `${item.empname}_${item.empcode}`;
            acc[key] = item;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays,
            doj
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;
            const isNewJoiner = pastThreeDaysISO.includes(doj);
            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            let status = null;
            if (isNewJoiner) {
                status = null;
            } else if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        // Function to determine the status
        const determineStatus = (
            attendanceStatus,
            noticePeriodStatus,
            livestatus
        ) => {
            if (noticePeriodStatus === "Exit Confirmed") {
                return `Exit Confirmed`;
            } else if (!livestatus && noticePeriodStatus && attendanceStatus) {
                return `Notice Period ${noticePeriodStatus} and ${attendanceStatus}`;
            } else if (noticePeriodStatus) {
                return `Notice Period ${noticePeriodStatus}`;
            } else if (!noticePeriodStatus && attendanceStatus) {
                return attendanceStatus;
            } else if (!noticePeriodStatus && !attendanceStatus && livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };

        // Enrich users with status
        const enrichedLeaveAttendanceUsers = allusers.map((user) => {
            const userId = user._id.toString();
            let weekOffDays = [];
            if (user.boardingLog && user.boardingLog.length > 0) {
                const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                weekOffDays = lastBoardingLog.weekoff || [];
            }
            const userKey = `${user.companyname}_${user.empcode}`;
            const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                userId,
                user.empcode,
                user.companyname,
                weekOffDays,
                user?.doj
            );
            const noticePeriodStatus =
                noticePeriodMap[userKey]?.exitstatus === true
                    ? "Exit Confirmed"
                    : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                        noticePeriodMap[userKey]?.cancelstatus === false &&
                        noticePeriodMap[userKey]?.continuestatus === false
                        ? "Approved"
                        : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                            noticePeriodMap[userKey]?.cancelstatus === true
                            ? "Cancelled"
                            : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                noticePeriodMap[userKey]?.continuestatus === true
                                ? "Continue"
                                : noticePeriodMap[userKey]?.rejectStatus === "true"
                                    ? "Rejected"
                                    : noticePeriodMap[userKey]?.recheckStatus === "true"
                                        ? "Recheck"
                                        : noticePeriodMap[userKey]?.status || null;
            const livestatus = !status && !noticePeriodStatus ? "Live" : null;
            const profileImage = profileimage
                ? employeeDocumentsMap[userId] || ""
                : null;
            return {
                ...user,
                attendanceStatus: noticePeriodStatus ? true : false,
                noticePeriodStatus: noticePeriodStatus ? true : false,
                livestatus: livestatus ? true : false,
                status: determineStatus(status, noticePeriodStatus, livestatus),
                longAbsentCount: absentDays, // Long absent count
                longLeaveCount: leaveDays, // Long leave count
                profileimage: profileimage ? profileImage : "",
            };
        });

        finalArray = enrichedLeaveAttendanceUsers;
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finalArray) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({
        count: finalArray.length,
        allusers: finalArray,
    });
});


exports.getAlluserDataFilterLongAbsend = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const {
            company,
            branch,
            unit,
            team,
            filterin,
            module,
            submodule,
            mainpage,
            subpage,
            subsubpage,
            status,
        } = req.body;
        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            doj: {
                $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
            },
        };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, // Include boardingLog in the result

            username: 1,
            originalpassword: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            doj: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pcountry: 1,
        }).lean();
        filteredUsers = result;

        const currentDateChecklist = moment().format("DD-MM-YYYY");
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];

        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];

        const [attendance, allLeaveStatus, holidays, checklistData] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                MyCheckList.find({
                    module,
                    submodule,
                    mainpage,
                    subpage,
                    subsubpage,
                    // status: { $ne: "completed" },
                    longleaveabsentaprooveddatechecklist: { $in: [currentDateChecklist] },
                }),
            ]);
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }

                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    continue; // User was present on this date
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    leaveDays++; // User was on leave on this date
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++; // Holiday on this date
                } else {
                    absentDays++; // User was absent on this date
                }
            }

            let status = null;
            if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        const determineStatus = (attendanceStatus) => {
            return attendanceStatus ? attendanceStatus : null;
        };

        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();

                const checklistItem = checklistData.find(
                    (item) => item.commonid === userId
                );
                // console.log(checklistItem?.longleaveabsentaprooveddatechecklist);
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }

                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays
                );

                return {
                    ...user,
                    attendanceStatus: !!status,
                    noticePeriodStatus: false,
                    livestatus: status ? false : null,
                    userstatus: determineStatus(status),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                    checklistassigned: !!checklistItem,
                    longleaveabsentaprooveddatechecklist:
                        checklistItem?.longleaveabsentaprooveddatechecklist,
                };
            })
            .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status

        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        console.log(err);
        return res.status(500).json({ error: "Internal server error" });
    }
});




exports.getAlluserDataFilterLongAbsendCompleted = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const {
            company,
            branch,
            unit,
            team,
            filterin,
            module,
            submodule,
            mainpage,
            subpage,
            subsubpage,
            status,
        } = req.body;
        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            doj: {
                $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
            },
        };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, // Include boardingLog in the result

            username: 1,
            originalpassword: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            doj: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pcountry: 1,
        }).lean();

        const currentDateChecklist = moment().format("DD-MM-YYYY");
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];

        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];

        const [attendance, allLeaveStatus, holidays, checklistData] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                MyCheckList.find({
                    // subsubpage: "Long Absent Restriction List",
                    status: { $in: ["progress", "Completed"] },
                    module,
                    submodule,
                    mainpage,
                    subpage,
                    subsubpage,
                    // status: { $ne: "completed" },
                    longleaveabsentaprooveddatechecklist: { $in: [currentDateChecklist] },
                }),
            ]);

        // filteredUsers = result.filter(d => return checklistData.some(item => item.commonid === d._id  ));
        // console.log(checklistData.length)
        filteredUsers = result.filter(d => {
            return checklistData.some(item => item.commonid == d._id);
        });
        // console.log(filteredUsers.length)

        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }

                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    continue; // User was present on this date
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    leaveDays++; // User was on leave on this date
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++; // Holiday on this date
                } else {
                    absentDays++; // User was absent on this date
                }
            }

            let status = null;
            if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        const determineStatus = (attendanceStatus) => {
            return attendanceStatus ? attendanceStatus : null;
        };

        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();

                const checklistItem = checklistData.find(
                    (item) => item.commonid === userId
                );
                // console.log(checklistItem?.longleaveabsentaprooveddatechecklist);
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }

                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays
                );

                return {
                    ...user,

                    attendanceStatus: !!status,
                    noticePeriodStatus: false,
                    livestatus: status ? false : null,
                    userstatus: determineStatus(status),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                    checklistassigned: !!checklistItem,
                    longleaveabsentaprooveddatechecklist:
                        checklistItem?.longleaveabsentaprooveddatechecklist,
                };
            })
            .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status

        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        console.log(err);
        return res.status(500).json({ error: "Internal server error" });
    }
});




exports.getAlluserDataFilterLongAbsendHierarchy = catchAsyncErrors(
    async (req, res) => {
        try {
            let filteredUsers, filterQuerys;
            let hierarchy,
                tertiaryhierarchyfinal,
                hierarchyfilter,
                filteredoverall,
                reportingtobaseduser,
                hierarchyfilter1,
                hierarchyfilter2,
                hierarchySecond,
                hierarchyMap,
                resulted,
                resultedTeam,
                hierarchyFinal,
                hierarchyDefault;
            const {
                company,
                branch,
                unit,
                team,
                filterin,
                module,
                submodule,
                mainpage,
                subpage,
                subsubpage,
                status,
                listpageaccessmode,
            } = req.body;


            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            // console.log(answer, "answert")
            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

            // console.log(restrictList, "restrict")


            const today = moment();
            const pastThreeDaysISO = [
                today.clone().format("YYYY-MM-DD"),
                today.clone().subtract(1, "days").format("YYYY-MM-DD"),
                today.clone().subtract(2, "days").format("YYYY-MM-DD"),
                today.clone().subtract(3, "days").format("YYYY-MM-DD"),
            ];
            let filterQuery = {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                doj: {
                    $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
                },
                ...(listpageaccessmode === "Reporting to Based"
                    ? { reportingto: req.body.username }
                    : {}),
            };

            if (Array.isArray(company) && company.length > 0) {
                filterQuery.company = { $in: company };
            }

            if (Array.isArray(branch) && branch.length > 0) {
                filterQuery.branch = { $in: branch };
            }

            if (Array.isArray(unit) && unit.length > 0) {
                filterQuery.unit = { $in: unit };
            }

            if (Array.isArray(team) && team.length > 0) {
                filterQuery.team = { $in: team };
            }

            const removeEmptyArrays = (obj) => {
                return Object.fromEntries(
                    Object.entries(obj).filter(
                        ([key, value]) => !Array.isArray(value) || value.length > 0
                    )
                );
            };

            filterQuerys = removeEmptyArrays(filterQuery);
            let resulting = await User.find(filterQuerys, {
                resonablestatus: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                empcode: 1,
                companyname: 1,
                longleaveabsentaprooveddate: 1,
                boardingLog: 1, // Include boardingLog in the result
                username: 1,
                originalpassword: 1,
                firstname: 1,
                lastname: 1,
                aadhar: 1,
                panno: 1,
                dob: 1,
                pstreet: 1,
                pcity: 1,
                ppincode: 1,
                pstate: 1,
                doj: 1,
                pcountry: 1,
            }).lean();

            if (
                (req.body.hierachy === "My Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchy = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: req.body.sector,
                });
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDef.length > 0
                            ? [].concat(...answerDef)
                            : []
                        : hierarchy.length > 0
                            ? [].concat(...hierarchy.map((item) => item.employeename))
                            : [];
                hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

                hierarchyfilter = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Primary",
                });
                primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0])
                    ? hierarchyfilter.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter1 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Secondary",
                });
                secondaryhierarchy = hierarchyfilter1.map(
                    (item) => item.employeename[0]
                )
                    ? hierarchyfilter1.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter2 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Tertiary",
                });
                tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0])
                    ? hierarchyfilter2.map((item) => item.employeename[0])
                    : [];

                resulted = resulting
                    .map((userObj) => {
                        const matchingHierarchy = hierarchyDefault.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            control: matchingHierarchy ? matchingHierarchy.control : "",
                        };
                    })
                    .filter((data) => hierarchyMap.includes(data.companyname));
            }

            if (
                (req.body.hierachy === "All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault
                    .map((data) => data.employeename)
                    .flat();

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    answerDef,
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                resultedTeam = resulting
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyall = resultedTeam
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            //my + all hierarchy list dropdown

            if (
                (req.body.hierachy === "My + All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                filteredoverall = resulting
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            if (listpageaccessmode === "Reporting to Based") {
                reportingtobaseduser = resulting.map((userObj) => {
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: "",
                        control: "",
                    };
                });
            }

            filteredUsers =
                req.body.hierachy === "My Hierarchy List" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resulted
                    : req.body.hierachy === "All Hierarchy List" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? resultedTeam
                        : req.body.hierachy === "My + All Hierarchy List" &&
                            (listpageaccessmode === "Hierarchy Based" ||
                                listpageaccessmode === "Overall")
                            ? filteredoverall
                            : reportingtobaseduser;

            const currentDateChecklist = moment().format("DD-MM-YYYY");
            const pastThreeAttendaysDays = [
                today.clone().format("DD-MM-YYYY"),
                today.clone().subtract(1, "days").format("DD-MM-YYYY"),
                today.clone().subtract(2, "days").format("DD-MM-YYYY"),
                today.clone().subtract(3, "days").format("DD-MM-YYYY"),
            ];

            const pastThreeLeaveDays = [
                today.clone().format("DD/MM/YYYY"),
                today.clone().subtract(1, "days").format("DD/MM/YYYY"),
                today.clone().subtract(2, "days").format("DD/MM/YYYY"),
                today.clone().subtract(3, "days").format("DD/MM/YYYY"),
            ];

            const [attendance, allLeaveStatus, holidays, checklistData] =
                await Promise.all([
                    Attendance.find(
                        {
                            date: {
                                $in: pastThreeAttendaysDays,
                            },
                        },
                        { date: 1, userid: 1 }
                    ).lean(),

                    ApplyLeave.find(
                        {
                            date: { $in: pastThreeLeaveDays },
                        },
                        { employeename: 1, employeeid: 1, date: 1 }
                    ).lean(),

                    Holiday.find(
                        {
                            date: { $in: pastThreeDaysISO },
                        },
                        {
                            date: 1,
                            employee: 1,
                            company: 1,
                            applicablefor: 1,
                            unit: 1,
                            team: 1,
                        }
                    ).lean(),
                    MyCheckList.find({
                        module,
                        submodule,
                        mainpage,
                        subpage,
                        subsubpage,
                        // status: { $ne: "completed" },
                        longleaveabsentaprooveddatechecklist: {
                            $in: [currentDateChecklist],
                        },
                    }),
                ]);

            const attendanceMap = attendance.reduce((acc, item) => {
                const userId = item.userid.toString();
                const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
                if (!acc[userId]) {
                    acc[userId] = [];
                }
                acc[userId].push(date);
                return acc;
            }, {});

            const leaveMap = allLeaveStatus.reduce((acc, item) => {
                const userKey = `${item.employeeid}_${item.employeename}`;
                const leaveDates = item.date.map((date) =>
                    moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
                );
                if (!acc[userKey]) {
                    acc[userKey] = [];
                }
                acc[userKey].push(...leaveDates);
                return acc;
            }, {});

            const employeeMatchesUser = (user, holiday) => {
                return (
                    holiday.company.includes(user.company) &&
                    holiday.applicablefor.includes(user.branch) &&
                    holiday.unit.includes(user.unit) &&
                    holiday.team.includes(user.team) &&
                    (holiday.employee.includes(user.companyname) ||
                        holiday.employee.includes("ALL"))
                );
            };

            const holidayMap = holidays.reduce((acc, item) => {
                const date = moment(item.date).format("DD/MM/YYYY");

                filteredUsers.forEach((user) => {
                    if (employeeMatchesUser(user, item)) {
                        if (!acc[user.empcode]) {
                            acc[user.empcode] = [];
                        }
                        acc[user.empcode].push(date);
                    }
                });

                return acc;
            }, {});

            const checkStatusForPast3Days = (
                userId,
                empcode,
                employeename,
                weekOffDays
            ) => {
                const userKey = `${empcode}_${employeename}`;
                let absentDays = 0;
                let leaveDays = 0;
                let holidayDays = 0;

                for (let date of pastThreeLeaveDays) {
                    // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                    // if (weekOffDays.includes(dayOfWeek)) {
                    //   continue; // Skip week off days
                    // }

                    if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                        continue; // User was present on this date
                    } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                        leaveDays++; // User was on leave on this date
                    } else if (
                        holidayMap[empcode] &&
                        holidayMap[empcode].includes(date)
                    ) {
                        holidayDays++; // Holiday on this date
                    } else {
                        absentDays++; // User was absent on this date
                    }
                }

                let status = null;
                if (absentDays >= 4) {
                    status = "Long Absent";
                } else if (leaveDays >= 4) {
                    status = "Long Leave";
                }

                return { status, absentDays, leaveDays, holidayDays };
            };

            const determineStatus = (attendanceStatus) => {
                return attendanceStatus ? attendanceStatus : null;
            };

            const resultAccessFiltered = filteredUsers
                ?.map((user) => {
                    const userId = user._id.toString();

                    const checklistItem = checklistData.find(
                        (item) => item.commonid === userId
                    );
                    let weekOffDays = [];
                    if (user.boardingLog && user.boardingLog.length > 0) {
                        const lastBoardingLog =
                            user.boardingLog[user.boardingLog.length - 1];
                        weekOffDays = lastBoardingLog.weekoff || [];
                    }

                    const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                        userId,
                        user.empcode,
                        user.companyname,
                        weekOffDays
                    );

                    return {
                        ...user,
                        attendanceStatus: !!status,
                        noticePeriodStatus: false,
                        livestatus: status ? false : null,
                        userstatus: determineStatus(status),
                        longAbsentCount: absentDays, // Long absent count
                        longLeaveCount: leaveDays, // Long leave count
                        checklistassigned: !!checklistItem,
                        longleaveabsentaprooveddatechecklist:
                            checklistItem?.longleaveabsentaprooveddatechecklist,
                    };
                })
                .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status


            const enrichedLeaveAttendanceUsers = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];
            return res.status(200).json({
                filterallDatauser: enrichedLeaveAttendanceUsers,
                tableName: filterin,
            });
        } catch (err) {
            return res.status(500).json({ error: "Internal server error" });
        }
    }
);


exports.getAlluserDataFilter = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const { company, branch, unit, team, status, filterin, isCurrentStatus } =
            req.body;

        const filterQuery = {
            company: company,
            branch: branch,
            unit: unit,
            team: team,
        };

        filterQuery.workmode =
            filterin === "Employee" ? { $ne: "Internship" } : { $eq: "Internship" };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            doj: 1,
            boardingLog: 1,
            attendancemode: 1, // Include boardingLog in the result
        }).lean();
        filteredUsers =
            !isCurrentStatus && status.length > 0
                ? result
                    .map((data) => {
                        if (
                            status.length === 1 &&
                            status.includes("Live") &&
                            (data.resonablestatus === "" ||
                                !data.resonablestatus ||
                                data.resonablestatus === "Rejoined")
                        ) {
                            return data;
                        }
                        if (
                            status.length > 1 &&
                            status.includes("Live") &&
                            (!data.resonablestatus ||
                                data.resonablestatus === "Rejoined" ||
                                data.resonablestatus === "" ||
                                status.includes(data.resonablestatus))
                        ) {
                            return data;
                        }
                        if (
                            !status.includes("Live") &&
                            data.resonablestatus &&
                            data.resonablestatus !== "Rejoined" &&
                            data.resonablestatus !== "" &&
                            status.includes(data.resonablestatus)
                        ) {
                            return data;
                        }
                    })
                    .filter((data) => data !== undefined)
                : result;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];

        const noticeperiodpipeline = [
            {
                // Sort by empname and then by createdAt in descending order
                $sort: { empname: 1, createdAt: -1 },
            },
            {
                // Group by empname and select the first document per group (most recent)
                $group: {
                    _id: "$empname", // Group by empname
                    mostRecentDocument: { $first: "$$ROOT" }, // Select the most recent document per empname
                },
            },
            {
                // Project the necessary fields from the most recent document
                $replaceRoot: { newRoot: "$mostRecentDocument" },
            },
            {
                $match: {
                    $or: [
                        {
                            exitstatus: true,
                        },
                        // Condition for "Approved" status
                        {
                            approvedStatus: "true",
                            cancelstatus: false,
                        },
                        // Condition for "Applied" status
                        {
                            status: "Applied",
                        },
                    ],
                    // Add the new conditions
                    rejectStatus: { $ne: "true" },
                    cancelstatus: { $ne: true },
                    continuestatus: { $ne: true },
                },
            },
            {
                $project: {
                    empname: 1,
                    empcode: 1,
                    status: 1,
                    rejectStatus: 1,
                    cancelstatus: 1,
                    approvedStatus: 1,
                    continuestatus: 1,
                    recheckStatus: 1,
                    exitstatus: 1,
                    createdAt: 1,
                },
            },
        ];

        const [attendance, allLeaveStatus, holidays, noticeperiodstatus] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                Noticeperiod.aggregate(noticeperiodpipeline).exec(),
            ]);

        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        // Create a map for fast lookup
        const noticePeriodMap = noticeperiodstatus.reduce((acc, item) => {
            const key = `${item.empname}_${item.empcode}`;
            acc[key] = item;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays, doj
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;
            const isNewJoiner = pastThreeDaysISO.includes(doj);
            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }
            let status = null;
            if (isNewJoiner) {
                status = null;
            } else if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        // Function to determine the status
        const determineStatus = (
            attendanceStatus,
            noticePeriodStatus,
            livestatus
        ) => {
            if (noticePeriodStatus === "Exit Confirmed") {
                return `Exit Confirmed`;
            } else if (!livestatus && noticePeriodStatus && attendanceStatus) {
                return `Notice Period ${noticePeriodStatus} and ${attendanceStatus}`;
            } else if (noticePeriodStatus) {
                return `Notice Period ${noticePeriodStatus}`;
            } else if (!noticePeriodStatus && attendanceStatus) {
                return attendanceStatus;
            } else if (!noticePeriodStatus && !attendanceStatus && livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };

        // Enrich users with status
        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }
                const userKey = `${user.companyname}_${user.empcode}`;
                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays,
                    user?.doj
                );
                const noticePeriodStatus =
                    noticePeriodMap[userKey]?.exitstatus === true
                        ? "Exit Confirmed"
                        : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                            noticePeriodMap[userKey]?.cancelstatus === false &&
                            noticePeriodMap[userKey]?.continuestatus === false
                            ? "Approved"
                            : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                noticePeriodMap[userKey]?.cancelstatus === true
                                ? "Cancelled"
                                : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                    noticePeriodMap[userKey]?.continuestatus === true
                                    ? "Continue"
                                    : noticePeriodMap[userKey]?.rejectStatus === "true"
                                        ? "Rejected"
                                        : noticePeriodMap[userKey]?.recheckStatus === "true"
                                            ? "Recheck"
                                            : noticePeriodMap[userKey]?.status || null;
                const livestatus = !status && !noticePeriodStatus ? "Live" : null;

                return {
                    ...user,
                    attendanceStatus: noticePeriodStatus ? true : false,
                    noticePeriodStatus: noticePeriodStatus ? true : false,
                    livestatus: livestatus ? true : false,
                    userstatus: determineStatus(status, noticePeriodStatus, livestatus),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                };
            })
            ?.filter((data) => {
                if (isCurrentStatus && status?.length > 0) {
                    if (status.includes("Live")) {
                        // Condition when "Live" is in the array
                        return data.userstatus === "Live";
                    }

                    if (status.includes("Long Absent")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Long Absent" ||
                            data.userstatus === "Notice Period Applied Long Absent" ||
                            data.userstatus === "Notice Period Approved Long Absent"
                        );
                    }
                    if (status.includes("Long Leave")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Long Leave" ||
                            data.userstatus === "Notice Period Applied Long Leave" ||
                            data.userstatus === "Notice Period Approved Long Leave"
                        );
                    }
                    if (status.includes("Notice Period Applied")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Notice Period Applied" ||
                            data.userstatus === "Notice Period Applied Long Leave"
                        );
                    }
                    if (status.includes("Notice Period Approved")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Notice Period Approved" ||
                            data.userstatus === "Notice Period Approved Long Leave"
                        );
                    }
                    if (status.includes("Exit Confirmed")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return data.userstatus === "Exit Confirmed";
                    }

                    return false; // Default case if none of the conditions are met
                } else {
                    return data;
                }
            });

        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


//controller to get the ex-user names
exports.getFormerUserNames = catchAsyncErrors(async (req, res, next) => {
    let pass, users;
    try {
        users = await User.find(
            {
                resonablestatus: {
                    $in: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    return res.status(200).json({
        formerusers: users,
    });
});


exports.getOnBoardingSalaryFix = catchAsyncErrors(async (req, res, next) => {
    try {
        const {
            salaryrange,
            type,
            process,
            amountvalue,
            fromamount,
            toamount,
            company,
            branch,
            batchNumber,
            batchSize,
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const fromAmount = parseFloat(fromamount);
        const toAmount = parseFloat(toamount);
        const skip = (batchNumber - 1) * batchSize;
        const limit = batchSize;

        // Define the match conditions based on the inputs
        let matchConditions = {
            company: { $in: company },
            branch: { $in: branch },
        };

        if (type === "Process Wise") {
            matchConditions.salarycode = new RegExp("^" + process);
        }

        switch (salaryrange) {
            case "Less Than":
                matchConditions.totalValue = { $lt: amountValue };
                break;
            case "Greater Than":
                matchConditions.totalValue = { $gt: amountValue };
                break;
            case "Exact":
                matchConditions.totalValue = { $eq: amountValue };
                break;
            case "Between":
                matchConditions.totalValue = { $gte: fromAmount, $lte: toAmount };
                break;
        }

        // Perform the optimized aggregation query
        const results = await Salaryslab.aggregate([
            {
                $addFields: {
                    totalValue: {
                        $add: [
                            "$basic",
                            "$hra",
                            "$conveyance",
                            "$medicalallowance",
                            "$productionallowance",
                            "$otherallowance",
                        ],
                    },
                },
            },
            { $match: matchConditions },
            { $skip: skip },
            { $limit: limit },
            {
                $lookup: {
                    from: "targetpoints",
                    localField: "salarycode",
                    foreignField: "processcode",
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: { $arrayElemAt: ["$targetpoints.points", 0] },
                },
            },
            {
                $project: {
                    targetPointsValue: 1,
                    totalValue: 1,
                    salarycode: 1,
                    company: 1,
                    branch: 1,
                    processqueue: 1,
                },
            },
        ]).exec();

        // Execute the process team query in parallel
        const processTeamData = await ProcessTeam.find(
            {
                company: { $in: company },
                branch: { $in: branch },
                process: { $in: results.map((r) => r.processqueue) },
            },
            { unit: 1, team: 1, company: 1, branch: 1, process: 1 }
        ).lean();

        // Combine the results
        const combinedArray = processTeamData.flatMap((mainItem) =>
            results.map((subItem) => ({
                ...mainItem,
                ...subItem,
                _id: new ObjectId(),
            }))
        );

        // Respond with the result
        return res.status(200).json({ results: combinedArray });
    } catch (err) {
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
});


exports.getAllTemplateUsers = catchAsyncErrors(async (req, res, next) => {
    try {
        const empDocs = await EmployeeDocuments.find({}, { 'files.name': 1, 'files.remark': 1, 'commonid': 1 }).lean();

        const pageSize = 100;
        let page = 0;
        let users;
        let allUsers = [];

        do {
            users = await User.find({}, {
                _id: 1, // Minimal data
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                fathername: 1,
                mothername: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                aadhar: 1,
                panno: 1,
                eduTodo: 1,
                assignEndExpvalue: 1,
                endexpdate: 1,
                assignExpLog: 1,
                workhistTodo: 1,
                age: 1,
                bankdetails: 1,
                addAddQuaTodo: 1,
                referencetodo: 1,
                workstation: 1,
            }).lean().skip(page * pageSize).limit(pageSize);

            if (!users || users.length === 0) break;
            const mappedUsers = users.map((data, index) => {

                const foundData = empDocs.find((item) => item?.commonid?.toString() === data?._id?.toString());
                const employeedocumentfiles = foundData ? foundData.files.map((itemnew) => ({
                    name: itemnew.name,
                    remark: itemnew.remark
                })) : [];

                return { ...data, employeedocumentfiles };
            });

            allUsers = [...allUsers, ...mappedUsers];
            page++;
        } while (users.length === pageSize);

        if (allUsers.length === 0) {
            return next(new ErrorHandler("Users not found", 400));
        }

        // Implementing pagination in response
        const totalPages = Math.ceil(allUsers.length / pageSize);
        const currentPage = parseInt(req.query.page) || 1;
        const paginatedUsers = allUsers.slice((currentPage - 1) * pageSize, currentPage * pageSize);

        return res.status(200).json({ count: allUsers.length, users: allUsers, totalPages, currentPage });
    } catch (err) {
        return next(new ErrorHandler("An error occurred while fetching users", 500));
    }
});

//VerifiedList Update
exports.updateVerifyUser = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;
    const upverifyuser = await User.findByIdAndUpdate(id, req.body,
        { new: true }
    );
    if (!upverifyuser) {
        return next(new ErrorHandler("User not found", 404));
    }
    return res.status(200).json({ message: "Updated successfully!", upverifyuser });
});

//controller to get employee/intern with status for list pages
exports.getAllUserAttendancePayRun = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { ismonth, isyear, department } = req.body;

    try {

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear
        }
        if (req.body.department.length > 0) {
            querydeptmonth.department = { $in: req.body.department }
        }

        let [usersAll, depMonthSet, controlcriteria, shift, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    companyname: { $in: req.body.employees },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },

                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                // shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const resultDateArray = depMonthSet.reduce((acc, curr) => {
            // Compare and update the earliest fromdate
            if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                acc.fromdate = curr.fromdate;
            }
            // Compare and update the latest todate
            if (new Date(curr.todate) > new Date(acc.todate)) {
                acc.todate = curr.todate;
            }
            return acc;
        }, {
            fromdate: depMonthSet[0].fromdate, // Start with the first fromdate
            todate: depMonthSet[0].todate      // Start with the first todate
        });

        function formatDate(dateString) {
            const [day, month, year] = dateString.split("-");
            return `${year}-${month}-${day}`;
        }

        let attFromDate = (resultDateArray.fromdate)
        let attToDate = (resultDateArray.todate)
        const userIds = usersAll.map(user => user._id);
        const userCds = usersAll.map(user => user.companyname);
        const [attendance, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, createdAt: { $gte: attFromDate, $lte: attToDate } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 })

        ])

        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];

        let users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            if (department.includes(findUserDeprtment)) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];


            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);


                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find(item => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item.todate === date.formattedDate);
                const filterBoardingLog = item.boardingLog && item.boardingLog?.filter((item) => {
                    // return item.logcreation === "user" || item.logcreation === "shift";
                    return item;
                });
                const attendanceFiltered = attendance.filter(d => {
                    const datevalue = formatDate(d.date);
                    return (
                        d.username == item.username && new Date(datevalue) >= new Date(attFromDate) && new Date(datevalue) <= new Date(attToDate)

                    )

                }

                )
                // const attendanceFiltered = attendance
                const depMonthSetFiltered = depMonthSet.filter(d => d.department === item.department)
                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;
                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: item.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,), item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        clockOutHours, checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
// update ProductionUpload by id => /api/productionupload/:id
exports.updatePayrunListInnerDataUser = catchAsyncErrors(async (req, res, next) => {

    const { outerId, month, value, year, date, fieldName } = req.body; // Extract the inner ID, month, value, year, date, and dynamic field name from the request body

    const update = {
        $push: {
            [fieldName]: { month, value, year, date }
        }
    };


    const options = {

        new: true
    };


    let upayrunlist = await User.findOneAndUpdate(
        { _id: outerId },
        update,
        options
    );


    if (!upayrunlist) {
        return next(new ErrorHandler("Data not found!", 404));
    }

    return res.status(200).json({ message: "Updated successfully", upayrunlist });
});

exports.undoPayrunListInnerDataUser = catchAsyncErrors(async (req, res, next) => {

    const { outerId, fieldName } = req.body;


    const update = {
        $set: {
            [fieldName]: []
        }
    };


    const options = {

        new: true
    };


    let upayrunlist = await User.findOneAndUpdate(
        { _id: outerId },
        update,
        options
    );


    if (!upayrunlist) {
        return next(new ErrorHandler("Data not found!", 404));
    }

    return res.status(200).json({ message: "Updated successfully", upayrunlist });
});


exports.getUserDocumentPrep = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                companyname: req.body.name,
            },
            {
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                designation: 1,
                id: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

//emp login status
exports.getAllUserLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                // $where: function() {
                //     return this.loginUserStatus && this.loginUserStatus.length > 0;
                //   }
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1, wfhcount: 1, wfhstatus: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});



exports.getAllUserEnquiryLive = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                empcode: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});
exports.getAllUserClockinAndClockoutStatusDocumentPreparation = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let depMonthSet;
    let shift;
    let attendance;
    let allLeaveStatus;
    let leavetype;
    let permission;
    let holidays;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates, person } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                username: person
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            departmentlog: 1,
        }
        );
        controlcriteria = await ControlCriteria.find();
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });
        attendance = await Attendance.find({
            date: { $in: formattedUserDates },
            username: person
        });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };


                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterDocPrep = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let shift;
    let attendance;
    let allLeaveStatus;
    let leavetype;
    let permission;
    let holidays;
    let resultshiftallot = [];
    let depMonthSet;
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { ismonth, isyear, username } = req.body;

    try {
        users = await User.find(
            {
                company: req.body.company,
                branch: req.body.branch,
                unit: req.body.unit,
                username: username,
                department: req.body.department,
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        controlcriteria = await ControlCriteria.find();
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });
        const userIds = users.map(user => user._id);
        attendance = await Attendance.find({ userid: { $in: userIds } });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item?._doc?.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const findShiftTiming = (shiftName) => {
                const foundShift = shift?.find((d) => d.name === shiftName);
                return foundShift
                    ? `${foundShift.fromhour}:${foundShift.frommin}${foundShift.fromtime}to${foundShift.tohour}:${foundShift.tomin}${foundShift.totime} `
                    : '';
            };

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item?._doc?.doj, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

//visitor scan

exports.getAllUsersVisitorRegister = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                company: req.body.company,
                branch: req.body.branch,
            },

            { companyname: 1, unit: 1 }

        );
    } catch (err) {
        return next(new ErrorHandler("Data not found", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllUserClockinAndClockoutStatusLoginCheck = catchAsyncErrors(async (req, res, next) => {
    let users;
    let depMonthSet;
    let shift;
    let finaluser = [];

    // const { userDates } = req.body;
    const currDate = new Date();
    var today = new Date();
    var todayDate = new Date();
    var dd = String(today.getDate()).padStart(2, "0");
    var mm = String(today.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = today.getFullYear();
    today = yyyy + "-" + mm + "-" + dd;
    var todayDateFormat = `${dd}/${mm}/${yyyy}`;

    // Get yesterday's date
    var yesterday = new Date(todayDate);
    yesterday.setDate(todayDate.getDate() - 1);
    var ddp = String(yesterday.getDate()).padStart(2, "0");
    var mmp = String(yesterday.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyyp = yesterday.getFullYear();
    var yesterdayDate = yyyyp + "-" + mmp + "-" + ddp;
    var yesterdayDateFormat = `${ddp}/${mmp}/${yyyyp}`;

    let startMonthDate = new Date(yesterdayDate);
    let endMonthDate = new Date(today);
    const daysArray = [];

    while (startMonthDate <= endMonthDate) {
        const formattedDate = `${String(startMonthDate.getDate()).padStart(
            2,
            "0"
        )}/${String(startMonthDate.getMonth() + 1).padStart(
            2,
            "0"
        )}/${startMonthDate.getFullYear()}`;
        const dayName = startMonthDate.toLocaleDateString("en-US", {
            weekday: "long",
        });
        const dayCount = startMonthDate.getDate();
        const shiftMode = "Main Shift";

        daysArray.push({ formattedDate, dayName, dayCount, shiftMode });

        // Move to the next day
        startMonthDate.setDate(startMonthDate.getDate() + 1);
    }


    const userDates = daysArray;

    try {
        users = await User.find(
            {
                empcode: req.body.empcode,
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });

        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });
            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });
            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });
            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));
            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;

        });
        const checking = beforefinaluser?.findIndex(data => data?.shift === "Week Off")
        const dataPick = checking < 1 ? checking : checking - 1
        const dateFormatCheck = beforefinaluser[dataPick]?.formattedDate;
        const [start, end] = beforefinaluser[dataPick]?.shift?.split('to') || [];

        const getEndDateTime = (formattedDate, shift) => {
            const [start, end] = shift?.split('to') || [];

            if (formattedDate && start && end) {
                // Convert date from DD/MM/YYYY to YYYY/MM/DD
                const formattedDateISO = formattedDate.split('/').reverse().join('-');

                // Function to convert 12-hour time to 24-hour time
                const convertTo24HourFormat = (time) => {
                    let [hours, minutes] = time.slice(0, -2).split(':');
                    const period = time.slice(-2);
                    if (period.toUpperCase() === 'PM' && hours !== '12') {
                        hours = parseInt(hours, 10) + 12;
                    } else if (period.toUpperCase() === 'AM' && hours === '12') {
                        hours = '00';
                    }
                    return `${hours}:${minutes}:00`;
                };

                const start24Hour = convertTo24HourFormat(start);
                const end24Hour = convertTo24HourFormat(end);

                const startDate = new Date(`${formattedDateISO}T${start24Hour}`);
                const endDate = new Date(`${formattedDateISO}T${end24Hour}`);

                // Handle case where end time is past midnight
                if (endDate < startDate) {
                    endDate.setDate(endDate.getDate() + 1);
                }

                return endDate;
            }

            return null;
        };

        const shiftDetailsYes = beforefinaluser[dataPick]?.shift;

        const endDateYess = moment(getEndDateTime(dateFormatCheck, shiftDetailsYes)).format("DD/MM/YYYY");
        const handleWeekOffShift = (shiftDetails) => {
            let currentDate = new Date(getEndDateTime(dateFormatCheck, shiftDetailsYes));
            currentDate.setHours(currentDate.getHours() + 4);
            for (let i = 1; i < shiftDetails.length; i++) {
                const currentShift = shiftDetails[i];
                if (currentShift.shift === 'Week Off') {
                    const previousShift = shiftDetails[i - 1];
                    const endDatePreviousShift = getEndDateTime(previousShift.formattedDate, previousShift.shift);
                    const endDatePreviousShiftFormatted = moment(endDatePreviousShift).format('DD/MM/YYYY');

                    if (endDatePreviousShiftFormatted === currentShift.formattedDate
                        && (currentDate >= new Date())
                    ) {
                        currentShift.shift = previousShift?.shift;
                        return;
                    } else {
                        currentShift.shift = 'Week Off';
                        return;
                    }
                }
            }
        };

        handleWeekOffShift(beforefinaluser);

        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});
//log updates
//update any log
exports.updateAnyLogValues = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    const updateFields = req.body;

    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const updateObj = { $set: {} };
        for (const key in updateFields) {
            updateObj.$set[`${logname}.$.${key}`] = updateFields[key];
        }

        const uploaddata = await User.findOneAndUpdate(query, updateObj, {
            new: true,
        });

        if (uploaddata) {
            return res
                .status(200)
                .json({ message: "Updated successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});

//delete any log
exports.deleteAnyLog = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const update = {
            $pull: {
                [logname]: { _id: logid },
            },
        };

        const deletedata = await User.findOneAndUpdate(query, update, {
            new: true,
        });

        if (deletedata) {
            return res
                .status(200)
                .json({ message: "Deleted successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});
exports.deleteShiftAnyLog = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const update = {
            $pull: {
                [logname]: { _id: logid },
            },
        };

        const deletedata = await User.findOneAndUpdate(query, update, {
            new: true,
        });

        if (deletedata) {
            return res
                .status(200)
                .json({ message: "Deleted successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});

exports.getAllUserProductionDayShiftFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let depMonthSet;
    let shift;
    let resultshiftallot = [];
    let finaluser = [];
    let query;
    const { userDates } = req.body;

    try {

        query = {
            company: { $in: req.body.company },
            branch: { $in: req.body.branch },
            unit: { $in: req.body.unit },
            team: { $in: req.body.team },
            companyname: { $in: req.body.empname },
            enquirystatus: { $nin: ["Enquiry Purpose"] },
            // resonablestatus: { $ne: "" }, // Include only when resonablestatus is not empty
            $or: [
                { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                { reasondate: "" }, // Include if reasondate doesn't exist
                { reasondate: { $gte: req.body.fromdate } } // Include if reasondate is greater than or equal to fromdate
            ]
        };
        users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            reasondate: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );
        controlcriteria = await ControlCriteria.find();
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);

            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            const createdUserDatesNext = sortedCreatedUserDates?.filter(d => {

                const filterData = userDates.some(val => {
                    const [day, month, year] = val.formattedDate.split('/').map(Number);
                    const currdate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript

                    // Add one day
                    currdate.setDate(currdate.getDate() + 1);

                    // Format the new date as DD/MM/YYYY
                    const newDay = String(currdate.getDate()).padStart(2, '0');
                    const newMonth = String(currdate.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                    const newYear = currdate.getFullYear();

                    const nextDateFormatted = `${newDay}/${newMonth}/${newYear}`;

                    return (nextDateFormatted === d.formattedDate)
                });
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date, index) => {
                const nextdate = createdUserDates[index + 1]
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                //Next Date
                const matchingItemNext = nextdate ? filteredRowData?.find(item => item && item?._doc?.adjdate == nextdate.formattedDate) : "";
                const matchingItemAllotNext = nextdate ? filteredRowData?.find(item => item && formatDate(item?._doc?.date) == nextdate.formattedDate) : "";
                const matchingDoubleShiftItemNext = nextdate ? filteredRowData.find(item => item && item?._doc?.todate === nextdate.formattedDate) : "";
                // const isWeekOffNext = nextdate ? item?._doc?.weekoff?.includes(nextdate.dayName) : "";
                const isWeekOffNext = nextdate ? (getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false) : "";
                const isWeekOffWithAdjustmentNext = nextdate ? isWeekOffNext && matchingItem : "";
                const isWeekOffWithManualNext = nextdate ? isWeekOffNext && matchingItemAllot : "";

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    nextshift: nextdate ? getShiftForDate(nextdate, matchingItemNext, matchingItemAllotNext, isWeekOffWithAdjustmentNext, isWeekOffWithManualNext, filterBoardingLog, isWeekOffNext, matchingDoubleShiftItemNext, item?._doc?.departmentlog, depMonthSet) : "",

                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                };


                return row;
            });

            return userRows;

        });
        finaluser.filter(item => new Date(item.reasondate) <= new Date(req.body.fromdate))
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
// get All user => /api/users
exports.getAllUsersEmployee = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllUserProductionDayShiftAttendanceFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let depMonthSet;
    let shift;
    let resultshiftallot = [];
    let finaluser = [];
    let query;
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {


        query = {
            company: { $in: req.body.company },
            branch: { $in: req.body.branch },
            unit: { $in: req.body.unit },
            team: { $in: req.body.team },
            companyname: { $in: req.body.empname },
            enquirystatus: { $nin: ["Enquiry Purpose"] },
            // resonablestatus: { $ne: "" }, // Include only when resonablestatus is not empty
            $or: [
                { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                { reasondate: { $lte: req.body.fromdate } } // Include if reasondate is greater than or equal to fromdate
            ]
        };


        users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            reasondate: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            departmentlog: 1,
        }
        );
        controlcriteria = await ControlCriteria.find();
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);

            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });
            const createdUserDatesNext = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => {
                    const [day, month, year] = val.formattedDate.split('/').map(Number);
                    const currdate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript

                    // Add one day
                    currdate.setDate(currdate.getDate() + 1);

                    // Format the new date as DD/MM/YYYY
                    const newDay = String(currdate.getDate()).padStart(2, '0');
                    const newMonth = String(currdate.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                    const newYear = currdate.getFullYear();

                    const nextDateFormatted = `${newDay}/${newMonth}/${newYear}`;

                    return (nextDateFormatted === d.formattedDate)
                });
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date, index) => {
                const nextdate = createdUserDates[index + 1]
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                //Next Date
                const matchingItemNext = nextdate ? filteredRowData?.find(item => item && item?._doc?.adjdate == nextdate.formattedDate) : "";
                const matchingItemAllotNext = nextdate ? filteredRowData?.find(item => item && formatDate(item?._doc?.date) == nextdate.formattedDate) : "";
                const matchingDoubleShiftItemNext = nextdate ? filteredRowData.find(item => item && item?._doc?.todate === nextdate.formattedDate) : "";
                // const isWeekOffNext = nextdate ? item?._doc?.weekoff?.includes(nextdate.dayName) : "";
                const isWeekOffNext = nextdate ? (getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false) : "";
                const isWeekOffWithAdjustmentNext = nextdate ? isWeekOffNext && matchingItem : "";
                const isWeekOffWithManualNext = nextdate ? isWeekOffNext && matchingItemAllot : "";

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    reasondate: item?._doc?.reasondate,
                    doj: item?._doc?.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    nextshift: nextdate ? getShiftForDate(nextdate, matchingItemNext, matchingItemAllotNext, isWeekOffWithAdjustmentNext, isWeekOffWithManualNext, filterBoardingLog, isWeekOffNext, matchingDoubleShiftItemNext, item?._doc?.departmentlog, depMonthSet) : "",

                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,

                };


                return row;
            });

            return userRows;

        });
        finaluser.filter(item => new Date(item.reasondate) <= new Date(req.body.fromdate))
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.getAllUserstatusDepCheck = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            { department: req?.body?.department },
            {

                resonablestatus: 1,
                department: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,

                email: 1,
                unit: 1,
                branch: 1,
                department: 1,
                username: 1,
                designation: 1,
                team: 1,
                role: 1,

                legalname: 1,
                callingname: 1,


                workstation: 1,
                area: 1,
                firstname: 1,
                lastname: 1

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: usersstatus.length, usersstatus });
});


exports.getAllUserLoginStatusAction = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1, wfhcount: 1, wfhstatus: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});


exports.getAllUserLoginExpStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.aggregate([
            {
                $match: {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"]
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate"
                        ]
                    },
                    extratimestatus: {
                        $in: [
                            "onetime-used",
                            "manual-used",
                            "permanent-used"
                        ]
                    }
                }
            },
            {
                $lookup: {
                    from: "individualsettings",
                    localField: "companyname",
                    foreignField: "companyname",
                    as: "result"
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extratimestatus: 1,
                    extradate: 1,
                    loginUserStatus: 1,
                    extraTimeStatus: 1,
                    loginapprestriction: {
                        $cond: {
                            if: { $gt: [{ $size: "$result" }, 0] },
                            then: {
                                $arrayElemAt: [
                                    "$result.loginapprestriction",
                                    0
                                ]
                            },
                            else: null
                        }
                    }
                }
            },
            {
                $lookup: {
                    from: "adminoverallsettings",
                    pipeline: [
                        { $match: {} },
                        {
                            $project: {
                                loginapprestriction: 1,
                                _id: 1,
                                empcode: 1,
                                companyname: 1,
                                username: 1,
                                branch: 1,
                                unit: 1,
                                designation: 1,
                                team: 1,
                                department: 1,
                                company: 1,
                                extratime: 1,
                                extrastatus: 1,
                                extratimestatus: 1,
                                extradate: 1,
                                loginUserStatus: 1,
                                extraTimeStatus: 1
                            }
                        }
                    ],
                    as: "adminResult"
                }
            },
            {
                $addFields: {
                    loginapprestriction: {
                        $cond: {
                            if: {
                                $eq: ["$loginapprestriction", null]
                            },
                            then: {
                                $arrayElemAt: [
                                    "$adminResult.loginapprestriction",
                                    0
                                ]
                            },
                            else: "$loginapprestriction"
                        }
                    }
                }
            },
            {
                $project: {
                    _id: 1,
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extratimestatus: 1,
                    extradate: 1,
                    loginUserStatus: 1,
                    extraTimeStatus: 1,
                    loginapprestriction: 1
                }
            }
        ]);

    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    // if (!users) {
    //     return next(new ErrorHandler("User not found!", 404));
    // }
    return res.status(200).json({
        users,
    });
});


exports.getAllProfileImage = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.aggregate([
            {
                $match: {
                    enquirystatus: { $nin: ["Enquiry Purpose"] },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                },
            },
            {
                $addFields: {
                    userIdStr: { $toString: "$_id" }, // Convert the ObjectId to string
                },
            },
            {
                $lookup: {
                    from: "employeedocuments",
                    localField: "userIdStr", // Use the string version of _id
                    foreignField: "commonid", // Match against the string commonid
                    as: "profileimage",
                },
            },
            {
                $addFields: {
                    profileimage: {
                        $ifNull: [{ $arrayElemAt: ["$profileimage.profileimage", 0] }, ""],
                    },
                },
            },
            {
                $project: {
                    empcode: 1,
                    companyname: 1,
                    email: 1,
                    contactfamily: 1,
                    contactpersonal: 1,
                    emergencyno: 1,
                    profileimage: 1,
                },
            },
        ]);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});

exports.getAllUserClockinAndClockoutStatusCheckLogin = catchAsyncErrors(async (req, res, next) => {
    let users;
    let depMonthSet;
    let shift;
    let finaluser = [];

    const { userDates } = req.body;

    try {
        users = await User.find(
            {
                empcode: req.body.empcode,
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });

        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});

exports.checkEmployeeEmptyFields = async (req, res) => {
    try {
        const { id } = req.query;

        // Fetch the user document first
        const document = await User.findById(id).lean();

        if (!document) {
            return res.status(404).json({ message: "Document not found" });
        }

        // Fetch employeedocument and assignbranch concurrently
        const [employeedocument, assignbranch] = await Promise.all([
            EmployeeDocuments.findOne({ commonid: document._id.toString() }).lean(),
            AssignBranch.findOne({
                employee: document.companyname,
                employeecode: document.empcode,
            }).lean(),
        ]);

        const emptyFields = new Set(); // Using Set to avoid duplicate entries

        const checkEmpty = (obj, prefix = "") => {
            for (const key in obj) {
                const value = obj[key];

                if (Array.isArray(value) && key === "workstation") {
                    if (value.length === 0) {
                        emptyFields.add("workstationprimary");
                        emptyFields.add("workstationsecondary");
                    } else {
                        if (value.includes("Please Select Primary Work Station")) {
                            emptyFields.add("workstationprimary");
                        }
                        if (value.length === 1) {
                            emptyFields.add("workstationsecondary");
                        }
                    }
                } else if (Array.isArray(value) && key === "boardingLog") {
                    if (value.length === 0) {
                        emptyFields.add("weekoff");
                    } else if (value.length > 0) {
                        if (value[value?.length - 1]?.weekoff?.length === 0) {
                            emptyFields.add("weekoff");
                        }
                    }
                } else if (
                    value === "" || // Check for empty string
                    value === "undefined" || // Check for "undefined" as a string
                    value === undefined || // Check for actual undefined
                    (Array.isArray(value) && value.length === 0) || // Check for empty array
                    (typeof value === "number" && value === 0) // Check for number equal to 0
                ) {
                    emptyFields.add(prefix + key);
                } else if (
                    typeof value === "object" &&
                    value !== null &&
                    !Array.isArray(value)
                ) {
                    // Recursively check nested objects
                    checkEmpty(value, `${prefix}${key}.`);
                }
            }

            if (obj.workmode !== "Internship") {
                emptyFields.delete(`${prefix}intStartDate`);
                emptyFields.delete(`${prefix}intEndDate`);
                emptyFields.delete(`${prefix}modeOfInt`);
                emptyFields.delete(`${prefix}intDuration`);
            }
            if (obj.maritalstatus !== "Married") {
                emptyFields.delete(`${prefix}dom`);
            }
        };

        checkEmpty(document);

        // Post-processing conditions after the loop
        if (document.panstatus === "Have PAN") {
            emptyFields.delete("panrefno");
        }

        if (document.panstatus === "Applied") {
            emptyFields.delete("panno");
        }

        if (document.panstatus === "Yet to Apply") {
            emptyFields.delete("panno");
            emptyFields.delete("panrefno");
        }

        // Check for employeedocument fields
        if (!employeedocument) {
            emptyFields.add("profileimage");
            emptyFields.add("employeedocuments");
        } else {
            if (!employeedocument.profileimage) emptyFields.add("profileimage");
            if (employeedocument.files.length === 0)
                emptyFields.add("employeedocuments");
        }

        // Check for assignbranch
        if (!assignbranch) {
            emptyFields.add("assignbranch");
        }
        return res.status(200).json({
            message: "Check completed",
            emptyFields: [...emptyFields], // Convert Set back to array
        });
    } catch (err) {
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
};
exports.getUserCredentials = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                username: req.body.username,
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                username: 1,
                email: 1,
                companyname: 1,
                id: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Data not found", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});
exports.getAllUserTemporaryLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.aggregate([
            {
                $lookup: {
                    from: "individualsettings",
                    localField: "companyname",
                    foreignField: "companyname",
                    as: "result"
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    designation: 1,
                    department: 1,
                    extrastatus: 1,
                    extradate: 1,
                    extratime: 1,
                    extramode: 1,
                    loginapprestriction: {
                        $cond: {
                            if: { $gt: [{ $size: "$result" }, 0] },
                            then: {
                                $arrayElemAt: [
                                    "$result.loginapprestriction",
                                    0
                                ]
                            },
                            else: null
                        }
                    }
                }
            },
            {
                $lookup: {
                    from: "adminoverallsettings",
                    pipeline: [
                        { $match: {} },
                        {
                            $project: {
                                loginapprestriction: 1,
                                companyname: 1,
                                _id: 1,
                                empcode: 1,
                                company: 1,
                                branch: 1,
                                unit: 1,
                                team: 1,
                                designation: 1,
                                department: 1,
                                extramode: 1,
                                extrastatus: 1,
                                extradate: 1,
                                extratime: 1
                            }
                        }
                    ],
                    as: "adminResult"
                }
            },
            {
                $addFields: {
                    loginapprestriction: {
                        $cond: {
                            if: {
                                $eq: ["$loginapprestriction", null]
                            },
                            then: {
                                $arrayElemAt: [
                                    "$adminResult.loginapprestriction",
                                    0
                                ]
                            },
                            else: "$loginapprestriction"
                        }
                    }
                }
            },
            // Add this $match stage to filter out unwanted enquirystatus and resonablestatus
            {
                $match: {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"]
                    },
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"]
                    }
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    designation: 1,
                    department: 1,
                    extrastatus: 1,
                    extradate: 1,
                    extratime: 1,
                    extramode: 1,
                    loginapprestriction: 1
                }
            }
        ]);
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});


exports.dynamicQueryUserController = async (req, res) => {
    try {
        const { aggregationPipeline } = req.body;

        const users = await User.aggregate(aggregationPipeline);

        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
};


exports.getAllUsersexceldataAssignbranch = catchAsyncErrors(async (req, res, next) => {

    const { assignbranch, month, year } = req.body;

    const query = {
        workmode: { $ne: "Internship" },

        // companyname: "VINITHA.NATESAN",
    }



    if (assignbranch.length > 0) {
        query.$or = assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit,
            workmode: { $ne: "Internship" },
            // companyname: "KANAGARAJ.RAJAMANI",
            enquirystatus: { $nin: ["Enquiry Purpose"] },

            // resonablestatus: {
            //     $nin: [
            //         "Not Joined",
            //         "Postponed",
            //         "Rejected",
            //         "Closed",
            //         "Releave Employee",
            //         "Absconded",
            //         "Hold",
            //         "Terminate"
            //     ],
            // }
        }))
    }

    let users, usersAll, depMonthSet;
    try {
        depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, fromdate: 1, todate: 1 });
        usersAll = await User.find(query,
            {

            }
        );
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];
        users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }
            let findfromtodate = depMonthSet.find(d => d.department === findUserDeprtment)
            let fromdate = findfromtodate ? findfromtodate.fromdate : ""
            let todate = findfromtodate ? findfromtodate.todate : ""
            if (item.reasondate == "" || (item.resonablestatus !== "" && new Date(item.reasondate) >= new Date(fromdate))) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    // if (!users || users.length === 0) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }
    return res.status(200).json({ count: users.length, users });
});


exports.getAllUsersexceldataByAssign = catchAsyncErrors(async (req, res, next) => {
    const { assignbranch } = req.body;

    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        resonablestatus: {
            $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
        },
    };
    let users;
    try {
        users = await User.find(
            query,
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                pfesistatus: 1,
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ count: users.length, users });
});


exports.getAllUsersAssignbranch = catchAsyncErrors(async (req, res, next) => {
    const { assignbranch } = req.body;

    // Create a query array for company and branch
    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: { $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"] }
    };


    let users;

    try {
        users = await User.find(query,

            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.getAllUsersCompanyname = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {

                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

exports.getIndividualUserLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {


        users = await User.findOne(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                _id: req.body._id

            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1
            }
        );

    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});



exports.getHierarchyBasedEmployeeStatus = catchAsyncErrors(
    async (req, res, next) => {
        let resultArray,
            user,
            result1,
            ans1D,
            i = 1,
            result2,
            result3,
            result4,
            result5,
            result6,
            dataCheck,
            userFilter,
            result,
            hierarchyFilter,
            answerDef,
            hierarchyFinal,
            hierarchy,
            hierarchyDefList,
            resultAccessFilter,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames;

        try {
            const { listpageaccessmode } = req.body;

            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

            result = await User.find(
                {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"
                        ? { reportingto: req.body.username }
                        : {}),
                },
                {
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extradate: 1,
                    loginUserStatus: 1, workstation: 1, workstationshortname: 1, workstationinput: 1,
                }
            );

            // Accordig to sector and list filter process
            hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
            userFilter = hierarchyFilter
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyDefList = await Hirerarchi.find();
            user = await User.find({ companyname: req.body.username });
            const userFilt = user.length > 0 && user[0].designation;
            const desiGroup = await Designation.find();
            let HierarchyFilt =
                req.body.sector === "all"
                    ? hierarchyDefList
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup)
                    : hierarchyFilter
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup);
            const DesifFilter = desiGroup.filter((data) =>
                HierarchyFilt.includes(data.group)
            );
            const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
            const SameDesigUser = HierarchyFilt.includes("All")
                ? true
                : userFilt === desigName;
            //Default Loading of List
            answerDef = hierarchyDefList
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? [].concat(...answerDef)
                        : []
                    : hierarchyFilter.length > 0
                        ? [].concat(...userFilter)
                        : [];

            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            //solo
            ans1D =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? hierarchyDefList.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : []
                    : hierarchyFilter.length > 0
                        ? hierarchyFilter.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : [];
            result1 =
                ans1D.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = ans1D.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );

                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];

            resulted = result1;

            //team
            let branches = [];
            hierarchySecond = await Hirerarchi.find();

            const subBranch =
                hierarchySecond.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) =>
                                hierarchyMap.includes(name)
                            )
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel =
                hierarchySecond.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => hierarchyMap.includes(name))
                    )
                    : [];

            result2 =
                answerFilterExcel.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                // If a match is found, inject the control property into the corresponding item in an1
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...subBranch);

            const ans =
                subBranch.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => subBranch.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel2 =
                subBranch.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => subBranch.includes(name))
                    )
                    : [];

            result3 =
                answerFilterExcel2.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel2.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...ans);

            const loop3 =
                ans.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => ans.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel3 =
                ans.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => ans.includes(name))
                    )
                    : [];

            result4 =
                answerFilterExcel3.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel3?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop3);

            const loop4 =
                loop3.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop3.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : [];
            const answerFilterExcel4 =
                loop3.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop3.includes(name))
                    )
                    : [];
            result5 =
                answerFilterExcel4.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel4?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop4);

            const loop5 =
                loop4.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop4.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel5 =
                loop4.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop4.includes(name))
                    )
                    : [];
            result6 =
                answerFilterExcel5.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel5?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop5);

            resultedTeam = [
                ...result2,
                ...result3,
                ...result4,
                ...result5,
                ...result6,
            ];
            //overall Teams List
            myallTotalNames = [...hierarchyMap, ...branches];
            overallMyallList = [...resulted, ...resultedTeam];


            let resultAccessFiltered =
                req.body.hierachy === "myhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resulted
                    : req.body.hierachy === "allhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? resultedTeam
                        : req.body.hierachy === "myallhierarchy" &&
                            (listpageaccessmode === "Hierarchy Based" ||
                                listpageaccessmode === "Overall")
                            ? overallMyallList
                            : result;

            resultAccessFilter = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];


        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }
        if (!result) {
            return next(new ErrorHandler("No data found!", 404));
        }
        return res.status(200).json({
            result,
            ans1D,
            result1,
            resulted,
            resultedTeam,
            branch,
            hierarchy,
            overallMyallList,
            resultAccessFilter,
            hierarchyFilter,
            user,
            dataCheck,
            userFilter,
            resultArray,
        });
    }
);


exports.getHierarchyBasedEmployeeStatusdefault = catchAsyncErrors(
    async (req, res, next) => {
        let resultArray,
            user,
            result1,
            ans1D,
            i = 1,
            result2,
            result3,
            result4,
            result5,
            result6,
            dataCheck,
            userFilter,
            result,
            hierarchyFilter,
            answerDef,
            hierarchyFinal,
            hierarchy,
            hierarchyDefList,
            resultAccessFilter,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames;

        try {
            const { listpageaccessmode } = req.body;

            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders", // The name of the collection to join with
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            } // Ensure 'teamcontrols' is an array or default to an empty array
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

            result = await User.find(
                {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"
                        ? { reportingto: req.body.username }
                        : {}),
                },
                {
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extradate: 1,
                    loginUserStatus: 1, workstation: 1, workstationshortname: 1, workstationinput: 1,
                }
            );

            // Accordig to sector and list filter process
            hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
            userFilter = hierarchyFilter
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyDefList = await Hirerarchi.find();
            user = await User.find({ companyname: req.body.username });
            const userFilt = user.length > 0 && user[0].designation;
            const desiGroup = await Designation.find();
            let HierarchyFilt =
                req.body.sector === "all"
                    ? hierarchyDefList
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup)
                    : hierarchyFilter
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup);
            const DesifFilter = desiGroup.filter((data) =>
                HierarchyFilt.includes(data.group)
            );
            const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
            const SameDesigUser = HierarchyFilt.includes("All")
                ? true
                : userFilt === desigName;
            //Default Loading of List
            answerDef = hierarchyDefList
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? [].concat(...answerDef)
                        : []
                    : hierarchyFilter.length > 0
                        ? [].concat(...userFilter)
                        : [];

            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            //solo
            ans1D =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? hierarchyDefList.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : []
                    : hierarchyFilter.length > 0
                        ? hierarchyFilter.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : [];
            result1 =
                ans1D.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = ans1D.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );

                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];

            resulted = result1;

            //team
            let branches = [];
            hierarchySecond = await Hirerarchi.find();

            const subBranch =
                hierarchySecond.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) =>
                                hierarchyMap.includes(name)
                            )
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel =
                hierarchySecond.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => hierarchyMap.includes(name))
                    )
                    : [];

            result2 =
                answerFilterExcel.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                // If a match is found, inject the control property into the corresponding item in an1
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...subBranch);

            const ans =
                subBranch.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => subBranch.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel2 =
                subBranch.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => subBranch.includes(name))
                    )
                    : [];

            result3 =
                answerFilterExcel2.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel2.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...ans);

            const loop3 =
                ans.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => ans.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel3 =
                ans.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => ans.includes(name))
                    )
                    : [];

            result4 =
                answerFilterExcel3.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel3?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop3);

            const loop4 =
                loop3.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop3.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : [];
            const answerFilterExcel4 =
                loop3.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop3.includes(name))
                    )
                    : [];
            result5 =
                answerFilterExcel4.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel4?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop4);

            const loop5 =
                loop4.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop4.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel5 =
                loop4.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop4.includes(name))
                    )
                    : [];
            result6 =
                answerFilterExcel5.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel5?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop5);

            resultedTeam = [
                ...result2,
                ...result3,
                ...result4,
                ...result5,
                ...result6,
            ];
            //overall Teams List
            myallTotalNames = [...hierarchyMap, ...branches];
            overallMyallList = [...resulted, ...resultedTeam];



            let resultAccessFiltered = req.body.hierachy === "myhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||
                    listpageaccessmode === "Overall")
                ? resulted
                : req.body.hierachy === "allhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resultedTeam
                    : req.body.hierachy === "myallhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? overallMyallList
                        : result;


            resultAccessFilter = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }
        if (!result) {
            return next(new ErrorHandler("No data found!", 404));
        }
        return res.status(200).json({
            result,
            ans1D,
            result1,
            resulted,
            resultedTeam,
            branch,
            hierarchy,
            overallMyallList,
            resultAccessFilter,
            hierarchyFilter,
            user,
            dataCheck,
            userFilter,
            resultArray,
        });
    }
);


exports.getAllUsersnewFilter = catchAsyncErrors(async (req, res, next) => {

    const { companyname, branchname, unitname, teamname, employeename } = req.body;

    let users;
    const filter = {

        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        resonablestatus: {
            $nin: [
                "Not Joined",
                "Postponed",
                "Rejected",
                "Closed",
                "Releave Employee",
                "Absconded",
                "Hold",
                "Terminate",
            ],
        },

        ...(companyname && Array.isArray(companyname) && companyname.length > 0 ? { company: { $in: companyname } } : companyname ? { company: companyname } : {}),
        ...(branchname && Array.isArray(branchname) && branchname.length > 0 ? { branch: { $in: branchname } } : {}),
        ...(unitname && Array.isArray(unitname) && unitname.length > 0 ? { unit: { $in: unitname } } : {}),
        ...(teamname && Array.isArray(teamname) && teamname.length > 0 ? { team: { $in: teamname } } : {}),
        ...(employeename && Array.isArray(employeename) && employeename.length > 0 ? { companyname: { $in: employeename } } : {}),

    }

    try {
        users = await User.find(filter);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


// get All user => /api/users
exports.getAllUsersWithXEmployee = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                departmentlog: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllNotInEmployees = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});


exports.deleteUsersShiftAllot = catchAsyncErrors(async (req, res, next) => {
    const { outerId, innerId } = req.body;
    try {
        // Find the user and remove the shiftallot object with the matching innerId
        const user = await User.findOneAndUpdate(
            { _id: outerId },
            {
                $pull: { shiftallot: { _id: innerId } }
            },
            { new: true } // Return the updated document
        );
        if (!user) {
            return next(new ErrorHandler("Data not found!", 404));
        }
        return res.status(200).json({ message: "Deleted successfully" });
    } catch (error) {
        return next(new ErrorHandler(error.message, 500));
    }
});


exports.employeeCodeAutogenerate = async (req, res) => {
    try {
        const { company, branch, doj, branchcode } = req.body;
        // Extract date in YYMMDD format
        const formattedDate = new Date(doj);
        const year = String(formattedDate.getFullYear()).slice(-2); // last two digits of year
        const month = String(formattedDate.getMonth() + 1).padStart(2, "0"); // zero-padded month
        const day = String(formattedDate.getDate()).padStart(2, "0"); // zero-padded day
        const dateString = `${year}${month}${day}`;

        // Get SettingsCode for the specific branch and company
        let overallsettings = await AdminOverAllSettings.findOne().sort({
            createdAt: -1,
        });
        let SettingsCode = overallsettings?.todos?.find(
            (data) => data?.company === company && data?.branch?.includes(branch)
        )?.empcodedigits;
        // Fetch the last employee based on branch and company with certain status and empcode starting with branchcode
        const users = await User.aggregate([
            {
                $match: {
                    branch,
                    company,
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    wordcheck: { $eq: false },
                    workmode: { $ne: "Internship" },
                    empcode: { $regex: `^${branchcode.toUpperCase()}` }, // Match empcode starting with branchcode + dateString
                },
            },
            {
                $addFields: {
                    numericPart: {
                        $toInt: { $substr: ["$empcode", 8, -1] }, // Extract the numeric part after first 8 characters
                    },
                },
            },
            {
                $sort: { numericPart: -1 }, // Sort by numeric part in descending order to get the greatest one
            },
            {
                $limit: 1, // Take the employee with the highest numeric part
            },
            {
                $project: {
                    empcode: 1,
                    numericPart: 1, // include numericPart in the projection
                },
            },
        ]);
        // New employee code logic
        let newEmployeeCode;
        const settingsNumericPart = parseInt(SettingsCode, 10); // Parse SettingsCode

        if (users.length > 0) {
            // If employees exist, extract the last numeric portion of the empcode
            const lastEmployeeNumericPart = users[0].numericPart;

            // Determine if we should use SettingsCode or last employee's numeric part
            if (
                settingsNumericPart - 1 >= lastEmployeeNumericPart &&
                overallsettings?.empdigits
            ) {
                // If SettingsCode is greater, increment from SettingsCode - 1
                const nextCode = String(settingsNumericPart + 1).padStart(
                    users[0].empcode.slice(8).length,
                    "0"
                ); // Ensure same length
                newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${nextCode}`;
            } else {
                // Otherwise, increment from the last employee's numeric part
                const nextCode = String(lastEmployeeNumericPart + 1).padStart(
                    users[0].empcode.slice(8).length,
                    "0"
                ); // Ensure same length
                newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${nextCode}`;
            }
        } else {
            // If no employees exist, start with SettingsCode or default to 001
            const startCode = settingsNumericPart ? settingsNumericPart : "001";
            newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${startCode}`;
        }

        return res.status(200).json({
            employeeCode: newEmployeeCode,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
};

exports.getFilteredUserForShiftAdjusment = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {

        users = await User.find(
            {
                companyname: { $in: req.body.employee },
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

exports.getAllEmployeesForAttendanceFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { company, branch, unit, team, employee, department } = req.body;
    try {

        let query = {
            company: { $in: company },
            branch: { $in: branch },
            unit: { $in: unit },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        // If team is provided, include the team in the condition
        if (team && team.length > 0) {
            query.$and = [
                { team: { $in: team } },
                {
                    $or: [
                        {
                            departmentlog: {
                                $elemMatch: {
                                    department: { $in: department }
                                }
                            }
                        },
                        { companyname: { $in: employee } }
                    ]
                }
            ];
        } else {
            // If team is not provided, just use department or employee condition
            query.$or = [
                {
                    departmentlog: {
                        $elemMatch: {
                            department: { $in: department }
                        }
                    }
                },
                { companyname: { $in: employee } }
            ];
        }

        users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            // shift: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

//SEPERATE FUNCTION FORACCESSBRANCHLIST IN ATTENDANCE OVERALL INDIVIDUAL
exports.getAllEmployeesForAttendanceFilterForAccessbranchWiseList = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { assignbranch } = req.body;
    try {

        const branchFilter = assignbranch.map(branchObj => ({
            company: branchObj.company,
            branch: branchObj.branch,
            unit: branchObj.unit
        }));

        const filterQuery = {
            $or: branchFilter,
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        // Run the query
        users = await User.find(filterQuery, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // Check if users were found
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    // Return found users
    return res.status(200).json({ users });
});

exports.getAllUsersnewFilterMissingfield = catchAsyncErrors(
    async (req, res, next) => {
        const {
            companyname,
            branchname,
            unitname,
            teamname,
            employeename,
            departmentname,
        } = req.body;
        let users;
        const filter = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },

            ...(companyname && Array.isArray(companyname) && companyname.length > 0
                ? { company: { $in: companyname } }
                : {}),
            ...(branchname && Array.isArray(branchname) && branchname.length > 0
                ? { branch: { $in: branchname } }
                : {}),
            ...(unitname && Array.isArray(unitname) && unitname.length > 0
                ? { unit: { $in: unitname } }
                : {}),
            ...(teamname && Array.isArray(teamname) && teamname.length > 0
                ? { team: { $in: teamname } }
                : {}),
            ...(employeename && Array.isArray(employeename) && employeename.length > 0
                ? { companyname: { $in: employeename } }
                : {}),
            ...(departmentname &&
                Array.isArray(departmentname) &&
                departmentname.length > 0
                ? { department: { $in: departmentname } }
                : {}),
        };
        try {
            users = await User.find(filter);
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }

        if (!users) {
            return next(new ErrorHandler("Users not found", 400));
        }

        if (!Array.isArray(users) || users.length === 0) {
            return res.status(400).json({ message: "No users provided" });
        }

        const results = await Promise.all(
            users.map(async (user) => {
                const document = await User.findById(user._id).lean();

                if (!document) {
                    return {
                        _id: user._id,
                        message: "Document not found",
                        emptyFields: [],
                    };
                }

                const [employeedocument, assignbranch] = await Promise.all([
                    EmployeeDocuments.findOne({
                        commonid: document._id.toString(),
                    }).lean(),
                    AssignBranch.findOne({
                        employee: document.companyname,
                        employeecode: document.empcode,
                    }).lean(),
                ]);

                const emptyFields = new Set();

                const checkEmpty = (obj, prefix = "") => {
                    for (const key in obj) {
                        const value = obj[key];

                        if (Array.isArray(value) && key === "workstation") {
                            if (value.length === 0) {
                                emptyFields.add("workstationprimary");
                                emptyFields.add("workstationsecondary");
                            } else {
                                if (value.includes("Please Select Primary Work Station")) {
                                    emptyFields.add("workstationprimary");
                                }
                                if (value.length === 1) {
                                    emptyFields.add("workstationsecondary");
                                }
                            }
                        } else if (Array.isArray(value) && key === "boardingLog") {
                            if (value.length === 0) {
                                emptyFields.add("weekoff");
                            } else if (value.length > 0) {
                                if (value[value?.length - 1]?.weekoff?.length === 0) {
                                    emptyFields.add("weekoff");
                                }
                            }
                        } else if (
                            value === "" ||
                            value === "undefined" ||
                            value === undefined ||
                            (Array.isArray(value) && value.length === 0) ||
                            (typeof value === "number" && value === 0)
                        ) {
                            emptyFields.add(prefix + key);
                        } else if (
                            typeof value === "object" &&
                            value !== null &&
                            !Array.isArray(value)
                        ) {
                            checkEmpty(value, `${prefix}${key}.`);
                        }
                    }

                    if (obj.workmode !== "Internship") {
                        emptyFields.delete(`${prefix}intStartDate`);
                        emptyFields.delete(`${prefix}intEndDate`);
                        emptyFields.delete(`${prefix}modeOfInt`);
                        emptyFields.delete(`${prefix}intDuration`);
                    }
                    if (obj.maritalstatus !== "Married") {
                        emptyFields.delete(`${prefix}dom`);
                    }
                };

                checkEmpty(document);

                if (document.panstatus === "Have PAN") {
                    emptyFields.delete("panrefno");
                }

                if (document.panstatus === "Applied") {
                    emptyFields.delete("panno");
                }

                if (document.panstatus === "Yet to Apply") {
                    emptyFields.delete("panno");
                    emptyFields.delete("panrefno");
                }

                if (!employeedocument) {
                    emptyFields.add("profileimage");
                    emptyFields.add("employeedocuments");
                } else {
                    if (!employeedocument.profileimage) emptyFields.add("profileimage");
                    if (employeedocument.files.length === 0) {
                        emptyFields.add("employeedocuments");
                    }
                }

                if (!assignbranch) {
                    emptyFields.add("assignbranch");
                }

                const result = {
                    ...document,
                    employeedocument,
                    assignbranch,
                    emptyfields: [...emptyFields],
                };

                // trimStringFields(result);

                return result;
            })
        );
        res.status(200).json({ count: results.length, results });
    }
);


exports.getAllUsersPostergenerate = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                companyname: 1,
                team: 1,
                legalname: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.duplicateFaceDetector = catchAsyncErrors(async (req, res, next) => {
    try {
        const { faceDescriptor, id } = req.body;

        // Ensure faceDescriptor is an array of numbers
        if (
            !Array.isArray(faceDescriptor) ||
            !faceDescriptor.every((num) => typeof num === "number")
        ) {
            throw new Error("Invalid face descriptor format.");
        }

        // Fetch all user face descriptors from MongoDB
        const allUsers = await User.find(
            { _id: { $ne: id } },
            { faceDescriptor: 1 }
        ).lean();
        let authenticated = false;

        // Compare face descriptors
        for (const user of allUsers) {
            const storedDescriptor = user?.faceDescriptor;

            if (
                !Array.isArray(storedDescriptor) ||
                storedDescriptor.length !== faceDescriptor.length
            ) {
                continue; // Skip mismatched descriptors
            }

            const distance = faceapi.euclideanDistance(
                faceDescriptor,
                storedDescriptor
            );

            if (distance < 0.4) {
                authenticated = true;
                break; // Exit loop once fond
            }
        }

        return res.status(200).json({ matchfound: authenticated });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

//Hierarchy- Hierarchy Based Employee Status
exports.getHierarchyBasedEmployeeWorkstationhira = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        myallTotalNames;

    try {

        let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);
        let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        result = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1, loginUserStatus: 1,
            }
        );
        result = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1, loginUserStatus: 1
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === "all" ?
            hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) :
            hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes("All") ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === "all" ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];


        //solo
        ans1D = req.body.sector === "all" ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;


        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = [...hierarchyMap, ...branches];
        overallMyallList = [...resulted, ...resultedTeam];

        let resultAccessFiltered = req.body.hierachy === "myhierarchy" ? resulted : req.body.hierachy === "allhierarchy" ? resultedTeam : overallMyallList;

        resultAccessFilter = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!result) {
        return next(new ErrorHandler("No data found!", 404));
    }
    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
    });
});


exports.getHierarchyBasedEmployeeWorkstation = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        myallTotalNames;

    try {

        let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);
        let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        result = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1, loginUserStatus: 1,
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === "all" ?
            hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) :
            hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes("All") ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === "all" ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];


        //solo
        ans1D = req.body.sector === "all" ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;


        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + "-" + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = [...hierarchyMap, ...branches];
        overallMyallList = [...resulted, ...resultedTeam];

        let resultAccessFiltered = req.body.hierachy === "myhierarchy" ? resulted : req.body.hierachy === "allhierarchy" ? resultedTeam : overallMyallList;
        resultAccessFilter = restrictList?.length > 0 ? resultAccessFiltered?.filter(data => restrictList?.includes(data?.companyname)) : [];
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!result) {
        return next(new ErrorHandler("No data found!", 404));
    }
    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
    });
});

exports.getUserWithStatusHomeCount = catchAsyncErrors(async (req, res, next) => {
    let allusers;
    try {
        const { pageName, assignbranch } = req.body;

        const branchFilter = assignbranch.map((branchObj) => ({
            branch: branchObj.branch,
            company: branchObj.company,
            unit: branchObj.unit
        }));

        let Query = { $or: branchFilter };

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        // Fetch relevant attendance records for the past 3 days
        let attendance = await Attendance.find(
            {
                date: {
                    $in: pastThreeAttendaysDays,
                },
            },
            { date: 1, userid: 1 }
        ).lean();
        // Fetch relevant leave records
        let allLeaveStatus = await ApplyLeave.find(
            {
                date: { $in: pastThreeLeaveDays },
            },
            { employeename: 1, employeeid: 1, date: 1 }
        ).lean();

        let holidays = await Holiday.find(
            {
                date: { $in: pastThreeDaysISO },
            },
            { date: 1, employee: 1 }
        ).lean();

        let noticeperiodstatus = await Noticeperiod.find(
            {},
            {
                empname: 1,
                empcode: 1,
                status: 1,
                rejectStatus: 1,
                cancelstatus: 1,
                approvedStatus: 1,
                continuestatus: 1,
                recheckStatus: 1,
            }
        ).lean();

        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        const leaveMap = allLeaveStatus.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");
            item.employee.forEach((employee) => {
                if (!acc[employee]) {
                    acc[employee] = [];
                }
                acc[employee].push(date);
            });
            return acc;
        }, {});



        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            ...Query,
        };

        if (pageName === "Employee") {
            filterQuery.workmode = {
                $ne: "Internship",
            };
        } else if (pageName === "Internship") {
            filterQuery.workmode = {
                $eq: "Internship",
            };
        }
        // Use $or to filter incomes that match any of the branch, company, and unit combinations
        // filterQuery = {
        //     $and: [
        //         filterQuery, // Retain previous conditions
        //         { $or: branchFilter } // Apply branch filtering
        //     ]
        // };
        allusers = await User.countDocuments(filterQuery);
    } catch (err) {
        console.log(err, "err")
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!finalArray) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({
        // count: finalArray.length,
        // allusers: finalArray,
        allusers
    });
});

exports.getAllUserHomeCountReleive = catchAsyncErrors(async (req, res, next) => {
    let user;

    try {
        const branchFilter = req.body.assignbranch.map((branchObj) => ({
            branch: branchObj.branch,
            company: branchObj.company,
            unit: branchObj.unit
        }));

        let Query = { $or: branchFilter };

        let filterQuery = {
            resonablestatus: { $in: ['Absconded', 'Not Joined', 'Hold', 'Terminate', 'Postponed', 'Rejected', 'Closed', 'Releave Employee'] },
            workmode: { $ne: "Internship" },
            ...Query
        }
        user = await User.countDocuments(filterQuery);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!usersstatus) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({ user });
});

exports.getAllUserHomeCountNotClockIn = catchAsyncErrors(async (req, res, next) => {
    let user;

    try {
        const currentDate = new Date();
        const formattedDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
        user = await Attendance.countDocuments({ date: formattedDate }, {});
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!usersstatus) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({ user });
});

exports.getAllUserHomeCountNotClockInList = catchAsyncErrors(async (req, res, next) => {
    let user, attendance, applyleaves, filtered;

    try {
        const currentDate = new Date();
        const formattedDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
        const formattedDateApply = `${currentDate.getDate().toString().padStart(2, '0')}/${(currentDate.getMonth() + 1).toString().padStart(2, '0')}/${currentDate.getFullYear()}`;
        console.log(formattedDateApply)
        attendance = await Attendance.find({ date: formattedDate }, { username: 1, userid: 1 });

        applyleaves = await ApplyLeave.find({ status: "Approved", date: { $in: formattedDateApply } }, { employeename: 1 })
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
        };

        filterQuery.workmode = {
            $ne: "Internship",
        };



        let alluser = await User.find(filterQuery, { company: 1, branch: 1, unit: 1, team: 1, department: 1, username: 1, companyname: 1, empcode: 1, shifttiming: 1 });


        // console.log(alluser.length, "allusercount")



        let finalfiltered = alluser.filter(
            (ur) =>
                !attendance.some((oldItem) => {
                    return ur.username === oldItem.username && ur._id == oldItem.userid
                })
        );
        console.log(applyleaves, "finalfiltered")

        filtered = finalfiltered.filter(
            (ur) =>
                !applyleaves.some((oldItem) => {
                    return ur.companyname === oldItem.employeename
                })
        );

    } catch (err) {
        console.log(err, "eroror")
        return next(new ErrorHandler("Records not found!", 404));
    }
    return res.status(200).json({ filtered });
});


// update user by id => /api/user/:id
exports.updatePCUsername = catchAsyncErrors(async (req, res, next) => {
    try {
        const id = req.params.id;

        // Update the user by ID and return the updated user object
        const upuserone = await User.findByIdAndUpdate(id, req.body, { new: true });

        if (!upuserone) {
            return next(new ErrorHandler("User not found", 404));
        }

        // Return the relevant fields in the response
        return res.status(200).json({
            message: "Updated successfully!",
            userDatas: {
                company: upuserone?.company,
                branch: upuserone?.branch,
                unit: upuserone?.unit,
                team: upuserone?.team,
                companyname: upuserone?.companyname,
                empcode: upuserone?.empcode,
                department: upuserone?.department
            }
        });
    } catch (err) {
        return next(new ErrorHandler("An error occurred", 500));
    }
});

exports.getAlluserDataFilterLongAbsendHierarchyHome = catchAsyncErrors(
    async (req, res) => {
        try {
            let filteredUsers, filterQuerys;
            let hierarchy,
                tertiaryhierarchyfinal,
                hierarchyfilter,
                filteredoverall,
                reportingtobaseduser,
                hierarchyfilter1,
                hierarchyfilter2,
                hierarchySecond,
                hierarchyMap,
                resulted,
                resultedTeam,
                hierarchyFinal,
                hierarchyDefault;
            const {
                company,
                branch,
                unit,
                team,
                filterin,
                module,
                submodule,
                mainpage,
                subpage,
                subsubpage,
                status,
                listpageaccessmode,
            } = req.body;
            const today = moment();
            const pastThreeDaysISO = [
                today.clone().format("YYYY-MM-DD"),
                today.clone().subtract(1, "days").format("YYYY-MM-DD"),
                today.clone().subtract(2, "days").format("YYYY-MM-DD"),
                today.clone().subtract(3, "days").format("YYYY-MM-DD"),
            ];
            let filterQuery = {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                doj: {
                    $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
                },
                ...(listpageaccessmode === "Reporting to Based"
                    ? { reportingto: req.body.username }
                    : {}),
            };

            if (Array.isArray(company) && company.length > 0) {
                filterQuery.company = { $in: company };
            }

            if (Array.isArray(branch) && branch.length > 0) {
                filterQuery.branch = { $in: branch };
            }

            if (Array.isArray(unit) && unit.length > 0) {
                filterQuery.unit = { $in: unit };
            }

            if (Array.isArray(team) && team.length > 0) {
                filterQuery.team = { $in: team };
            }

            const removeEmptyArrays = (obj) => {
                return Object.fromEntries(
                    Object.entries(obj).filter(
                        ([key, value]) => !Array.isArray(value) || value.length > 0
                    )
                );
            };

            filterQuerys = removeEmptyArrays(filterQuery);
            let resulting = await User.find(filterQuerys, {
                resonablestatus: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                empcode: 1,
                companyname: 1,
                longleaveabsentaprooveddate: 1,
                boardingLog: 1,
                attendancemode: 1, // Include boardingLog in the result

                username: 1,
                originalpassword: 1,
                firstname: 1,
                lastname: 1,
                aadhar: 1,
                panno: 1,
                dob: 1,
                pstreet: 1,
                pcity: 1,
                ppincode: 1,
                pstate: 1,
                doj: 1,
                pcountry: 1,
            }).lean();


            //my + all hierarchy list dropdown

            if (
                (req.body.hierachy === "My + All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                filteredoverall = resulting
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            if (listpageaccessmode === "Reporting to Based") {
                reportingtobaseduser = resulting.map((userObj) => {
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: "",
                        control: "",
                    };
                });
            }

            filteredUsers =
                req.body.hierachy === "My + All Hierarchy List" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? filteredoverall
                    : reportingtobaseduser;

            const currentDateChecklist = moment().format("DD-MM-YYYY");
            const pastThreeAttendaysDays = [
                today.clone().format("DD-MM-YYYY"),
                today.clone().subtract(1, "days").format("DD-MM-YYYY"),
                today.clone().subtract(2, "days").format("DD-MM-YYYY"),
                today.clone().subtract(3, "days").format("DD-MM-YYYY"),
            ];

            const pastThreeLeaveDays = [
                today.clone().format("DD/MM/YYYY"),
                today.clone().subtract(1, "days").format("DD/MM/YYYY"),
                today.clone().subtract(2, "days").format("DD/MM/YYYY"),
                today.clone().subtract(3, "days").format("DD/MM/YYYY"),
            ];

            const [attendance, allLeaveStatus, holidays, checklistData] =
                await Promise.all([
                    Attendance.find(
                        {
                            date: {
                                $in: pastThreeAttendaysDays,
                            },
                        },
                        { date: 1, userid: 1 }
                    ).lean(),

                    ApplyLeave.find(
                        {
                            date: { $in: pastThreeLeaveDays },
                        },
                        { employeename: 1, employeeid: 1, date: 1 }
                    ).lean(),

                    Holiday.find(
                        {
                            date: { $in: pastThreeDaysISO },
                        },
                        {
                            date: 1,
                            employee: 1,
                            company: 1,
                            applicablefor: 1,
                            unit: 1,
                            team: 1,
                        }
                    ).lean(),
                    MyCheckList.find({
                        module,
                        submodule,
                        mainpage,
                        subpage,
                        subsubpage,
                        // status: { $ne: "completed" },
                        longleaveabsentaprooveddatechecklist: {
                            $in: [currentDateChecklist],
                        },
                    }),
                ]);

            const attendanceMap = attendance.reduce((acc, item) => {
                const userId = item.userid.toString();
                const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
                if (!acc[userId]) {
                    acc[userId] = [];
                }
                acc[userId].push(date);
                return acc;
            }, {});

            const leaveMap = allLeaveStatus.reduce((acc, item) => {
                const userKey = `${item.employeeid}_${item.employeename}`;
                const leaveDates = item.date.map((date) =>
                    moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
                );
                if (!acc[userKey]) {
                    acc[userKey] = [];
                }
                acc[userKey].push(...leaveDates);
                return acc;
            }, {});

            const employeeMatchesUser = (user, holiday) => {
                return (
                    holiday.company.includes(user.company) &&
                    holiday.applicablefor.includes(user.branch) &&
                    holiday.unit.includes(user.unit) &&
                    holiday.team.includes(user.team) &&
                    (holiday.employee.includes(user.companyname) ||
                        holiday.employee.includes("ALL"))
                );
            };

            const holidayMap = holidays.reduce((acc, item) => {
                const date = moment(item.date).format("DD/MM/YYYY");

                filteredUsers.forEach((user) => {
                    if (employeeMatchesUser(user, item)) {
                        if (!acc[user.empcode]) {
                            acc[user.empcode] = [];
                        }
                        acc[user.empcode].push(date);
                    }
                });

                return acc;
            }, {});

            const checkStatusForPast3Days = (
                userId,
                empcode,
                employeename,
                weekOffDays
            ) => {
                const userKey = `${empcode}_${employeename}`;
                let absentDays = 0;
                let leaveDays = 0;
                let holidayDays = 0;

                for (let date of pastThreeLeaveDays) {
                    // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                    // if (weekOffDays.includes(dayOfWeek)) {
                    //   continue; // Skip week off days
                    // }

                    if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                        continue; // User was present on this date
                    } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                        leaveDays++; // User was on leave on this date
                    } else if (
                        holidayMap[empcode] &&
                        holidayMap[empcode].includes(date)
                    ) {
                        holidayDays++; // Holiday on this date
                    } else {
                        absentDays++; // User was absent on this date
                    }
                }

                let status = null;
                if (absentDays >= 4) {
                    status = "Long Absent";
                } else if (leaveDays >= 4) {
                    status = "Long Leave";
                }

                return { status, absentDays, leaveDays, holidayDays };
            };

            const determineStatus = (attendanceStatus) => {
                return attendanceStatus ? attendanceStatus : null;
            };

            const enrichedLeaveAttendanceUsers = filteredUsers
                ?.map((user) => {
                    const userId = user._id.toString();

                    const checklistItem = checklistData.find(
                        (item) => item.commonid === userId
                    );
                    let weekOffDays = [];
                    if (user.boardingLog && user.boardingLog.length > 0) {
                        const lastBoardingLog =
                            user.boardingLog[user.boardingLog.length - 1];
                        weekOffDays = lastBoardingLog.weekoff || [];
                    }

                    const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                        userId,
                        user.empcode,
                        user.companyname,
                        weekOffDays
                    );

                    return {
                        ...user,
                        attendanceStatus: !!status,
                        noticePeriodStatus: false,
                        livestatus: status ? false : null,
                        userstatus: determineStatus(status),
                        longAbsentCount: absentDays, // Long absent count
                        longLeaveCount: leaveDays, // Long leave count
                        checklistassigned: !!checklistItem,
                        longleaveabsentaprooveddatechecklist:
                            checklistItem?.longleaveabsentaprooveddatechecklist,
                    };
                })
                .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status

            return res.status(200).json({
                filterallDatauser: enrichedLeaveAttendanceUsers.length,
                tableName: filterin,

            });
        } catch (err) {
            return res.status(500).json({ error: "Internal server error" });
        }
    }
);

exports.getAllUserTotalShiftDaysHome = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { page, pageSize,
    } = req.body;

    try {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1; // Months are zero-based, so add 1
        const currentYear = currentDate.getFullYear();

        const ismonth = currentMonth;
        const isyear = currentYear

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear
        }
        let [usersAll, depMonthSet, controlcriteria, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                }, {}
            ).limit(6),


            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const resultDateArray = depMonthSet.reduce((acc, curr) => {
            if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                acc.fromdate = curr.fromdate;
            }
            // Compare and update the latest todate
            if (new Date(curr.todate) > new Date(acc.todate)) {
                acc.todate = curr.todate;
            }
            return acc;
        }, {
            fromdate: depMonthSet[0].fromdate,
            todate: depMonthSet[0].todate
        });

        function formatDate(dateString) {
            const [day, month, year] = dateString.split("-");
            return `${year}-${month}-${day}`;
        }

        let attFromDate = (resultDateArray.fromdate)
        let attToDate = (resultDateArray.todate)

        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];

        let users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            // if (department.includes(findUserDeprtment)) {
            return {
                ...item._doc, // Use _doc to avoid including Mongoose metadata
                department: findUserDeprtment,
            };

            // }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);
        const [attendance, allLeaveStatus, permission, leavecriterias] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, createdAt: { $gte: attFromDate, $lte: attToDate } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 }),
            Leavecriteria.find({ leavetype: "No Call/No Show" }, { mode: 1, company: 1, branch: 1, unit: 1, team: 1, employee: 1, designation: 1, department: 1, leavetype: 1, tookleave: 1 }),

        ])
        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;


        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];


            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = item.doj?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);


                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = item.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find(item => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find(item => item && item.todate === date.formattedDate);
                const filterBoardingLog = item.boardingLog && item.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });
                let attendanceFiltered = attendance.filter(d => d.username === item.username)


                const depMonthSetFiltered = depMonthSet.filter(d => d.department === item.department)
                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: item.doj,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered),
                        date.shiftMode,
                    ),
                    // clockinstatus: checkClockInStatus(
                    //     checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                    //     getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    //     graceTime, allLeaveStatus, holidays,
                    //     checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                    //     earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                    //     checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                    //     date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), leavecriterias, date.weekNumberInMonth, date.dayName, (relevantDepLogEntry && relevantDepLogEntry?.department), (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    // ),
                    // clockoutstatus: checkClockOutStatus(
                    //     checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                    //     checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                    //     getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    //     clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    //     allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                    //     earlyclockout, beforeearlyclockout,
                    //     checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    //     leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), leavecriterias, date.weekNumberInMonth, date.dayName, (relevantDepLogEntry && relevantDepLogEntry?.department), (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    // ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime,
                        allLeaveStatus,
                        holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        item.branch,
                        item.empcode,
                        item.company,
                        date.formattedDate,
                        item.unit,
                        item.team,
                        item.companyname,
                        earlyclockin,
                        lateclockin,
                        afterlateclockin,
                        leavetype,
                        permission,
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode),
                        date.shiftMode,
                        checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        leavecriterias,
                        date.weekNumberInMonth,
                        date.dayName,
                        item.department,
                        item.designation
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode),
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        allLeaveStatus,
                        holidays,
                        item.branch,
                        item.empcode,
                        item.company,
                        date.formattedDate,
                        item.unit,
                        item.team,
                        item.companyname,
                        onclockout,
                        earlyclockout,
                        beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        leavetype,
                        permission,
                        date.shiftMode,
                        checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        leavecriterias,
                        date.weekNumberInMonth,
                        date.dayName,
                        item.department,
                        item.designation
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.getAllUsersexceldataAssignbranchHome = catchAsyncErrors(async (req, res, next) => {


    const query = {
        workmode: { $ne: "Internship" },
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: {
            $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
        },
        // companyname: "VINITHA.NATESAN",
    }
    const currentDate = new Date();
    const currentMonth = currentDate.toLocaleString('default', { month: 'long' });
    // Months are zero-based, so add 1
    const currentYear = currentDate.getFullYear();

    const month = currentMonth;
    const year = currentYear;

    let users, usersAll, depMonthSet;
    try {
        depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, fromdate: 1, todate: 1 });

        usersAll = await User.find(query,
            {

            }
        ).limit(6);
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];
        users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }
            let findfromtodate = depMonthSet.find(d => d.department === findUserDeprtment)
            let fromdate = findfromtodate ? findfromtodate.fromdate : ""
            let todate = findfromtodate ? findfromtodate.todate : ""
            if (item.reasondate == "" || (item.resonablestatus !== "" && new Date(item.reasondate) >= new Date(fromdate))) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);



    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    // if (!users || users.length === 0) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }
    return res.status(200).json({ users });
});


exports.getAllShiftToUserOverAllBulkDelete = catchAsyncErrors(
    async (req, res, next) => {
        let teams,
            result,
            noticeperiodapply,
            minimumpoints,
            loan,
            myverification,
            draft,
            user,
            count;

        let id = req.body.id;
        try {
            usershift = await ShiftGrouping.find();

            const usershifttype = usershift?.filter((data) =>
                id?.includes(data._id?.toString())
            );

            [
                user,
            ] = await Promise.all([
                User.find(),
            ]);


            const usershiftType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            answers.shift?.includes(sub.shifttiming)
                    )
                )
                ?.map((data) => data._id?.toString());

            const usershiftBordinglogType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            sub.boardingLog?.some((item) => answers.shift?.includes(item?.shifttiming))
                    )
                )
                ?.map((data) => data._id?.toString());

            const usershiftshiftallotType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            sub.shiftallot?.some((item) => answers.shift?.includes(item?.shifttiming))
                    )
                )
                ?.map((data) => data._id?.toString());


            const usershiftBordinglogTodoType = usershifttype
                .filter((answers) =>
                    user.some((sub) =>
                        sub.boardingLog?.some((item) =>
                            item?.todo?.some((todoItem) =>
                                answers.shift?.includes(todoItem?.shifttiming)
                            )
                        )
                    )
                )
                ?.map((data) => data._id?.toString());



            const duplicateId = [
                ...usershiftType,
                ...usershiftBordinglogType,
                ...usershiftshiftallotType,
                ...usershiftBordinglogTodoType,
            ];
            result = id?.filter((data) => !duplicateId?.includes(data));
            count = id?.filter((data) => duplicateId?.includes(data))?.length;

        } catch (err) {
            return next(
                new ErrorHandler("Recors Not Found", 500)
            );
        }

        return res.status(200).json({
            count: count,
            result,
        });
    }
);



exports.getAllTeamShiftHierarchyList = catchAsyncErrors(
    async (req, res, next) => {
        let result,
            reportingtobaseduser,
            clientuserid,
            hierarchy,
            resultAccessFilter,
            secondaryhierarchyfinal,
            tertiaryhierarchyfinal,
            primaryhierarchyfinal,
            hierarchyfilter,
            filteredoverall,
            primaryhierarchy,
            hierarchyfilter1,
            secondaryhierarchy,
            hierarchyfilter2,
            tertiaryhierarchy,
            primaryhierarchyall,
            secondaryhierarchyall,
            tertiaryhierarchyall,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames,
            hierarchyFinal,
            hierarchyDefault,
            reportingusers, hierarchyfirstlevel;
        let resultAccessFilterHierarchy = [];
        let resultsectorother = []
        let filteredoverallsectorall = []

        // const vendorNames = req.body.vendor.map((vendor) => vendor.value);
        try {
            const { listpageaccessmode } = req.body;
            let clientidsmap;
            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]

            let finalDataRestrictList = []
            if (listpageaccessmode === "Reporting to Based") {
                let usersss = await User.find(
                    {
                        enquirystatus: {
                            $nin: ["Enquiry Purpose"],
                        },
                        resonablestatus: {
                            $nin: [
                                "Not Joined",
                                "Postponed",
                                "Rejected",
                                "Closed",
                                "Releave Employee",
                                "Absconded",
                                "Hold",
                                "Terminate",
                            ],
                        },
                        reportingto: req.body.username,
                    },
                    {
                        empcode: 1,
                        companyname: 1,
                    }
                ).lean();
                const companyNames = usersss.map((user) => user.companyname);
                let clientids = await ClientUserid.find(
                    {
                        // projectvendor: { $in: vendorNames },
                        empname: { $in: companyNames },
                    },
                    { userid: 1 }
                ).lean();
                clientidsmap = clientids.map((user) => user.userid);
            }

            let prodresult = await User.aggregate([
                {
                    $match: {
                        "shiftallot.adjstatus": "Adjustment",
                        ...(listpageaccessmode === "Reporting to Based"
                            ? { user: { $in: clientidsmap } }
                            : {})
                    }
                },
                {
                    $project: {
                        shiftallot: {
                            $filter: {
                                input: "$shiftallot",
                                as: "item",
                                cond: { $eq: ["$$item.adjstatus", "Adjustment"] } // Filter only matching `adjstatus`
                            }
                        }
                    }
                }
            ]);

            // clientuserid = await ClientUserid.find(
            //     { loginallotlog: { $exists: true, $ne: [] } },
            //     { empname: 1, userid: 1, loginallotlog: 1, projectvendor: 1 }
            // ).lean();

            result = prodresult.flatMap(d => d.shiftallot)
                .map((item) => {


                    return {
                        // company: item.company,
                        // branch: item.branch,
                        // unit: item.unit,
                        // team: item.team,
                        // companyname: item.username,
                        // empcode: item.empcode,
                        // adjchangereason: item.adjchangereason,
                        // adjapplydate: item.adjapplydate,
                        // adjustmenttype: item.adjustmenttype,
                        // adjstatus: item.adjstatus,
                        // removedondate: item.removedondate,
                        // userid: item.userid,
                        // selectedDate: item.selectedDate,
                        // selectedShifTime: item.selectedShifTime,
                        // pluseshift: item.pluseshift,
                        // adjchangeshiftime: item.adjchangeshiftime,
                        // todate: item.todate,
                        // adjdate: item.adjdate,
                        // id: item._id,
                        ...item,
                        companyname: item.username
                    };
                });
            // console.log(result, "rrrrr")
            // resultsectorother = result



            //myhierarchy dropdown
            if (
                req.body.hierachy === "myhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||
                    listpageaccessmode === "Overall")
            ) {
                hierarchy = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: req.body.sector,
                });
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,

                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDef.length > 0
                            ? [].concat(...answerDef)
                            : []
                        : hierarchy.length > 0
                            ? [].concat(...hierarchy.map((item) => item.employeename))
                            : [];

                hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];
                // console.log(hierarchyMap, "hierarchyMap")
                hierarchyfilter = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Primary",
                });
                primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0])
                    ? hierarchyfilter.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter1 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Secondary",
                });
                secondaryhierarchy = hierarchyfilter1.map(
                    (item) => item.employeename[0]
                )
                    ? hierarchyfilter1.map((item) => item.employeename[0])
                    : [];

                hierarchyfilter2 = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: "Tertiary",
                });
                tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0])
                    ? hierarchyfilter2.map((item) => item.employeename[0])
                    : [];

                resulted = result
                    .map((userObj) => {
                        const matchingHierarchy = hierarchyDefault.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            // branch: userObj.branch,
                            // unit: userObj.unit,
                            // team: userObj.team,
                            // empcode: userObj.empcode,
                            // adjchangereason: userObj.adjchangereason,
                            // adjapplydate: userObj.adjapplydate,
                            // adjustmenttype: userObj.adjustmenttype,
                            // adjstatus: userObj.adjstatus,

                            // removedondate: userObj.removedondate,
                            // userid: userObj.userid,
                            // selectedDate: userObj.selectedDate,
                            // selectedShifTime: userObj.selectedShifTime,
                            // pluseshift: userObj.pluseshift,
                            // adjchangeshiftime: userObj.adjchangeshiftime,
                            // todate: userObj.todate,
                            // adjdate: userObj.adjdate,
                            // _id: userObj.id,
                            level: matchingHierarchy ? matchingHierarchy.level : "",
                            control: matchingHierarchy ? matchingHierarchy.control : "",
                        };
                    }).filter((data) => hierarchyMap.includes(data.companyname));

                console.log(resulted, "result")
            }

            if (
                req.body.hierachy === "allhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||
                    listpageaccessmode === "Overall")
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );


                // let sectorFinal = req.body.sector == "all"
                //   ? ["Primary", "Secondary", "Tertiary"] : [req.body.sector]

                // hierarchyDefault = await Hirerarchi.find({
                //   supervisorchoose: req.body.username,
                //   level: { $in: sectorFinal },

                // });


                let sectorFinal = req.body.sector == "all"
                    ? ["Primary", "Secondary", "Tertiary"] : [req.body.sector]

                let FirstSuphierarchyDefaultLevel = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                }, { level: 1 });

                // console.log(FirstSuphierarchyDefaultLevel, "FirstSuphierarchyDefaultLevel")

                FirstSuphierarchyDefaultLevel = req.body.sector == "all" ? FirstSuphierarchyDefaultLevel.map(item => item.level) : [req.body.sector]

                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: { $in: FirstSuphierarchyDefaultLevel },
                });

                let answerDef = hierarchyDefault
                    .map((data) => data.employeename)
                    .flat();

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    result
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                FirstSuphierarchyDefaultLevel.includes(item.level) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return result;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    result = [...result, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        result
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    answerDef,
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        FirstSuphierarchyDefaultLevel.includes(data.level)
                    )
                    .map((item) => item.employeename[0]);
                // console.log(answerDeoverall, "answerDeoverall")
                resultedTeam = result
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            // branch: userObj.branch,
                            // unit: userObj.unit,
                            // team: userObj.team,
                            // companyname: userObj.username,
                            // empcode: userObj.empcode,
                            // adjchangereason: userObj.adjchangereason,
                            // adjapplydate: userObj.adjapplydate,
                            // adjustmenttype: userObj.adjustmenttype,
                            // adjstatus: userObj.adjstatus,
                            // removedondate: userObj.removedondate,
                            // userid: userObj.userid,
                            // selectedDate: userObj.selectedDate,
                            // selectedShifTime: userObj.selectedShifTime,
                            // pluseshift: userObj.pluseshift,
                            // adjchangeshiftime: userObj.adjchangeshiftime,
                            // todate: userObj.todate,
                            // adjdate: userObj.adjdate,
                            // _id: userObj.id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                if (resultedTeam.length == 0) {

                    let sectorFinal = req.body.sector == "all"
                        ? ["Primary", "Secondary", "Tertiary"] : [req.body.sector]

                    let FirstSuphierarchyDefaultLevel = await Hirerarchi.find({
                        supervisorchoose: req.body.username,
                    }, { level: 1 });

                    FirstSuphierarchyDefaultLevel = req.body.sector == "all" ? FirstSuphierarchyDefaultLevel.map(item => item.level) : [req.body.sector]

                    hierarchyfirstlevel = await Hirerarchi.countDocuments({ supervisorchoose: req.body.username, level: { $in: FirstSuphierarchyDefaultLevel }, });
                    //  let hierarchySecond2 = await Hirerarchi.find({});
                    hierarchySecond = await Hirerarchi.find(
                        {},
                        { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                    );

                    hierarchyDefault = await Hirerarchi.find({
                        supervisorchoose: req.body.username,
                        //  level: { $nin: sectorFinal },

                    });

                    // console.log(hierarchySecond.length, "hierarchyDefault")

                    let answerDef = hierarchyDefault
                        .map((data) => data.employeename)
                        .flat();

                    // console.log(answerDef, "answerDef")

                    function findEmployeesRecursive(
                        currentSupervisors,
                        processedSupervisorsallsector,
                        resultsectorother
                    ) {
                        const filteredData = hierarchySecond.filter((item) =>
                            item.supervisorchoose.some(
                                (supervisor) =>
                                    currentSupervisors.includes(supervisor) &&
                                    !processedSupervisorsallsector.has(supervisor)
                            )
                        );

                        if (filteredData.length === 0) {
                            return resultsectorother;
                        }

                        const newEmployees = filteredData.reduce((employees, item) => {
                            employees.push(...item.employeename);
                            processedSupervisorsallsector.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                            return employees;
                        }, []);

                        const uniqueNewEmployees = [...new Set(newEmployees)];
                        resultsectorother = [...resultsectorother, ...filteredData];
                        // console.log(result, "result")
                        return findEmployeesRecursive(
                            uniqueNewEmployees,
                            processedSupervisorsallsector,
                            resultsectorother
                        );
                    }

                    const processedSupervisorsallsector = new Set();
                    const filteredOverallItem = findEmployeesRecursive(
                        answerDef,
                        processedSupervisorsallsector,
                        []
                    );

                    // console.log(processedSupervisorsallsector, "processedSupervisorsallsector");
                    //  console.log(filteredOverallItem.map((item) => item.employeename), "filteredOverallItem");

                    let answerDeoverall = filteredOverallItem.map((item) => item.employeename ? item.employeename[0] : "");

                    // console.log("Count of data in other sectors:", answerDeoverall);

                    filteredoverallsectorall = resultsectorother.filter((data) =>
                        answerDeoverall.includes(data.companyname)
                    ).length;

                    // console.log("filteredoverallsectorall:", filteredoverallsectorall);
                }




                // let hierarchyallfinal = await Hirerarchi.find({
                //   employeename: { $in: answerDeoverall.map((item) => item) },
                //   level: req.body.sector,
                // });
                // hierarchyFinal =
                //   req.body.sector === "all"
                //     ? answerDeoverall.length > 0
                //       ? [].concat(...answerDeoverall)
                //       : []
                //     : hierarchyallfinal.length > 0
                //       ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                //       : [];

                // primaryhierarchyall = resultedTeam
                //   .filter((item) => item.level == "Primary")
                //   .map((item) => item.companyname);

                // secondaryhierarchyall = resultedTeam
                //   .filter((item) => item.level == "Secondary")
                //   .map((item) => item.companyname);

                // tertiaryhierarchyall = resultedTeam
                //   .filter((item) => item.level == "Tertiary")
                //   .map((item) => item.companyname);
            }

            //my + all hierarchy list dropdown

            if (
                req.body.hierachy === "myallhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||
                    listpageaccessmode === "Overall")
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );

                let sectorFinal = req.body.sector == "all"
                    ? ["Primary", "Secondary", "Tertiary"] : [req.body.sector]

                let FirstSuphierarchyDefaultLevel = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                }, { level: 1 });

                FirstSuphierarchyDefaultLevel = req.body.sector == "all" ? FirstSuphierarchyDefaultLevel.map(item => item.level) : [req.body.sector]

                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: { $in: FirstSuphierarchyDefaultLevel },
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    result
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                FirstSuphierarchyDefaultLevel.includes(item.level) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return result;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    result = [...result, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        result
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        FirstSuphierarchyDefaultLevel.includes(data.level)
                    )
                    .map((item) => item.employeename[0]);
                filteredoverall = result
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            // branch: userObj.branch,
                            // unit: userObj.unit,
                            // team: userObj.team,
                            // empcode: userObj.empcode,
                            // adjchangereason: userObj.adjchangereason,
                            // adjapplydate: userObj.adjapplydate,
                            // adjustmenttype: userObj.adjustmenttype,
                            // adjstatus: userObj.adjstatus,
                            // removedondate: userObj.removedondate,
                            // userid: userObj.userid,
                            // selectedDate: userObj.selectedDate,
                            // selectedShifTime: userObj.selectedShifTime,
                            // pluseshift: userObj.pluseshift,
                            // adjchangeshiftime: userObj.adjchangeshiftime,
                            // todate: userObj.todate,
                            // adjdate: userObj.adjdate,
                            // _id: userObj.id,
                            // createdAt: userObj.createdAt,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));



                //alert there is no sector
                if (filteredoverall.length == 0) {

                    let hierarchySecond2 = await Hirerarchi.find();
                    hierarchyfirstlevel = await Hirerarchi.countDocuments({ supervisorchoose: req.body.username, level: req.body.sector, });
                    // console.log(hierarchyfirstlevel, "hierarchyfirstlevel")

                    function findEmployeesRecursive(currentSupervisors, processedSupervisorsallsector, resultsectorother) {
                        const filteredData = hierarchySecond2.filter((item) =>
                            item.supervisorchoose.some(
                                (supervisor) =>
                                    currentSupervisors.includes(supervisor) &&
                                    !processedSupervisorsallsector.has(supervisor)
                            )
                        );

                        // console.log(filteredData.length, "l;lp");
                        if (filteredData.length === 0) {
                            return resultsectorother; // No more employees to process
                        }

                        // Collect new employees
                        const newEmployees = filteredData.reduce((employees, item) => {
                            employees.push(...item.employeename);
                            processedSupervisorsallsector.add(item.supervisorchoose[0]); // Track processed supervisors
                            return employees;
                        }, []);

                        // Prevent duplicates
                        const uniqueNewEmployees = [...new Set(newEmployees)];

                        // **Modify `resultall` in place** instead of reassigning it
                        resultsectorother.push(...filteredData);

                        // console.log(result, "resultall1");

                        // Recursive call with new employees
                        return findEmployeesRecursive(uniqueNewEmployees, processedSupervisorsallsector, resultsectorother);
                    }

                    const processedSupervisorsallsector = new Set();
                    // const resultall = []; // Define `resultall` outside to maintain reference

                    const filteredOverallItem = findEmployeesRecursive(
                        [req.body.username],
                        processedSupervisorsallsector,
                        resultsectorother // Pass the reference instead of a new array
                    );

                    // console.log(processedSupervisorsallsector, "processedSupervisorsallsector");
                    //   console.log(filteredOverallItem.map((item) => item.employeename), "filteredOverallItem");

                    let answerDeoverall = filteredOverallItem.map((item) => item.employeename ? item.employeename[0] : "");

                    // console.log("Count of data in other sectors:", answerDeoverall);

                    filteredoverallsectorall = resultsectorother.filter((data) =>
                        answerDeoverall.includes(data.companyname)
                    ).length;

                    // console.log("filteredoverallsectorall:", filteredoverallsectorall);
                }

                // let hierarchyallfinal = await Hirerarchi.find({
                //   employeename: { $in: answerDeoverall.map((item) => item) },
                //   level: req.body.sector,
                // });
                // hierarchyFinal =
                //   req.body.sector === "all"
                //     ? answerDeoverall.length > 0
                //       ? [].concat(...answerDeoverall)
                //       : []
                //     : hierarchyallfinal.length > 0
                //       ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                //       : [];

                // primaryhierarchyfinal = filteredoverall
                //   .filter((item) => item.level == "Primary")
                //   .map((item) => item.companyname);

                // secondaryhierarchyfinal = filteredoverall
                //   .filter((item) => item.level == "Secondary")
                //   .map((item) => item.companyname);

                // tertiaryhierarchyfinal = filteredoverall
                //   .filter((item) => item.level == "Tertiary")
                //   .map((item) => item.companyname);
            }

            if (listpageaccessmode === "Reporting to Based") {
                reportingtobaseduser = result.map((userObj) => {
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        // branch: userObj.branch,
                        // unit: userObj.unit,
                        // team: userObj.team,
                        // empcode: userObj.empcode,
                        // adjchangereason: userObj.adjchangereason,
                        // adjapplydate: userObj.adjapplydate,
                        // adjustmenttype: userObj.adjustmenttype,
                        // adjstatus: userObj.adjstatus,
                        // removedondate: userObj.removedondate,
                        // userid: userObj.userid,
                        // selectedDate: userObj.selectedDate,
                        // selectedShifTime: userObj.selectedShifTime,
                        // pluseshift: userObj.pluseshift,
                        // adjchangeshiftime: userObj.adjchangeshiftime,
                        // todate: userObj.todate,
                        // adjdate: userObj.adjdate,
                        // _id: userObj.id,
                        level: "",
                        control: "",
                    };
                });
            }

            // resultAccessFilter =
            //   req.body.hierachy === "myhierarchy" &&
            //     (listpageaccessmode === "Hierarchy Based" ||
            //       listpageaccessmode === "Overall")
            //     ? resulted
            //     : req.body.hierachy === "allhierarchy" &&
            //       (listpageaccessmode === "Hierarchy Based" ||
            //         listpageaccessmode === "Overall")
            //       ? resultedTeam
            //       : req.body.hierachy === "myallhierarchy" &&
            //         (listpageaccessmode === "Hierarchy Based" ||
            //           listpageaccessmode === "Overall")
            //         ? filteredoverall
            //         : reportingtobaseduser;


            let finalsupervisor = req.body.hierachy == "myhierarchy" ? resulted?.map(Data => Data?.companyname) : req.body.hierachy == "allhierarchy" ? resultedTeam?.map(Data => Data?.companyname) : filteredoverall?.map(Data => Data?.companyname)
            // console.log(finalsupervisor, "finalsupervisor")
            const restrictTeam = await Hirerarchi.aggregate([
                {
                    $match: {
                        $or: [
                            {
                                supervisorchoose: { $in: finalsupervisor } // Matches if supervisorchoose field has a value in finalsupervisor
                            },
                            {
                                employeename: { $in: finalsupervisor }     // Matches if employeename field has a value in finalsupervisor
                            }
                        ],
                        level: { $in: levelFinal } // Matches if level field has a value in levelFinal
                    },
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);

            let restrictListTeam = restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
            // console.log(restrictListTeam, restrictTeam, "restrictListTeam")
            resultAccessFilterHierarchy = req.body.hierachy === "myhierarchy" ? resulted : req.body.hierachy === "allhierarchy" ? resultedTeam : filteredoverall;
            resultAccessFilter = restrictListTeam?.length > 0 ? resultAccessFilterHierarchy?.filter(data => restrictListTeam?.includes(data?.companyname)) : [];
            // console.log(resultAccessFilter, "resultpage")
            // console.log(resultAccessFilter, resultAccessFilterHierarchy, filteredoverallsectorall, "oooo")
        } catch (err) {
            console.log(err, "errver")
            return next(new ErrorHandler("Records not found!", 404));
        }

        return res.status(200).json({
            // result
            // resulted,
            // resultedTeam,
            // branch,
            // hierarchy,
            // overallMyallList,
            hierarchyfirstlevel,
            filteredoverallsectorall,
            resultAccessFilterHierarchy: resultAccessFilterHierarchy.length,
            resultAccessFilter,
            // primaryhierarchy,
            //  secondaryhierarchy,
            //  tertiaryhierarchy,
            //  primaryhierarchyall,
            //  secondaryhierarchyall,
            //  tertiaryhierarchyall,
            //  primaryhierarchyfinal,
            //  secondaryhierarchyfinal, tertiaryhierarchyfinal,
        });
    }
);


exports.getAllTeamShiftHierarchyListNotificationCount = catchAsyncErrors(
    async (req, res, next) => {
        let result,
            reportingtobaseduser,
            clientuserid,
            hierarchy,
            resultAccessFilter,
            secondaryhierarchyfinal,
            tertiaryhierarchyfinal,
            primaryhierarchyfinal,
            hierarchyfilter,
            filteredoverall,
            primaryhierarchy,
            hierarchyfilter1,
            secondaryhierarchy,
            hierarchyfilter2,
            tertiaryhierarchy,
            primaryhierarchyall,
            secondaryhierarchyall,
            tertiaryhierarchyall,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames,
            hierarchyFinal,
            hierarchyDefault,
            reportingusers, hierarchyfirstlevel;
        let resultAccessFilterHierarchy = [];
        let resultsectorother = [];
        let filteredoverallsectorall = [];


        // const vendorNames = req.body.vendor.map((vendor) => vendor.value);
        try {
            const { listpageaccessmode } = req.body;
            let clientidsmap;
            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]

            // if (listpageaccessmode === "Reporting to Based") {
            //     let usersss = await User.find(
            //         {
            //             enquirystatus: {
            //                 $nin: ["Enquiry Purpose"],
            //             },
            //             resonablestatus: {
            //                 $nin: [
            //                     "Not Joined",
            //                     "Postponed",
            //                     "Rejected",
            //                     "Closed",
            //                     "Releave Employee",
            //                     "Absconded",
            //                     "Hold",
            //                     "Terminate",
            //                 ],
            //             },
            //             reportingto: req.body.username,
            //         },
            //         {
            //             empcode: 1,
            //             companyname: 1,
            //         }
            //     ).lean();
            //     const companyNames = usersss.map((user) => user.companyname);
            //     let clientids = await ClientUserid.find(
            //         {
            //             // projectvendor: { $in: vendorNames },
            //             empname: { $in: companyNames },
            //         },
            //         { userid: 1 }
            //     ).lean();
            //     clientidsmap = clientids.map((user) => user.userid);
            // }

            let prodresult = await User.aggregate([
                {
                    $match: {
                        "shiftallot.adjstatus": "Adjustment",
                        // ...(listpageaccessmode === "Reporting to Based"
                        //     ? { user: { $in: clientidsmap } }
                        //     : {})
                    }
                },
                {
                    $project: {
                        shiftallot: {
                            $filter: {
                                input: "$shiftallot",
                                as: "item",
                                cond: { $eq: ["$$item.adjstatus", "Adjustment"] } // Filter only matching `adjstatus`
                            }
                        }
                    }
                }
            ]);

            // clientuserid = await ClientUserid.find(
            //     { loginallotlog: { $exists: true, $ne: [] } },
            //     { empname: 1, userid: 1, loginallotlog: 1, projectvendor: 1 }
            // ).lean();

            result = prodresult.flatMap(d => d.shiftallot)
                .map((item) => {


                    return {

                        ...item,
                        companyname: item.username
                    };
                });
            // console.log(result, "rrrrrnoti")
            resultsectorother = result





            //my + all hierarchy list dropdown

            if (
                req.body.hierachy === "myallhierarchy"
                // &&
                // (listpageaccessmode === "Hierarchy Based" ||
                //     listpageaccessmode === "Overall")
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );

                let sectorFinal = req.body.sector == "all"
                    ? ["Primary", "Secondary", "Tertiary"] : [req.body.sector]

                let FirstSuphierarchyDefaultLevel = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                }, { level: 1 });

                FirstSuphierarchyDefaultLevel = req.body.sector == "all" ? FirstSuphierarchyDefaultLevel.map(item => item.level) : [req.body.sector]

                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,
                    level: { $in: FirstSuphierarchyDefaultLevel },
                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    result
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                FirstSuphierarchyDefaultLevel.includes(item.level) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return result;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]);
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    result = [...result, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        result
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        FirstSuphierarchyDefaultLevel.includes(data.level)
                    )
                    .map((item) => item.employeename[0]);
                // console.log(answerDeoverall, "answerDeoverallnoti")

                filteredoverall = result
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            // branch: userObj.branch,
                            // unit: userObj.unit,
                            // team: userObj.team,
                            // empcode: userObj.empcode,
                            // adjchangereason: userObj.adjchangereason,
                            // adjapplydate: userObj.adjapplydate,
                            // adjustmenttype: userObj.adjustmenttype,
                            // adjstatus: userObj.adjstatus,
                            // removedondate: userObj.removedondate,
                            // userid: userObj.userid,
                            // selectedDate: userObj.selectedDate,
                            // selectedShifTime: userObj.selectedShifTime,
                            // pluseshift: userObj.pluseshift,
                            // adjchangeshiftime: userObj.adjchangeshiftime,
                            // todate: userObj.todate,
                            // adjdate: userObj.adjdate,
                            // _id: userObj.id,
                            // createdAt: userObj.createdAt,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                // console.log(filteredoverall, "filteredoverallnoti")


                //alert there is no sector
                if (filteredoverall.length == 0) {

                    let hierarchySecond2 = await Hirerarchi.find();
                    hierarchyfirstlevel = await Hirerarchi.countDocuments({ supervisorchoose: req.body.username, level: req.body.sector, });

                    function findEmployeesRecursive(currentSupervisors, processedSupervisorsallsector, resultsectorother) {
                        const filteredData = hierarchySecond2.filter((item) =>
                            item.supervisorchoose.some(
                                (supervisor) =>
                                    currentSupervisors.includes(supervisor) &&
                                    !processedSupervisorsallsector.has(supervisor)
                            )
                        );

                        if (filteredData.length === 0) {
                            return resultsectorother;
                        }

                        const newEmployees = filteredData.reduce((employees, item) => {
                            employees.push(...item.employeename);
                            processedSupervisorsallsector.add(item.supervisorchoose[0]);
                            return employees;
                        }, []);

                        const uniqueNewEmployees = [...new Set(newEmployees)];

                        resultsectorother.push(...filteredData);

                        ;

                        return findEmployeesRecursive(uniqueNewEmployees, processedSupervisorsallsector, resultsectorother);
                    }

                    const processedSupervisorsallsector = new Set();

                    const filteredOverallItem = findEmployeesRecursive(
                        [req.body.username],
                        processedSupervisorsallsector,
                        resultsectorother
                    );



                    let answerDeoverall = filteredOverallItem.map((item) => item.employeename ? item.employeename[0] : "");


                    filteredoverallsectorall = resultsectorother.filter((data) =>
                        answerDeoverall.includes(data.companyname)
                    ).length;

                }


            }

            // if (listpageaccessmode === "Reporting to Based") {
            //     reportingtobaseduser = result.map((userObj) => {
            //         return {
            //             ...userObj,
            //             companyname: userObj.companyname,

            //             level: "",
            //             control: "",
            //         };
            //     });
            // }



            let finalsupervisor = req.body.hierachy == "myhierarchy" ? resulted?.map(Data => Data?.companyname) : req.body.hierachy == "allhierarchy" ? resultedTeam?.map(Data => Data?.companyname) : filteredoverall?.map(Data => Data?.companyname)
            const restrictTeam = await Hirerarchi.aggregate([
                {
                    $match: {
                        $or: [
                            {
                                supervisorchoose: { $in: finalsupervisor }
                            },
                            {
                                employeename: { $in: finalsupervisor }
                            }
                        ],
                        level: { $in: levelFinal }
                    },
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            },
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew"
                                                ]
                                            }
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData"
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);

            let restrictListTeam = restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
            // console.log(restrictListTeam, restrictTeam, "restrictListTeamnoti")
            resultAccessFilterHierarchy = req.body.hierachy === "myhierarchy" ? resulted : req.body.hierachy === "allhierarchy" ? resultedTeam : filteredoverall;
            resultAccessFilter = restrictListTeam?.length > 0 ? resultAccessFilterHierarchy?.filter(data => restrictListTeam?.includes(data?.companyname)) : [];
            // console.log(resultAccessFilter.length, "resultcouint")
            // console.log(resultAccessFilter, resultAccessFilterHierarchy, filteredoverallsectorall, "oooo")
        } catch (err) {
            console.log(err, "errver")
            return next(new ErrorHandler("Records not found!", 404));
        }

        return res.status(200).json({
            hierarchyfirstlevel,
            filteredoverallsectorall,
            resultAccessFilterHierarchy: resultAccessFilterHierarchy.length,
            resultAccessFilter,
            count: resultAccessFilter.length
        });
    }
);


