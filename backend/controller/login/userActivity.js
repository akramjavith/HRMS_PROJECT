const userActivity = require('../../model/login/userActivity');
const userActivityScreenshot = require('../../model/login/userActivityScreenshot');
const ErrorHandler = require('../../utils/errorhandler');
const catchAsyncErrors = require("../../middleware/catchAsyncError");
const User = require("../../model/login/auth");
const moment = require("moment");
const path = require('path');
const fs = require('fs');

exports.createUserActivity = catchAsyncErrors(async (req, res, next) => {
    const activityArray = req.body.activity;

    // Ensure req.body.activity is an array
    if (!Array.isArray(activityArray)) {
        return res.status(400).json({
            message: 'Invalid data format. Expected an array of activity objects.',
            success: false
        });
    }

    // Collect all usernames to query the User collection in one go
    const usernamesSet = new Set();
    activityArray.forEach(event => {
        usernamesSet.add(event.username.trim());
    });

    // Find all users in one query
    const usernames = Array.from(usernamesSet);
    let users = await User.find({ username: { $in: usernames } }, 'username company branch unit team department companyname empcode').lean();

    // Create a map of users for quick lookup
    let usersMap = {};
    users.forEach(user => {
        usersMap[user.username] = user;
    });

    // Process activityArray and enrich it with user details or mark as Mismatched
    let enrichedActivityArray = activityArray.map(event => {
        const username = event.username.trim();
        const foundData = usersMap[username] || {};  // Find user in usersMap or return an empty object

        return {
            ...event,  // Include original event data
            company: foundData.company || "",  // Fill user data if found, else empty string
            branch: foundData.branch || "",
            team: foundData.team || "",
            unit: foundData.unit || "",
            employeename: foundData.companyname || "",
            department: foundData.department || "",
            employeeid: String(foundData?._id) || "",
            employeecode: foundData.empcode || "",
            date: moment(event.timestamp).format('YYYY-MM-DD'),
            time: moment(event.timestamp).format('HH:mm:ss'),
            status: foundData.username ? "Matched" : "Mismatched"  // Determine status based on whether user was found
        };
    });
    try {
        // Insert all enriched activity logs in one go
        await userActivity.insertMany(enrichedActivityArray);

        return res.status(200).json({
            message: 'Successfully added all activity logs!',
            success: true
        });
    } catch (error) {
        // Handle any errors during the save process
        return res.status(500).json({
            message: 'Error saving activity logs.',
            error: error.message,
            success: false
        });
    }
});


exports.createUserActivityScreenshot = catchAsyncErrors(async (req, res, next) => {
    const { macaddress, username, localip, devicename, timestamp } = req.body;

    // File data from multer (screenshot)
    const file = req.file;

    if (!file) {
        return res.status(400).json({
            message: 'No screenshot file uploaded.',
            success: false
        });
    }

    // Ensure req.body has the necessary fields
    if (!macaddress || !username || !localip || !devicename || !timestamp) {
        return res.status(400).json({
            message: 'Missing required fields.',
            success: false
        });
    }

    // Find user based on the username provided
    let user = await User.findOne({ username: username.trim() }, 'username company branch unit team department companyname empcode').lean();

    let enrichedActivity = {
        macaddress: macaddress,
        username: username.trim(),
        localip: localip,
        devicename: devicename,
        timestamp: new Date(timestamp),
        date: moment(timestamp).format('YYYY-MM-DD'),
        time: moment(timestamp).format('HH:mm:ss'),
        company: user?.company || "",  // Fill user data if found, else empty string
        branch: user?.branch || "",
        team: user?.team || "",
        unit: user?.unit || "",
        employeename: user?.companyname || "",
        department: user?.department || "",
        employeeid: String(user?._id) || "",
        employeecode: user?.empcode || "",
        status: user?.username ? "Matched" : "Mismatched",  // Determine status based on whether user was found

        // File metadata
        filename: file.filename,  // File name generated by multer
        filepath: file.path,      // File path generated by multer
        filesize: file.size       // File size in bytes
    };

    try {
        // Insert the activity log into the database
        await userActivityScreenshot.create(enrichedActivity);

        return res.status(200).json({
            message: 'Screenshot and activity log saved successfully!',
            success: true
        });
    } catch (error) {
        return res.status(500).json({
            message: 'Error saving activity log.',
            error: error.message,
            success: false
        });
    }
});

exports.deleteUserActivityScreenshot = catchAsyncErrors(async (req, res, next) => {
    try {
        // Get the timestamp 24 hours ago from the current time
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        // Find all records in MongoDB that are older than 24 hours
        const oldRecords = await userActivityScreenshot.find({ createdAt: { $lt: twentyFourHoursAgo } });
        // If there are records to delete
        if (oldRecords.length > 0) {
            // Get an array of file paths
            const filePaths = oldRecords.map(record => path.join('useractivity/', record.filename));
            // Delete all files that exist
            filePaths.forEach(filePath => {
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                    console.log(`File ${filePath} deleted successfully.`);
                } else {
                    console.log(`File ${filePath} does not exist.`);
                }
            });

            // Delete all records in MongoDB at once
            const deleteResult = await userActivityScreenshot.deleteMany({ createdAt: { $lt: twentyFourHoursAgo } });

            return `${deleteResult.deletedCount} old records and associated files deleted successfully.`
        } else {
            return "No old records found."
        }
    } catch (error) {
        return res.status(500).json({
            success: false,
            message: `Error deleting old files and records: ${error.message}`
        });
    }
});


exports.dynamicQueryUserActivityController = catchAsyncErrors(async (req, res, next) => {
    try {
        const { aggregationPipeline } = req.body;

        const users = await userActivity.aggregate(aggregationPipeline);
        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


exports.getAllUserActivityStorage = catchAsyncErrors(async (req, res, next) => {
    let eventstorage, useractivityscreenshot;

    try {
        [eventstorage, useractivityscreenshot] = await Promise.all([
            await userActivity.aggregate([
                {
                    $group: {
                        _id: null,
                        usernames: { $addToSet: "$username" },
                        systems: { $addToSet: "$devicename" }
                    }
                },
                {
                    $project: {
                        _id: 0,
                        usernames: {
                            $filter: {
                                input: "$usernames",
                                as: "username",
                                cond: { $ne: ["$$username", ""] } // Exclude empty strings
                            }
                        },
                        systems: {
                            $filter: {
                                input: "$systems",
                                as: "devicename",
                                cond: { $ne: ["$$devicename", ""] } // Exclude empty strings
                            }
                        }
                    }
                }
            ]),
            await userActivityScreenshot.aggregate([
                {
                    $group: {
                        _id: null,
                        usernames: { $addToSet: "$username" },
                        systems: { $addToSet: "$devicename" }
                    }
                },
                {
                    $project: {
                        _id: 0,
                        usernames: {
                            $filter: {
                                input: "$usernames",
                                as: "username",
                                cond: { $ne: ["$$username", ""] } // Exclude empty strings
                            }
                        },
                        systems: {
                            $filter: {
                                input: "$systems",
                                as: "devicename",
                                cond: { $ne: ["$$devicename", ""] } // Exclude empty strings
                            }
                        }
                    }
                }
            ])])
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!eventstorage) {
        return next(new ErrorHandler("Events not found", 400));
    }

    return res.status(200).json({ eventstorage, useractivityscreenshot });
});

exports.dynamicQueryUserActivityScreenshotController = catchAsyncErrors(async (req, res, next) => {
    try {
        const { aggregationPipeline } = req.body;
        const users = await userActivityScreenshot.aggregate(aggregationPipeline);
        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});
